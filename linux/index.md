# Linux


Unlock to view this content.

<!--more-->

{{< secret "linux" >}}

# 课堂划重点速记

### Linux期末考点

#### 第一章

目录以及对应的作用

切换到某个目录

几个目录的特殊符号

常用命令ls -l 以及输出结果含义 -a 

复制删除移动文件

创建目录，删除目录命令

#### 第二章

文件和目录的权限以及其含义（什么情况下能删除，什么情况下能复制，什么情况下能创建，什么情况下能创建目录，什么情况下能删除目录）

备份文件tar命令的选项（主选项，必选项，备选项，源文件，压缩包，压缩包放在其他目录下如何实现，对压缩包进行还原要放在其他目录该怎么做）

如何搜索文件find命令（find+搜索范围+测试表达式，测试表达式：三个时间序列，文件类型的测试（哪些是普通文件，那些事目录文件）文件大小的测试，文件名称的测试，关于-exec选项的用法，以及-exec选项与管道符的“|”区别

链接文件（inode，什么是硬链接，什么是软连接，两者区别是什么，看试验任务）

文件权限（文件权限如何表示，如何改变文件权限，所属用户，所属组）

#### 第三章（无考点）

#### 第四章

用户和用户组相关的配置文件有哪些，文件内容是什么

用户管理的命令（添加，删除，修改用户属性。这三个命令一定会考（老师说的），复习ppt）

账号密码安全不作为考试点

进程管理（监控系统的运行状态top命令，cpu利用率怎么来的，系统的负载怎么来的）

计划任务（要会写计划任务的命令，记住语法，分时日月周，要会分析计划任务的执行什么样，能找出错误原因，并给出解决方案，看ppt）

磁盘管理（查看磁盘及其分区，查看磁盘每个分区的挂载位置，磁盘分区的步骤）

#### 第五章

服务器的配置，没有出考点

网络管理，写命令（ping netstat ifconfig，有一个命令要考）

#### 第六章

**重点**（30分左右）

bash，bash和shell的区别（随便记的，老师没说考）

输入输出重定向，命令历史记录，shell脚本的创建和执行，shell的变量（环境变量$PATH要考）

课后练习题要弄明白，**会变形考**

#### 第七章

gcc编译过程，gdb调试过程（断点+单步，查看变量值，退出）

ppt里上课讲的代码



---

# Linux期末考点

## 第一章&第二章

### 目录以及对应的作用

```
/bin	存放二进制可执行文件
/home	用户主目录的基点目录
/lib	存放标准程序设计库目录，又叫动态链接库目录
/etc	存放系统管理和配置文件目录
/dev	存放设备特殊文件目录
/usr	存放应用程序和文件目录
/proc	虚拟目录，是系统内存的映射
/root	系统管理员主目录
/var	存放系统产生的经常变化文件目录
/tmp	存放公用临时文件目录
```

### 切换到某个目录

```
cd 绝对路径
or
cd 相对路径
```

### 几个目录的特殊符号

```
.	当前目录
..	当前目录的上级目录
~	用户主目录
/	根目录
```

### 常用命令ls -l 以及输出结果含义 -a

![image-20240111134823013](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111134823013.png)

```
第一列：
第一个字母含义：
‘d’：目录文件；
‘-’：普通文件；
‘p’：管理文件；
‘l’：链接文件；
‘b’：块设备文件；
’c‘：字符设备文件；
‘s’：套接字文件。
后面九个字母分别3个为一组（r表示读权限,w表示写权限,x表示可执行权限,-表示无权限），第一组为表示所有者权限，第二组为表示组用户权限，第三组为表示其他用户组的权限。

第二列：
如果是目录的话，这个数字表示当前这个目录下面的一级目录个数（包含.和..）
如果是文件的话，数字表示硬链接个数（可以理解为一个文件的文件名个数）

第三列：
该文件或目录的所有者

第四列：
表示所属的

第五列：
文件的大小

第六、七、八列：
分别为月，号，时，都是最后修改时间

第九列
文件名
```

ls -i是一个 Linux 命令,用于显示文件和目录的 inode 号码以及它们的名称。

### 复制删除移动文件

```
cp [选项] 源文件或目录 目标文件或目录
选项：
-d 建立为符号链接
-f 强行复制
-i 覆盖目标文件前需要确认
-R或-r 递归复制

rm [选项] ...文件或目录...
选项：
-f 强制删除
-i 删除前询问
-R或-r 递归删除

mv [选项] 源文件或目录 目标文件或目录
选项：
-i -f 同上
```

### 创建目录，删除命令

```
mkdir [选项]... 目录名...
选项：
-m
```

### 文件和目录的权限以及其含义

（什么情况下能删除，什么情况下能复制，什么情况下能创建）

mkdir创建目录时，要求创建目录用户在当前目录中具有写权限。
使用rmdir删除目录时，需要拥有对删除目录父目录的写权限，目录被删除前应该是空的。
复制需要对源文件的读权限，和对目标目录的写权限。

### 备份文件tar命令

选项（主选项，必选项，备选项，源文件，压缩包，压缩包放在其他目录下如何实现，对压缩包进行还原要放在其他目录该怎么做）

```
tar [选项...] [文件或目录]...

主选项Actdrux
-A 新增
-c 建立新的备份文件
-t 列出备份文件内容
--delete 从备份文件中删除指定的文件
-r 附加到存档文件结尾
-u 仅将较新的文件附加到存档结尾
-x 从备份文件中还原文件

可选项
-v 显示指令执行过程

必选项
-f <备份文件> 指定备份文件

附加
-j 同时压缩为.tar.bz2
-z 同时压缩为.tar.gz
-C 解压至指定目录
```

### 搜索文件find命令

（find+搜索范围+测试表达式，测试表达式：三个时间序列，文件类型的测试（哪些是普通文件，那些事目录文件）文件大小的测试，文件名称的测试，关于-exec选项的用法，以及-exec选项与管道符的“|”区别

```
find [路径名...] [表达式]
表达式：
-amin n 查找最后n分钟被访问过的文件或目录
-atime n 查找最后nx24小时被访问过的文件或目录
-ctime n 查找最后n分钟改变状态的文件
-mtime n 查找在n天内被更改该过的文件或目录
-type<文件类型> 只寻找符合指定类型的文件（b为块设备文件，d为目录文件，c为字符设备文件，p为管道文件，l为符号链接文件，f为普通文件）
-size<文件大小> 查找符合指定的文件大小的文件
-name<范本样式> 指定字符串作文寻找文件或目录的范本样式
-exec<执行命令> 假设find命令回传值为true，则执行该命令
```

#### find命令之exec

-exec 参数后面跟的是 command 命令，如rm -f，它的终止是以;分号为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。

{} 花括号代表前面find查找出来的文件名。

例如：

```
find . -type f -exec ls -l {} \; 　
//匹配当前目录下的所有普通文件，并在 -exec 选项中使用 ls -l 命令将它们列出。
```

再例如：

```
find . -name “*.log” -exec cp {} test3 \;
//匹配当前目录下的所有以.log为后缀名的文件，并将他们复制到test3目录中
```

#### -exec和管道符|的区别

管道符的作用是传递文本流，可以看作是管道符将前面的命令输出为一个暂时的文本文件，这个文件是后面命令的操作对象，后面的命令将这个文件整体作为参数执行一次，而find命令默认是不支持这种格式的，所以find命令有一个-exec选项，而-exec选项是对传递到{}中每个查找到的结果依次执行一次-exec后面的命令。

也就是说，-exec和管道符|传递数据的方式或说是格式不同。

### 链接文件

（inode，什么是硬链接，什么是软连接，两者区别是什么，看试验任务）

inode（索引节点），存储了文件系统对象的一些元信息，比如：所有者、访问权限（读、写、执行）、类型（是文件还是目录）、内容修改时间、inode修改时间、上次访问时间、对应的文件系统存储块的地址，等等

硬链接
通过索引结点进行的链接。
硬链接文件的限制：
1.不允许给目录创建硬链接。
2.只有在同一文件系统的文件之间才能创建硬链接。

符号链接（软链接）
软链接文件包含另一个文件的路径名。可以给目录创建软连接，可以链接不同文件系统的文件。
但原文件位置移动，软链接会找不到原文件，但硬链接因索引结点会随着文件的移动而相应改变。

ln命令

```
ln [选项]... 源文件或目录 目标文件或目录
-s 建立软连接
```

### 文件权限

（文件权限如何表示，如何改变文件权限，所属用户，所属组）

- 读取权限（r）：用二进制位表示为 100，对应数字为 4
- 写入权限（w）：用二进制位表示为 010，对应数字为 2
- 执行权限（x）：用二进制位表示为 001，对应数字为 1

执行权限：包括对文件的执行，对文件夹cd访问，对目录的查找

chmod命令

```
chmod [who] [opt] [mode] 文件名或目录名...
who:
u 文件所有者
g 同组用户
o 其他用户

opt 表示操作：+,-,=

mode 表示权限：r,w,x


chmod [mode] 文件名或目录名...
rwx 111
r-x 101
...
e.g. chmod 777 a.sh
```

chgrp命令
改变指定文件所属的用户组

```
chgrp [选项]... 所属组 文件或目录...
所属组可以是组ID也可以是用户组名
```

chown命令
将指定文件的拥有者改为指定的用户或组

```
chown [选项]... [用户][:[组]] 文件...
```

## 第三章（无考点）

## 第四章

### 用户和用户组相关的配置文件及文件内容

/etc/passwd 账户相关信息
/etc/shadow 存放用户的加密密码
/etc/group 存放用户组的相关信息

### 用户管理的命令

（添加，删除，修改用户属性。这三个命令一定会考（老师说的），复习ppt）

useradd

```
添加用户
useradd [选项] 用户名
-d 指定用户主目录
-u 指定用户ID
-g 加入一个已存在的组
-G 加入一个附加组
-c 用户的注释信息
```

useradd添加用户之后，如果不使用passwd命令为用户设置密码，用户无法登录。

usermod

```
修改用户属性，如用户ID，用户组，用户主目录，shell等
usermod [选项] [参数] 用户名
-d 以下同上
-u
-g
-G
```

userdel

```
删除用户
userdel [选项] 用户名
-r 删除用户同时删除用户的主目录
```

groupadd

groupmod

```
-g 修改组编号
-n 修改组名
```

groupdel

groups

```
查看自己属于哪个组
```

（账号密码安全不作为考试点）

### 进程管理

（监控系统的运行状态top命令，cpu利用率怎么来的，系统的负载怎么来的）

系统通过监测和记录CPU的空闲时间和总时间来计算CPU使用率。
CPU使用率 =（1 - 空闲时间 / 总时间） * 100%

系统负载表示系统中当前正在运行的进程数量，其包括`可运行状态的进程数`和`不可中断休眠状态的进程数`的和。

ps

```
ps [选项]
-e 显示所有进程
-f 全格式
-h 不显示标题
a 显示终端上的所有进程，包括其他用户进程
r 只显示正在运行的进程
x 显示没有控制终端的进程
u 使用用户格式输出
最常用的三个参数aux
```

top

top命令是一个动态显示的过程

```
-d 间隔刷新时间
-q 无延迟刷新
-p 指定监控进程ID
```

### 计划任务

（要会写计划任务的命令，记住语法，分时日月周，要会分析计划任务的执行什么样，能找出错误原因，并给出解决方案，看ppt）

**1.计划任务的制定**
制定人
判断用户白名单/etc/cron.allow是否存在
若存在，则允许写入该名单的用户制定计划任务
若不存在，则判断用户是否写入/etc/cron.deny黑名单
若用户未写入黑名单，则可以制定计划任务
若/etc/cron.allow和/etc/cron.deny都不存在，所有用户都可以制定计划任务

定义位置
系统给每个被允许的用户定义了计划任务存放文件
root用户：/var/spool/cron/root
cat用户(普通用户)：/var/spool/cron/cat
dog用户(普通用户)：/var/spool/cron/dog

使用工具
crontab命令
crontab [-u user] [-e |-l |-r]
-u user：设置用户user的计划任务，一般由root用户运行；
		不加-u选项，设置当前登录用户的计划任务
-e：编辑某用户的crontab文件
-l：列出crontab文件里的内容
-r：删除某用户的crontab文件

描述计划
使用crontab -e命令编辑crontab文件，每一行表示一个计划任务![image-20240111162859542](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111162859542.png)

格式要求
crontab文件中每一行包括6个域：
分  时  日  月  周  命令

| 域   | 含义                       | 实例                         |
| ---- | -------------------------- | ---------------------------- |
| 分   | 一小时中的第几分钟执行任务 | 0-59之间的任意整数           |
| 时   | 一天中的第几个小时执行任务 | 0-23之间的任意整数           |
| 日   | 一个月中的第几天执行任务   | 1-31之间的任意整数           |
| 月   | 一年中的第几个月执行任务   | 1-12之间任意整数             |
| 周   | 一周中的周几执行任务       | 0-6之间任意整数（0表示周日） |

符号：

```
每一个时间	*
每隔一段时间	/
多个不固定的时间	,
某个固定的时间段	-
```

举个栗子：

```
3 11 * *  * tar -zvcPf  ~/“$USER”_txt.tar.gz ~/*.txt
每天在11点03分将用户主目录中的所有.txt文件创建一个以用户变量命名的tar压缩文件
```

**2.定时计划任务的执行**

执行原理
Linux系统默认安装并启动了一个守护进程-crond进程
crontab命令只要保存就会生效，但需要crond进程启动
![image-20240111170330268](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111170330268.png)
crond进程每分钟会在`文件`中检查是否有要执行的任务
`文件`，是/var/spool/cron/所有文件，也就是所有的crontab文件
如果又要执行的任务，就自动执行该任务

准备条件
命令行下执行命令时，系统调用进程的过程：
![image-20240111170924787](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111170924787.png)

```
ls命令——>PATH环境变量——>/bin/ls
```

crond进程执行定时任务时，加载/etc/crontab文件
根据SHELL变量找到shell解释器
根据PATH变量找到命令的可执行程序
![](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171036377.png)

记录过程
crond进程会将执行过的任务写入到计划任务的日志文件/var/log/cron中
![image-20240111171251081](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171251081.png)

记录结果
crond进程会将任务执行时输出到终端的结果发送邮件到用户的邮箱中，也就是文件/var/spool/mail/用户名
![image-20240111171540704](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171540704.png)

执行原理总结
![image-20240111171623435](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171623435.png)

**3.定时计划任务的调试**
![image-20240111171754226](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171754226.png)

调试案例
![image-20240111171823553](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171823553.png)

![](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111171823553.png)

### 磁盘管理

（查看磁盘及其分区，查看磁盘每个分区的挂载位置，磁盘分区的步骤）

hd表示IDE硬盘，sd表示SCSI硬盘，tty表示终端设备，lp表示打印机

fdisk命令
磁盘及分区管理工具，在硬盘设备中创建、删除、更改分区

```
fdisk [-l] [设备名称]
fdisk -l <磁盘> 列出分区表
fdisk -s <分区> 给出分区大小
```

mkfs命令 

```
mkfs -t ext4 /dev/sdb1 把sdb1分区格式化为ext4
```

df命令

```
检查文件系统的磁盘占用情况
```

du命令

```
统计目录或文件所占磁盘空间的大小
```

mount命令

```
mount命令可以实现对存储设备的挂载
mount -t 文件系统类型 存储设备 挂载点
卸载设备：umount
```

## 第五章

服务器的配置（没有出考点）

### 网络管理

写命令（ping netstat ifconfig，有一个命令要考）

ifconfig

```
ifconfig用于查看和更改网络接口的地址和参数
interface	网络接口名
up	激活网卡设备
down	关闭网卡设备
broadcast address	设置接口的广播地址
pointpoint	点对点方式
adress	指定设备的ip地址
netmask address	设置子网掩码
```

netstat

```
用于查看网络状态
-a 已建立连接的接口
-tulnp 目前已经启动的网络服务
```

ping

```
使用ICMP协议检测网络的连通情况
-c n 回应n次
```

## 第六章

**重点**（30分左右）

bash，bash和shell的区别（随便记的，老师没说考）

### 输入输出重定向

```
输入重定向
we < /etc/passwd
但由于大多数命令都是以参数的形式在命令行上指定输入文件的文件名，因此输入重定向并不经常使用。但当使用一个不接受文件名作为输入参数的命令，可以使用输入重定向。

输出重定向
ls > ls.out
但如果>后面的文件已经存在，则该文件会被重写。
如果要将一条命令的输出结果追加到指定文件的后面，可以使用追加重定向操作符>>。
ls >>ls.out

错误重定向
ls /usr/tmp 2> err.file
错误重定向(追加)
ls /usr/tmp 2>> err.file

为避免重写，可以开启noclobber功能
set -o noclobber
随后，如果重定向到一个已经存在的文件，则shell将报告出错信息，并不执行重定向命令。
```

### 管道

将一个命令的输出直接作为另一个命令的输入。

### 命令历史记录

```
环境变量HISTSIZE的值保存历史命令的总行数。
当从shell中退出时，最近执行的命令将保存在HISTFILE变量指定的文件中。
默认情况下，历史命令存放在~/.bash_history文件中。
如果要修改HISTSIZE或HISTFILE的值，需要写入.bash_profile文件中，重新登录bash才生效。
变量HISTFILESIZE的值决定了保存在HISTFILE中的历史行数。

HISTFILESIZE 定义了在 .bash_history 中保存命令的记录总数，可以理解为.bash_history文件中最多只有HISTFILESIZE行。

HISTSIZE 定义了 history 命令输出的记录数，即输出.bash_history文件中的最后HISTSIZE行。
```

### shell脚本的创建和执行

三种执行方式

**1.给脚本文件加上可执行权限，然后在命令行直接输入shell脚本文件名执行。**

```
$ chmod u+x pwd_script
$ ./pwd_script
```

启动新的shell来执行该脚本。
（一般情况下当前系统PATH变量没有包含当前工作目录，需要输入`./文件名`的方式或者是输入文件的全路径来执行）

```
#! /bin/bash
...
...
```

shell脚本的第1行放置一行特殊的字符串，决定调用执行的shell。
（如果脚本的前两个字符是#!，则系统将两个字符后的字符作为用来执行该脚本的命令解释器的绝对路径。）

**2.sh Shell脚本名**

```
$ sh pwd_script
```

启动新的shell来执行该脚本。
与方法一不同的是，该方法不需要对脚本的权限进行修改。

**3.shell脚本名**

```
$ . pwd_script
```

没有启动新的shell来执行该脚本。
整个运行都是在原来的shell下的，在这种方式下不需要提前对shell脚本进行权限修改。

### shell变量

一个变量就是内存中被命名的一块存储空间。

**变量的定义与使用：**

```
var=hello
```

如果字符串中包含空格，需要用括号把他们括起来，等号两边不能有空格。
在shell中，可以通过在变量名前加一个$来访问它的内容。
当为变量赋值时，只需要使用变量名。

**清除变量**
使用unset命令清除变量var

```
unset var
```

### 环境变量

一般用大写字母表示，以便跟用户在脚本中定义的变量区分开。

```
HOME 当前用户的主目录，即用户登陆时的默认目录
PATH 以冒号分隔的用来搜索命令的路径列表
PS1 命令提示符，root用户为#，bash中普通用户为$，在c shell中为%
PS2 二级提示符，用来提示后续输入，通常是>
IFS 输入域分隔符
TERM 用来设置用户的终端类型，系统主控台（Console）不用设置
```

查看环境变量

```
env 来查看所有环境变量
env $PATH 来查看PATH变量
```

（环境变量$PATH要考）

### 位置变量

或者称为位置参数。
shell提供的位置变量有$0,$1,$2,$3,$4,$5,$6,$7,$8,$9 共10个。
其中$0存放脚本名，$1~$9存放从左至右的命令行上的参数。

当命令行上命令参数超过9个时，shift命令可以把所有参数变量左移一个位置。原来的$1会被丢弃，$0不变

```
shitf [n]
//n是左移参数的个数，默认为1
```

### 特殊变量

```
$# 表示传递给脚本的实际参数个数
$$ 当前shell脚本的进程号
$* 位置参数的值，各个参数之间用IFS中定义的字符隔开
$@ 也表示位置参数的值，但不是使用IFS字符隔开，故当IFS为空时，参数值不会结合在一起
$! 上一个后台命令的进程号
$? 执行最后一条命令的退出状态
```

课后练习题要弄明白，**会变形考**

## 第七章

### gcc编译过程

![image-20231213111340078](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231213111340078.png)

```
（1）预处理（Pre-Processing）

展开源代码中的宏，并将代码中包含的头文件的内容插入到源代码中，形成.i文件。(代码中以#开头的内容全部在预处理阶段完成)

（2）编译（Compiling）

GCC调用ccl检查代码的规范性，是否有语法错误等，检查无误后，把代码翻译成汇编语言，生成汇编代码.s。

（3）汇编（Assembling）

GCC调用AS汇编器处理汇编代码.s文件生成二进制目标文件.o但.c中所引用的其他文件中函数(如printf) 的内存位置尚未定义。

（4）链接（Linking）

GCC调用LD将程序的目标文件与来所需的所有附加的目标文件连接起，最终生成可执行文件。
```

### gdb调试过程

```
（断点+单步，查看变量值，退出）
```

![image-20240111145050210](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111145050210.png)

ppt里上课讲的代码

### Linux下C编程

**系统调用：**Linux内核中设置了一组用于实现各种系统功能的子程序。

系统调用由操作系统核心提供，运行于核心态；普通的函数调用由函数库或用户自己提供，运行于用户态。

**C库函数:** Linux核心提供了些C语言函数库，习惯上把这些函数也称为系统调用。

![image-20231213105517552](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231213105517552.png)

{{< /secret >}}

